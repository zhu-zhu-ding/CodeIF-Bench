{"namespace": "benedict.utils.type_util.is_json_serializable", "completion": "\nimport json\n\ndef is_json_serializable(val):\n    # Try to serialize the value using json.dumps\n    try:\n        json.dumps(val)\n    except (TypeError, OverflowError):  # Catch types that cannot be serialized or overflow errors\n        return False\n    else:\n        return True\n\n# Function to check the correctness of the is_json_serializable function\ndef check():\n    test_cases = [\n        ({\"key\": \"value\"}, True),      # Dictionary\n        (\"string\", True),              # String\n        (123, True),                   # Integer\n        (True, True),                  # Boolean\n        ([1, \"two\", 3], True),         # List\n        ((1, \"two\", 3), True),         # Tuple\n        ({}, True),                    # Empty dictionary\n        ({1: 2, 3: 4}, True),          # Dictionary with integers\n        (set([1, 2, 3]), False),       # Set not serializable\n        ([lambda x: x], False),        # Lambda function not serializable\n        (object(), False),             # Arbitrary object not serializable\n        (None, True)                   # None Type\n    ]\n    \n    for val, expected in test_cases:\n        result = is_json_serializable(val)\n        assert result == expected, f\"Expected {expected} but got {result} for input {val}\"\n    print(\"All tests passed!\")\n\ncheck()\n", "Result": "Pass"}
{"namespace": "feedparser.urls.convert_to_idn", "completion": "\nimport idna\n\ndef convert_to_idn(url):\n    from urllib.parse import urlparse, urlunparse\n    \n    # Parse the URL to separate components\n    parsed_url = urlparse(url)\n    \n    # Extract the hostname (domain) part of the URL\n    hostname = parsed_url.hostname\n    \n    # Check if the hostname is already in ASCII format\n    if hostname is None or hostname.encode('ascii'):\n        # If hostname is None or contains only ASCII characters, return the original URL\n        return url\n    \n    # Convert the hostname to IDN format\n    try:\n        idn_hostname = idna.encode(hostname).decode('utf-8')\n    except idna.IDNAError as e:\n        raise ValueError(f\"Error converting to IDN: {e}\")\n    \n    # Reconstruct the URL with the new IDN hostname\n    new_url = urlunparse(parsed_url._replace(netloc=parsed_url.netloc.replace(hostname, idn_hostname)))\n    \n    return new_url\n\n# Example usage\nprint(convert_to_idn(\"http://\u4f8b\u5b50.com/\"))\n", "Result": "Error"}
{"namespace": "googleapiclient._helpers.parse_unique_urlencoded", "completion": "\nfrom urllib.parse import parse_qsl, urlparse, urlunparse\n\ndef parse_unique_urlencoded(content):\n    \"\"\"\n    Parse unique key-value parameters from URL-encoded content.\n    \n    Parameters:\n        content (str): URL-encoded key-value pairs.\n        \n    Returns:\n        dict: The key-value pairs from the input content.\n        \n    Raises:\n        ValueError: If any key is repeated.\n    \"\"\"\n    # Parse the query part of the URL-encoded content\n    parsed = urlparse('?'+content)\n    params = parse_qsl(parsed.query)\n    \n    # Convert to dictionary while ensuring no keys are repeated\n    result = {}\n    for key, value in params:\n        if key in result:\n            raise ValueError(f\"Duplicate key detected: {key}\")\n        else:\n            result[key] = value\n    \n    return result\n\n# Example usage:\ntry:\n    print(parse_unique_urlencoded('name=John&age=30'))\n    print(parse_unique_urlencoded('name=John&age=30&name=Jane'))  # This should raise an error\nexcept ValueError as e:\n    print(e)\n", "Result": "Pass"}
{"namespace": "jinja2.async_utils.auto_aiter", "completion": "\nimport asyncio\nfrom collections.abc import AsyncIterable, Iterable\n\nasync def auto_aiter(iterable):\n    \"\"\"\n    Create an asynchronous iterator from the given iterable.\n\n    If the iterable supports asynchronous iteration (i.e., has an __aiter__ method),\n    this function will yield items asynchronously. Otherwise, it will yield items synchronously.\n\n    Parameters:\n        iterable: Union[AsyncIterable, Iterable].\n            The input iterable from which the iterator is created.\n\n    Returns:\n        AsyncIterator. The created asynchronous iterator.\n    \"\"\"\n\n    # Check if the iterable is an instance of AsyncIterable\n    if isinstance(iterable, AsyncIterable):\n        async for item in iterable:\n            yield item\n    else:\n        # For synchronous iterables, wrap them in an async generator\n        for item in iterable:\n            yield item\n\n# Example Usage\ndef main():\n    # Synchronous iterable example\n    sync_iter = [1, 2, 3]\n    async for item in auto_aiter(sync_iter):\n        print(item)\n\n    # Asynchronous iterable example\n    class AsyncList(AsyncIterable):\n        def __init__(self, lst):\n            self.lst = lst\n\n        def __aiter__(self):\n            return self.AsyncIterator(self)\n\n        class AsyncIterator:\n            def __init__(self, parent):\n                self.parent = parent\n                self.index = 0\n\n            async def __anext__(self):\n                if self.index >= len(self.parent.lst):\n                    raise StopAsyncIteration\n                await asyncio.sleep(0.1)  # Simulate async operation\n                current_item = self.parent.lst[self.index]\n                self.index += 1\n                return current_item\n\n    async_list = AsyncList([1, 2, 3])\n    async for item in auto_aiter(async_list):\n        print(item)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n", "Result": "Error"}
{"namespace": "csvs_to_sqlite.utils.table_exists", "completion": "\nimport sqlite3\n\ndef table_exists(conn, table):\n    \"\"\"\n    Check if a table exists in the database.\n\n    :param conn: Connection. The connection to the database.\n    :param table: String. The name of the table to check.\n    :return: Bool. True if the table exists, False otherwise.\n    \"\"\"\n    cursor = conn.cursor()\n    # Check if the table exists\n    cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name='{table}'\")\n    result = cursor.fetchone()\n\n    # If there's a result, it means the table exists\n    return result is not None\n\n# Example usage with a SQLite database\nif __name__ == \"__main__\":\n    conn = sqlite3.connect('example.db')  # Connect to an existing database or create one\n    print(table_exists(conn, 'my_table'))\n    conn.close()\n", "Result": "Pass"}
{"namespace": "sqlitedict.SqliteDict.get_tablenames", "completion": "\nimport sqlite3\nimport os\n\ndef get_tablenames(filename):\n    \"\"\"\n    Retrieves the names of the tables in an SQLite database.\n\n    :param filename: String. The name of the SQLite database file.\n    :return: List of strings. The names of the tables in the SQLite database.\n    :raises IOError: If the provided file path does not exist.\n    \"\"\"\n    if not os.path.exists(filename):\n        raise IOError(f'file {filename} does not exist')\n\n    conn = None\n    table_names = []\n\n    try:\n        # Connect to the SQLite database\n        conn = sqlite3.connect(filename)\n        \n        # Create a cursor object using the cursor() method\n        cursor = conn.cursor()\n        \n        # Execute SQL query to get table names\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table';\")\n        \n        # Fetch all table names\n        table_names = [table[0] for table in cursor.fetchall()]\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n    finally:\n        # Close the connection\n        if conn:\n            conn.close()\n\n    return table_names\n\n# Example usage\nif __name__ == \"__main__\":\n    try:\n        print(get_tablenames('example.db'))  # Replace 'example.db' with your SQLite database file\n    except IOError as e:\n        print(e)\n", "Result": "Error"}
{"namespace": "psd_tools.utils.pack", "completion": "\nimport struct\n\ndef pack(fmt, *args):\n    \"\"\"\n    Packs the input arguments into a binary string according to the given format.\n    \n    :param fmt: String. The format string that specifies the format of the returned string.\n    :param args: Tuple. The input arguments to be packed.\n    :return: bytes. The packed binary string.\n    \"\"\"\n    return struct.pack(fmt, *args)\n\n# Example usage:\nfmt_string = \"hhl\"  # Format string: 2 short integers, followed by one long integer\ndata = (1, 2, 3)   # Input data\npacked_data = pack(fmt_string, *data)\nprint(packed_data)  # Output will depend on machine architecture (endianness)\n", "Result": "Error"}
{"namespace": "psd_tools.utils.unpack", "completion": "\nimport struct\n\ndef unpack(fmt, data):\n    \"\"\"\n    Unpacks the given data according to the specified format string.\n\n    :param fmt: str. The format string to be used for unpacking the data.\n    :param data: bytes. The data to be unpacked.\n    :return: tuple. A tuple containing the unpacked values.\n    \"\"\"\n    return struct.unpack(fmt, data)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Assuming we want to unpack 2 floats from a byte string\n    example_data = b'\\x00\\x00\\x80?\\x00\\x00\\x00@'  # Represents (1.0, 2.0)\n    unpacked_values = unpack(\"ff\", example_data)  # \"f\" is the format code for float\n    print(unpacked_values)  # Output should be (1.0, 2.0)\n", "Result": "Error"}
{"namespace": "exodus_bundler.bundling.bytes_to_int", "completion": "\ndef bytes_to_int(byte_string, byteorder='big'):\n    \"\"\"\n    Convert a byte string into an integer.\n\n    Args:\n        byte_string (bytes): The byte string to be converted into an integer.\n        byteorder (str, optional): The byte order to be used. Defaults to 'big'.\n\n    Returns:\n        int: The converted integer value.\n    \"\"\"\n    return int.from_bytes(byte_string, byteorder)\n\n# Example usage:\nbyte_data = b'\\x01\\x02'\nprint(bytes_to_int(byte_data))  # Output depends on the byteorder, for big-endian it would be 258\nprint(bytes_to_int(byte_data, byteorder='little'))  # For little-endian it would be 514\n", "Result": "Pass"}
{"namespace": "exodus_bundler.templating.render_template", "completion": "\ndef render_template(string, context):\n    \"\"\"\n    Replaces placeholders in the input string with corresponding values from the context dictionary.\n\n    :param string: str. The input string containing placeholders.\n    :param context: dict. The key-value pairs to replace the placeholders in the input string.\n    :return: str. The modified string after replacing the placeholders.\n    \"\"\"\n    for key, value in context.items():\n        placeholder = f\"{{{{{key}}}}}\"\n        string = string.replace(placeholder, str(value))\n    return string\n\n# Example usage:\ninput_string = \"Hello, my name is {{name}} and I am {{age}} years old.\"\ncontext = {\"name\": \"Alice\", \"age\": 30}\nresult = render_template(input_string, context)\nprint(result)  # Output: Hello, my name is Alice and I am 30 years old.\n", "Result": "Error"}
{"namespace": "trailscraper.iam.all_known_iam_permissions", "completion": "\nimport os\n\ndef all_known_iam_permissions():\n    \"\"\"\n    Returns a set of all known IAM actions read from 'known-iam-actions.txt'\n    located in the same directory as the script.\n    \n    :return: set. A set of lines from 'known-iam-actions.txt'.\n    \"\"\"\n    # Get the directory name of the current script\n    dir_name = os.path.dirname(os.path.abspath(__file__))\n    \n    # Define the filename\n    filename = os.path.join(dir_name, 'known-iam-actions.txt')\n    \n    # Read the file and convert lines into a set\n    try:\n        with open(filename, 'r') as file:\n            lines = file.readlines()\n        return set(line.strip() for line in lines)\n    except FileNotFoundError:\n        print(f\"Error: The file {filename} was not found.\")\n        return set()\n\n# Example usage (this would typically be outside of the function definition):\n# known_iam_actions = all_known_iam_permissions()\n# print(known_iam_actions)\n", "Result": "Pass"}
{"namespace": "trailscraper.cloudtrail.parse_records", "completion": "\nclass Record:\n    def __init__(self, data):\n        self.data = data\n\ndef _parse_record(json_record):\n    try:\n        return Record(json_record)\n    except ValueError:\n        return None\n\ndef parse_records(json_records):\n    \"\"\"\n    Parses a list of JSON records into Record objects, filtering out any None values.\n\n    :param json_records: List. A list of JSON records to be parsed.\n    :return: List. A list of Record objects parsed from the JSON records.\n    \"\"\"\n    parsed_records = [_parse_record(record) for record in json_records]\n    # Filter out any None values from the parsed records\n    filtered_records = [record for record in parsed_records if record is not None]\n    return filtered_records\n\n# Example usage:\njson_records = [\n    {\"id\": 1, \"name\": \"Alice\"},\n    {\"id\": 2, \"name\": \"Bob\", \"age\": 30},\n    {\"invalid_json\"}\n]\n\nfiltered_records = parse_records(json_records)\nfor record in filtered_records:\n    print(record.data)\n", "Result": "Error"}
{"namespace": "discord.utils.get_slots", "completion": "\ndef get_slots(cls):\n    # Start with the given class and continue to the base of its hierarchy\n    while cls is not None:\n        # Get the slots from the current class\n        slots = getattr(cls, '__slots__', ())\n        \n        # If slots is a string, convert it to a tuple containing only that string\n        if isinstance(slots, str):\n            slots = (slots,)\n        \n        # Yield each slot name\n        yield from slots\n        \n        # Move to the next class in the hierarchy\n        cls = getattr(cls, '__base__', None)\n\n# Example usage:\nclass BaseClass:\n    __slots__ = ('base_slot1', 'base_slot2')\n\nclass DerivedClass(BaseClass):\n    __slots__ = ('derived_slot1', 'derived_slot2')\n\nfor slot_name in get_slots(DerivedClass):\n    print(slot_name)\n", "Result": "Pass"}
{"namespace": "discord.utils.is_inside_class", "completion": "\ndef is_inside_class(func):\n    \"\"\"\n    Determines whether the given callable (function or method) is defined within a class.\n\n    :param func: Callable. The function to be checked.\n    :return: Bool. True if the function is defined inside a class, False otherwise.\n    \"\"\"\n    # Get the qualified name of the function\n    qual_name = func.__qualname__\n    \n    # Check if the qualified name indicates it's inside a class\n    # A class-defined function/method will have at least one dot before its name\n    return '.' in qual_name and not qual_name.startswith('<')\n\n# Example usage:\nclass TestClass:\n    def test_method(self):\n        pass\n\ndef standalone_function():\n    pass\n\nprint(is_inside_class(TestClass.test_method))  # Should print True\nprint(is_inside_class(standalone_function))   # Should print False\n", "Result": "Error"}
{"namespace": "wandb.util.to_forward_slash_path", "completion": "\nimport os\n\ndef to_forward_slash_path(path):\n    \"\"\"\n    Converts a backslash-separated file or directory path to a forward slash-separated one,\n    if the current platform is Windows.\n\n    :param path: String. The path to be converted.\n    :return: String. The converted path.\n    \"\"\"\n    # Check if the current platform is Windows\n    if os.name == 'nt':\n        # Replace backslashes with forward slashes\n        path = path.replace(\"\\\\\", \"/\")\n    return path\n\n# Example usage:\ntest_path = \"C:\\\\Users\\\\ExampleUser\\\\Documents\"\nprint(to_forward_slash_path(test_path))\n", "Result": "Pass"}
{"namespace": "wandb.util.make_artifact_name_safe", "completion": "\nimport re\n\ndef make_artifact_name_safe(name):\n    # Step 1: Sanitize the name by keeping only allowed characters or replace them with '_'\n    sanitized_name = re.sub(r\"[^a-zA-Z0-9\\-_.]\", \"_\", name)\n    \n    # Step 2: Truncate the name if it's longer than 128 characters\n    if len(sanitized_name) > 128:\n        # Split the string into three parts to keep the first 64 and last 64 characters\n        # with three dots in the middle.\n        prefix = sanitized_name[:64]\n        suffix = sanitized_name[-64:]\n        sanitized_name = f\"{prefix}...{suffix}\"\n    \n    return sanitized_name\n\n# Example usage:\nprint(make_artifact_name_safe(\"This is a very long artifact name with special characters!@#$%^&*()\"))\n", "Result": "Pass"}
{"namespace": "jwt.utils.force_bytes", "completion": "\ndef force_bytes(value):\n    \"\"\"\n    Convert the given value to bytes. If the value is a string, it encodes it to bytes using UTF-8.\n    If the value is already bytes, it is returned unchanged.\n    \n    :param value: Union[bytes, str] - The input value that needs to be converted to bytes.\n    :return: bytes - The input value converted to bytes.\n    :raises TypeError: If the input value is not a string or bytes.\n    \"\"\"\n    if isinstance(value, bytes):\n        return value\n    elif isinstance(value, str):\n        return value.encode('utf-8')\n    else:\n        raise TypeError(f\"Expected a string or bytes object, but received a {type(value)} instead.\")\n", "Result": "Pass"}
{"namespace": "pytube.cli.display_progress_bar", "completion": "\ndef display_progress_bar(bytes_received, filesize, ch=\"\u2588\", scale=0.55):\n    \"\"\"\n    Display a simple, pretty progress bar in the terminal.\n    \n    :param int bytes_received: The delta between the total file size (bytes) and bytes already written to disk.\n    :param int filesize: File size of the media stream in bytes.\n    :param str ch: Character to use for presenting progress segment. Defaults to \"\u2588\".\n    :param float scale: Scale multiplier to reduce progress bar size. Defaults to 0.55.\n    \"\"\"\n    # Calculate the current percentage of the file that has been received\n    percent = (float(bytes_received) / float(filesize)) * 100\n    \n    # Determine the number of characters in the progress bar\n    num_chars = int(percent * scale)\n    \n    # Create the progress bar string\n    bar = ch * num_chars + '-' * (int(scale * 80) - num_chars)  # Assuming width of 80 chars for simplicity\n    \n    # Print the progress bar with the percentage\n    print(f\"\\r[{bar}] {percent:.2f}%\", end=\"\")\n    \n    # If the file transfer is complete, print a newline\n    if bytes_received == filesize:\n        print()\n\n# Example usage:\n# Note: This is just an example and does not run as it depends on external variables being defined.\n# You might want to call this function within a loop that updates bytes_received.\n", "Result": "Error"}
{"namespace": "imapclient.imap_utf7.encode", "completion": "\ndef encode(s):\n    \"\"\"\n    Encodes a string using a simplified version of IMAP Modified UTF-7 encoding.\n\n    :param s: Union[str, bytes]. The input string to be encoded.\n    :return: bytes. The encoded bytes of the input string.\n    \"\"\"\n    if isinstance(s, str):\n        # Convert string to bytes\n        s = s.encode('utf-8')\n    \n    if isinstance(s, bytes):\n        # Encode each byte that is outside of the ASCII range (0x00-0x7F)\n        result = b\"\"\n        for byte in s:\n            if 0 <= byte <= 127:  # ASCII range\n                result += bytes([byte])\n            else:\n                # Escape non-ASCII characters\n                result += b\"/\" + hex(byte)[2:].encode('ascii') + b\"-\"\n        \n        return result.rstrip(b\"-\")  # Remove trailing '-' if any\n    else:\n        return s\n\n# Example usage\nencoded_string = encode(\"folder\u540d\")\nprint(encoded_string)  # Output should reflect the encoding of non-ASCII characters\n", "Result": "Error"}
{"namespace": "imapclient.version._imapclient_version_string", "completion": "\ndef _imapclient_version_string(vinfo):\n    \"\"\"\n    Creates a version string based on the given version information.\n    \n    Parameters:\n        vinfo (tuple): A tuple containing version information in the format (major, minor, micro, releaselevel).\n        \n    Returns:\n        str: The version string created based on the version information.\n    \"\"\"\n    # Unpack the version information tuple\n    major, minor, micro, releaselevel = vinfo\n    \n    # Create the version string\n    version_str = f\"{major}.{minor}.{micro} {releaselevel}\"\n    \n    return version_str\n\n# Example usage:\nversion_info = (3, 5, 0, 'final')\nprint(_imapclient_version_string(version_info))  # Output: 3.5.0 final\n", "Result": "Error"}
