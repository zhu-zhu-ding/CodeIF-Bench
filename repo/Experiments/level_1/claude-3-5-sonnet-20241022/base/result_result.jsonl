{"namespace": "benedict.utils.type_util.is_json_serializable", "completion": "\ndef is_json_serializable(val: Any) -> bool:\n    \"\"\"\n    Check if the input value is JSON serializable.\n    \n    :param val: Any. The input value to be checked for JSON serializability\n    :return: Bool. True if the input value is JSON serializable, False otherwise\n    \"\"\"\n    try:\n        json.dumps(val)\n        return True\n    except (TypeError, OverflowError):\n        return False\n", "Result": "Error"}
{"namespace": "feedparser.urls.convert_to_idn", "completion": "\ndef convert_to_idn(url: str) -> str:\n    \"\"\"\n    Convert a URL to IDN notation.\n    \n    :param url: String. The URL to be converted to IDN notation\n    :return: String. The URL in IDN notation\n    \"\"\"\n    from urllib.parse import urlparse, urlunparse\n    \n    # Parse the URL into components\n    parsed = urlparse(url)\n    \n    # Check if hostname exists and needs conversion\n    if parsed.hostname:\n        try:\n            # Try encoding hostname in ASCII\n            parsed.hostname.encode('ascii')\n        except UnicodeEncodeError:\n            # Convert to IDN if ASCII encoding fails\n            idn_hostname = parsed.hostname.encode('idna').decode('ascii')\n            # Create new components with converted hostname\n            components = list(parsed)\n            components[1] = idn_hostname\n            return urlunparse(components)\n    \n    # Return original URL if no conversion needed\n    return url\n", "Result": "Error"}
{"namespace": "googleapiclient._helpers.parse_unique_urlencoded", "completion": "\ndef parse_unique_urlencoded(content: str) -> dict:\n    \"\"\"\n    Parse unique key-value parameters from URL-encoded content.\n    \n    Args:\n        content: URL-encoded key-value pairs\n        \n    Returns:\n        Dictionary of parsed key-value pairs\n        \n    Raises:\n        ValueError: If a key is repeated in the content\n    \"\"\"\n    if not content:\n        return {}\n    \n    result = {}\n    pairs = content.split('&')\n    \n    for pair in pairs:\n        if not pair:\n            continue\n            \n        key, _, value = pair.partition('=')\n        key = key.strip()\n        \n        if key in result:\n            raise ValueError(f\"Duplicate key found: {key}\")\n            \n        result[key] = value\n        \n    return result\n", "Result": "Pass"}
{"namespace": "jinja2.async_utils.auto_aiter", "completion": "\nfrom typing import Union, AsyncIterable, Iterable, AsyncIterator\n\nasync def auto_aiter(iterable: Union[AsyncIterable, Iterable]) -> AsyncIterator:\n    if hasattr(iterable, '__aiter__'):\n        async for item in iterable:\n            yield item\n    else:\n        for item in iterable:\n            yield item\n", "Result": "Pass"}
{"namespace": "csvs_to_sqlite.utils.table_exists", "completion": "\ndef table_exists(conn, table):\n    \"\"\"\n    Check if the table exists in the database.\n    \n    Args:\n        conn: Connection. The connection to the database.\n        table: String. The name of the table to check.\n        \n    Returns:\n        Bool. True if the table exists, False otherwise.\n    \"\"\"\n    try:\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            SELECT name \n            FROM sqlite_master \n            WHERE type='table' AND name=?\n        \"\"\", (table,))\n        return cursor.fetchone() is not None\n    except Exception as e:\n        print(f\"Error checking table existence: {e}\")\n        return False\n    finally:\n        cursor.close()\n", "Result": "Pass"}
{"namespace": "sqlitedict.SqliteDict.get_tablenames", "completion": "\ndef get_tablenames(filename: str) -> list[str]:\n    import sqlite3\n    import os\n\n    if not os.path.exists(filename):\n        raise IOError(f\"file {filename} does not exist\")\n    \n    try:\n        conn = sqlite3.connect(filename)\n        cursor = conn.cursor()\n        \n        # Query to get all table names\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table';\")\n        tables = cursor.fetchall()\n        \n        # Convert list of tuples to list of strings\n        table_names = [table[0] for table in tables]\n        \n        return table_names\n    finally:\n        if 'conn' in locals():\n            conn.close()\n", "Result": "Pass"}
{"namespace": "psd_tools.utils.pack", "completion": "\ndef pack(fmt: str, *args) -> bytes:\n    \"\"\"\n    Pack arguments into a binary string according to the given format.\n    \n    :param fmt: String. Format string that specifies the format (e.g., '>I', '>f')\n    :param *args: Tuple. Input arguments to be packed\n    :return: Binary string containing the packed values\n    \"\"\"\n    import struct\n    return struct.pack(fmt, *args)\n", "Result": "Error"}
{"namespace": "psd_tools.utils.unpack", "completion": "\ndef unpack(fmt: str, data: bytes) -> tuple:\n    \"\"\"\n    Unpacks binary data according to the specified format.\n    \n    Args:\n        fmt (str): Format string for unpacking (e.g., '>hhl' for big-endian 2 shorts and 1 long)\n        data (bytes): Binary data to unpack\n        \n    Returns:\n        tuple: Tuple containing the unpacked values\n        \n    Example:\n        unpack('>hh', b'\\x00\\x01\\x00\\x02') -> (1, 2)\n    \"\"\"\n    import struct\n    return struct.unpack(fmt, data)\n", "Result": "Error"}
{"namespace": "exodus_bundler.bundling.bytes_to_int", "completion": "\ndef bytes_to_int(bytes_str: bytes, byteorder: str = \"big\") -> int:\n    \"\"\"\n    Convert a byte string into an integer.\n    \n    Args:\n        bytes_str: Byte string to be converted into an integer\n        byteorder: Byte order to be used (\"big\" or \"little\"), defaults to \"big\"\n    \n    Returns:\n        Integer converted from the byte string\n    \"\"\"\n    return int.from_bytes(bytes_str, byteorder=byteorder)\n", "Result": "Pass"}
{"namespace": "exodus_bundler.templating.render_template", "completion": "\ndef render_template(string: str, context: dict) -> str:\n    \"\"\"\n    Replace placeholders in a string with values from a context dictionary.\n    \n    Args:\n        string: Input string containing placeholders\n        context: Dictionary with key-value pairs for replacement\n        \n    Returns:\n        Modified string with placeholders replaced by values\n    \"\"\"\n    result = string\n    for key, value in context.items():\n        placeholder = \"{{\" + key + \"}}\"\n        result = result.replace(placeholder, str(value))\n    return result\n", "Result": "Error"}
{"namespace": "trailscraper.iam.all_known_iam_permissions", "completion": "\ndef all_known_iam_permissions():\n    \"\"\"\n    Returns a list of all known IAM actions by reading from 'known-iam-actions.txt'\n    \n    :return: set - A set of lines from the file\n    \"\"\"\n    import os\n    \n    current_dir = os.path.dirname(os.path.abspath(__file__))\n    file_path = os.path.join(current_dir, 'known-iam-actions.txt')\n    \n    with open(file_path, 'r') as f:\n        return set(line.strip() for line in f)\n", "Result": "Pass"}
{"namespace": "trailscraper.cloudtrail.parse_records", "completion": "\ndef parse_records(json_records):\n    \"\"\"\n    Parse a list of JSON records into Record objects.\n    \n    Args:\n        json_records (List): A list of JSON records to be parsed\n        \n    Returns:\n        List: A list of Record objects parsed from the JSON records\n    \"\"\"\n    # Map each JSON record through _parse_record and filter out None values\n    return [\n        record for record in map(_parse_record, json_records)\n        if record is not None\n    ]\n", "Result": "Pass"}
{"namespace": "discord.utils.get_slots", "completion": "\ndef get_slots(cls: type) -> Iterator[str]:\n    \"\"\"\n    Returns an iterator that yields the names of slots in a class and its base classes.\n    \n    Args:\n        cls: The class for which the slots are to be retrieved\n        \n    Returns:\n        An iterator yielding slot names as strings\n        \n    Example:\n        for slot in get_slots(MyClass):\n            print(slot)\n    \"\"\"\n    # Check each class in the method resolution order\n    for class_ in cls.__mro__:\n        # Get slots if they exist in the class\n        slots = getattr(class_, '__slots__', ())\n        if isinstance(slots, str):\n            yield slots\n        else:\n            for slot in slots:\n                yield slot\n", "Result": "Pass"}
{"namespace": "discord.utils.is_inside_class", "completion": "\ndef is_inside_class(func):\n    \"\"\"\n    Determine whether a given callable is defined within a class.\n    \n    Args:\n        func: Callable. The function to be checked.\n    Returns:\n        bool: True if the function is defined inside a class, False otherwise.\n    \"\"\"\n    if not callable(func):\n        raise TypeError(\"Input must be a callable (function or method)\")\n        \n    # Get the qualified name of the callable\n    qualname = getattr(func, '__qualname__', '')\n    \n    # Split the qualified name into parts\n    parts = qualname.split('.')\n    \n    # Check if there are at least 2 parts (class.method)\n    # and the first part is not '<locals>' (nested function)\n    return len(parts) >= 2 and '<locals>' not in parts[:-1]\n", "Result": "Pass"}
{"namespace": "wandb.util.to_forward_slash_path", "completion": "\ndef to_forward_slash_path(path: str) -> str:\n    \"\"\"\n    Convert backslash path to forward slash path if platform is Windows.\n    \n    :param path: String. The path to be converted.\n    :return: String. The converted path.\n    \"\"\"\n    import platform\n    \n    if platform.system() == 'Windows':\n        return path.replace('\\\\', '/')\n    return path\n", "Result": "Pass"}
{"namespace": "wandb.util.make_artifact_name_safe", "completion": "\nimport re\n\ndef make_artifact_name_safe(name: str) -> str:\n    # Replace invalid characters with underscore\n    safe_name = re.sub(r'[^a-zA-Z0-9\\-_.]', '_', name)\n    \n    # If name is longer than 128 characters, truncate with dots in middle\n    if len(safe_name) > 128:\n        half_length = (128 - 3) // 2\n        safe_name = f\"{safe_name[:half_length]}...{safe_name[-half_length:]}\"\n    \n    return safe_name\n", "Result": "Pass"}
{"namespace": "jwt.utils.force_bytes", "completion": "\ndef force_bytes(value: Union[bytes, str]) -> bytes:\n    \"\"\"\n    Convert the input value to bytes.\n    \n    Args:\n        value: Input value that needs to be converted to bytes.\n        \n    Returns:\n        The input value converted to bytes.\n        \n    Raises:\n        TypeError: If input is neither bytes nor str.\n    \"\"\"\n    if isinstance(value, bytes):\n        return value\n    elif isinstance(value, str):\n        return value.encode('utf-8')\n    else:\n        raise TypeError(f\"Expected bytes or str, got {type(value).__name__}\")\n", "Result": "Pass"}
{"namespace": "pytube.cli.display_progress_bar", "completion": "\ndef display_progress_bar(bytes_received: int, filesize: int, ch: str = \"\u2588\", scale: float = 0.55) -> None:\n    \"\"\"\n    Display a pretty progress bar in the terminal.\n    \n    Args:\n        bytes_received (int): The delta between total file size and bytes written\n        filesize (int): Total file size in bytes\n        ch (str): Character for progress segment (default: \"\u2588\")\n        scale (float): Scale multiplier for bar size (default: 0.55)\n    \"\"\"\n    columns = min(int(80 * scale), 80)  # Get terminal width, cap at 80\n    max_width = columns - 7  # Leave space for percentages\n\n    filled = int(round(max_width * bytes_received / float(filesize)))\n    remaining = max_width - filled\n    progress = round(100.0 * bytes_received / float(filesize), 1)\n    bar = ch * filled + '-' * remaining\n\n    print(f'\\r|{bar}| {progress}%', end='', flush=True)\n", "Result": "Pass"}
{"namespace": "imapclient.imap_utf7.encode", "completion": "\nfrom typing import Union\n\ndef encode(s: Union[str, bytes]) -> bytes:\n    if not isinstance(s, str):\n        return s\n    \n    result = []\n    is_utf7 = False\n    \n    for char in s:\n        # ASCII characters except &\n        if 0x20 <= ord(char) <= 0x7e and char != '&':\n            if is_utf7:\n                result.append('-')\n                is_utf7 = False\n            result.append(char)\n        else:\n            if not is_utf7:\n                result.append('&')\n                is_utf7 = True\n            # Convert to modified BASE64\n            if char == '&':\n                result.append('-')\n            else:\n                result.extend(char.encode('utf-16be').hex())\n    \n    if is_utf7:\n        result.append('-')\n    \n    return ''.join(result).encode('ascii')\n", "Result": "Error"}
{"namespace": "imapclient.version._imapclient_version_string", "completion": "\ndef _imapclient_version_string(vinfo):\n    major, minor, micro, releaselevel = vinfo\n    \n    version = f\"{major}.{minor}.{micro}\"\n    \n    if releaselevel != 'final':\n        version += f\"-{releaselevel}\"\n        \n    return version\n", "Result": "Pass"}
