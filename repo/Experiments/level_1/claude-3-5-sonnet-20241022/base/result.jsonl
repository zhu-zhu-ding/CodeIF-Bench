[
    {
        "namespace": "benedict.utils.type_util.is_json_serializable",
        "completion": "Here's a function to check JSON serializability:\n\n```python\ndef is_json_serializable(val: Any) -> bool:\n    \"\"\"\n    Check if the input value is JSON serializable.\n    \n    :param val: Any. The input value to be checked for JSON serializability\n    :return: Bool. True if the input value is JSON serializable, False otherwise\n    \"\"\"\n    try:\n        json.dumps(val)\n        return True\n    except (TypeError, OverflowError):\n        return False\n```\n\nThis function:\n1. Uses `json.dumps()` to attempt serialization\n2. Returns `True` if successful\n3. Returns `False` if it catches TypeError or OverflowError\n4. Requires `import json` at the top of the file"
    },
    {
        "namespace": "feedparser.urls.convert_to_idn",
        "completion": "Here's a Python function that converts URLs to IDN notation:\n\n```python\ndef convert_to_idn(url: str) -> str:\n    \"\"\"\n    Convert a URL to IDN notation.\n    \n    :param url: String. The URL to be converted to IDN notation\n    :return: String. The URL in IDN notation\n    \"\"\"\n    from urllib.parse import urlparse, urlunparse\n    \n    # Parse the URL into components\n    parsed = urlparse(url)\n    \n    # Check if hostname exists and needs conversion\n    if parsed.hostname:\n        try:\n            # Try encoding hostname in ASCII\n            parsed.hostname.encode('ascii')\n        except UnicodeEncodeError:\n            # Convert to IDN if ASCII encoding fails\n            idn_hostname = parsed.hostname.encode('idna').decode('ascii')\n            # Create new components with converted hostname\n            components = list(parsed)\n            components[1] = idn_hostname\n            return urlunparse(components)\n    \n    # Return original URL if no conversion needed\n    return url\n```\n\nThis function:\n1. Uses `urlparse` to break the URL into components\n2. Checks if hostname exists and needs IDN conversion\n3. Attempts ASCII encoding to detect non-ASCII hostnames\n4. Converts to IDN if needed using `idna` encoding\n5. Reconstructs the URL with the converted hostname\n\nExample usage:\n```python\n# Regular URL\nprint(convert_to_idn(\"https://example.com\"))  # No change needed\n# URL with Unicode\nprint(convert_to_idn(\"https://m\u00fcnchen.de\"))  # Converts to IDN form\n```"
    },
    {
        "namespace": "googleapiclient._helpers.parse_unique_urlencoded",
        "completion": "Here's a Python function that parses unique URL-encoded parameters:\n\n```python\ndef parse_unique_urlencoded(content: str) -> dict:\n    \"\"\"\n    Parse unique key-value parameters from URL-encoded content.\n    \n    Args:\n        content: URL-encoded key-value pairs\n        \n    Returns:\n        Dictionary of parsed key-value pairs\n        \n    Raises:\n        ValueError: If a key is repeated in the content\n    \"\"\"\n    if not content:\n        return {}\n    \n    result = {}\n    pairs = content.split('&')\n    \n    for pair in pairs:\n        if not pair:\n            continue\n            \n        key, _, value = pair.partition('=')\n        key = key.strip()\n        \n        if key in result:\n            raise ValueError(f\"Duplicate key found: {key}\")\n            \n        result[key] = value\n        \n    return result\n```\n\nThis function:\n1. Takes URL-encoded content as input\n2. Splits the content by '&' to separate key-value pairs\n3. Uses partition to split each pair into key and value\n4. Checks for duplicate keys and raises ValueError if found\n5. Returns a dictionary with unique key-value pairs"
    },
    {
        "namespace": "jinja2.async_utils.auto_aiter",
        "completion": "Here's an implementation of the `auto_aiter` function:\n\n```python\nfrom typing import Union, AsyncIterable, Iterable, AsyncIterator\n\nasync def auto_aiter(iterable: Union[AsyncIterable, Iterable]) -> AsyncIterator:\n    if hasattr(iterable, '__aiter__'):\n        async for item in iterable:\n            yield item\n    else:\n        for item in iterable:\n            yield item\n```\n\nThis function:\n1. Takes either an AsyncIterable or regular Iterable as input\n2. Checks if the iterable has `__aiter__` method (indicating it's async)\n3. Uses appropriate iteration method (async or sync) based on the check\n4. Yields items one at a time asynchronously\n\nYou can use it like:\n```python\n# Example usage:\nasync for item in auto_aiter(some_iterable):\n    # Process item\n    pass\n```"
    },
    {
        "namespace": "csvs_to_sqlite.utils.table_exists",
        "completion": "Here's a Python function to check if a table exists in a database:\n\n```python\ndef table_exists(conn, table):\n    \"\"\"\n    Check if the table exists in the database.\n    \n    Args:\n        conn: Connection. The connection to the database.\n        table: String. The name of the table to check.\n        \n    Returns:\n        Bool. True if the table exists, False otherwise.\n    \"\"\"\n    try:\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            SELECT name \n            FROM sqlite_master \n            WHERE type='table' AND name=?\n        \"\"\", (table,))\n        return cursor.fetchone() is not None\n    except Exception as e:\n        print(f\"Error checking table existence: {e}\")\n        return False\n    finally:\n        cursor.close()\n```\n\nThis function assumes you're using SQLite. If you're using a different database (MySQL, PostgreSQL, etc.), you'll need to modify the SQL query accordingly."
    },
    {
        "namespace": "sqlitedict.SqliteDict.get_tablenames",
        "completion": "Here's a Python function that retrieves table names from an SQLite database:\n\n```python\ndef get_tablenames(filename: str) -> list[str]:\n    import sqlite3\n    import os\n\n    if not os.path.exists(filename):\n        raise IOError(f\"file {filename} does not exist\")\n    \n    try:\n        conn = sqlite3.connect(filename)\n        cursor = conn.cursor()\n        \n        # Query to get all table names\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table';\")\n        tables = cursor.fetchall()\n        \n        # Convert list of tuples to list of strings\n        table_names = [table[0] for table in tables]\n        \n        return table_names\n    finally:\n        if 'conn' in locals():\n            conn.close()\n```\n\nThis function:\n1. Checks if file exists first\n2. Connects to the SQLite database\n3. Queries the sqlite_master table for all table names\n4. Returns the names as a list of strings\n5. Ensures proper connection cleanup using try/finally"
    },
    {
        "namespace": "psd_tools.utils.pack",
        "completion": "Here's a Python function that packs arguments into a binary string according to a given format:\n\n```python\ndef pack(fmt: str, *args) -> bytes:\n    \"\"\"\n    Pack arguments into a binary string according to the given format.\n    \n    :param fmt: String. Format string that specifies the format (e.g., '>I', '>f')\n    :param *args: Tuple. Input arguments to be packed\n    :return: Binary string containing the packed values\n    \"\"\"\n    import struct\n    return struct.pack(fmt, *args)\n```\n\nThis function:\n- Uses Python's built-in `struct` module\n- Takes a format string and variable arguments\n- Returns packed binary data according to the format\n- Format string examples: '>I' (big-endian unsigned int), '>f' (big-endian float)\n\nExample usage:\n```python\npacked = pack('>I', 42)  # Packs integer 42 as big-endian\npacked = pack('>If', 1, 3.14)  # Packs an integer and float\n```"
    },
    {
        "namespace": "psd_tools.utils.unpack",
        "completion": "Here's a Python function that unpacks data according to a specified format:\n\n```python\ndef unpack(fmt: str, data: bytes) -> tuple:\n    \"\"\"\n    Unpacks binary data according to the specified format.\n    \n    Args:\n        fmt (str): Format string for unpacking (e.g., '>hhl' for big-endian 2 shorts and 1 long)\n        data (bytes): Binary data to unpack\n        \n    Returns:\n        tuple: Tuple containing the unpacked values\n        \n    Example:\n        unpack('>hh', b'\\x00\\x01\\x00\\x02') -> (1, 2)\n    \"\"\"\n    import struct\n    return struct.unpack(fmt, data)\n```\n\nThis function:\n- Uses Python's `struct` module for binary data unpacking\n- Accepts a format string (e.g., '>hh' for big-endian, two short integers)\n- Accepts bytes data to unpack\n- Returns a tuple with the unpacked values\n\nExample usage:\n```python\n# Example: unpack two big-endian short integers\ndata = b'\\x00\\x01\\x00\\x02'\nresult = unpack('>hh', data)  # Returns (1, 2)\n```"
    },
    {
        "namespace": "exodus_bundler.bundling.bytes_to_int",
        "completion": "Here's a Python function that converts a byte string to an integer:\n\n```python\ndef bytes_to_int(bytes_str: bytes, byteorder: str = \"big\") -> int:\n    \"\"\"\n    Convert a byte string into an integer.\n    \n    Args:\n        bytes_str: Byte string to be converted into an integer\n        byteorder: Byte order to be used (\"big\" or \"little\"), defaults to \"big\"\n    \n    Returns:\n        Integer converted from the byte string\n    \"\"\"\n    return int.from_bytes(bytes_str, byteorder=byteorder)\n```\n\nThis function:\n- Uses Python's built-in `int.from_bytes()` method\n- Supports both big-endian (\"big\") and little-endian (\"little\") byte orders\n- Takes bytes as input and returns an integer\n- Includes type hints for clarity\n\nExample usage:\n```python\n# Example: convert b'\\x00\\x0f' to integer\nresult = bytes_to_int(b'\\x00\\x0f')  # Returns 15\n```"
    },
    {
        "namespace": "exodus_bundler.templating.render_template",
        "completion": "Here's a simple template rendering function in Python:\n\n```python\ndef render_template(string: str, context: dict) -> str:\n    \"\"\"\n    Replace placeholders in a string with values from a context dictionary.\n    \n    Args:\n        string: Input string containing placeholders\n        context: Dictionary with key-value pairs for replacement\n        \n    Returns:\n        Modified string with placeholders replaced by values\n    \"\"\"\n    result = string\n    for key, value in context.items():\n        placeholder = \"{{\" + key + \"}}\"\n        result = result.replace(placeholder, str(value))\n    return result\n```\n\nUsage example:\n```python\ntemplate = \"Hello {{name}}, you are {{age}} years old!\"\ncontext = {\"name\": \"John\", \"age\": 30}\nresult = render_template(template, context)\n# Result: \"Hello John, you are 30 years old!\"\n```\n\nThis implementation:\n1. Takes a string with placeholders in `{{key}}` format\n2. Replaces each placeholder with corresponding value from context\n3. Converts values to strings for replacement\n4. Returns the modified string"
    },
    {
        "namespace": "trailscraper.iam.all_known_iam_permissions",
        "completion": "Here's a Python function that meets your requirements:\n\n```python\ndef all_known_iam_permissions():\n    \"\"\"\n    Returns a list of all known IAM actions by reading from 'known-iam-actions.txt'\n    \n    :return: set - A set of lines from the file\n    \"\"\"\n    import os\n    \n    current_dir = os.path.dirname(os.path.abspath(__file__))\n    file_path = os.path.join(current_dir, 'known-iam-actions.txt')\n    \n    with open(file_path, 'r') as f:\n        return set(line.strip() for line in f)\n```\n\nThis function:\n1. Uses `os.path.dirname()` and `__file__` to get the directory of the current script\n2. Joins it with 'known-iam-actions.txt' to create the full file path\n3. Reads the file and returns a set of stripped lines\n4. Handles file operations using a context manager (`with` statement)\n\nMake sure 'known-iam-actions.txt' exists in the same directory as the script using this function."
    },
    {
        "namespace": "trailscraper.cloudtrail.parse_records",
        "completion": "Here's a Python function that matches your requirements:\n\n```python\ndef parse_records(json_records):\n    \"\"\"\n    Parse a list of JSON records into Record objects.\n    \n    Args:\n        json_records (List): A list of JSON records to be parsed\n        \n    Returns:\n        List: A list of Record objects parsed from the JSON records\n    \"\"\"\n    # Map each JSON record through _parse_record and filter out None values\n    return [\n        record for record in map(_parse_record, json_records)\n        if record is not None\n    ]\n```\n\nNote: This assumes that:\n1. `_parse_record` function is already defined elsewhere\n2. `Record` class exists in your codebase\n3. `_parse_record` returns either a `Record` object or `None`\n\nLet me know if you need the implementation of `_parse_record` or `Record` class as well."
    },
    {
        "namespace": "discord.utils.get_slots",
        "completion": "Here's a Python function to get slot names from a class and its base classes:\n\n```python\ndef get_slots(cls: type) -> Iterator[str]:\n    \"\"\"\n    Returns an iterator that yields the names of slots in a class and its base classes.\n    \n    Args:\n        cls: The class for which the slots are to be retrieved\n        \n    Returns:\n        An iterator yielding slot names as strings\n        \n    Example:\n        for slot in get_slots(MyClass):\n            print(slot)\n    \"\"\"\n    # Check each class in the method resolution order\n    for class_ in cls.__mro__:\n        # Get slots if they exist in the class\n        slots = getattr(class_, '__slots__', ())\n        if isinstance(slots, str):\n            yield slots\n        else:\n            for slot in slots:\n                yield slot\n```\n\nThis function:\n- Uses `__mro__` (Method Resolution Order) to iterate through the class and its base classes\n- Handles both string and iterable slot definitions\n- Yields slot names one at a time\n- Returns an iterator for memory efficiency\n- Includes type hints and documentation"
    },
    {
        "namespace": "discord.utils.is_inside_class",
        "completion": "Here's a Python function that checks if a callable is defined inside a class:\n\n```python\ndef is_inside_class(func):\n    \"\"\"\n    Determine whether a given callable is defined within a class.\n    \n    Args:\n        func: Callable. The function to be checked.\n    Returns:\n        bool: True if the function is defined inside a class, False otherwise.\n    \"\"\"\n    if not callable(func):\n        raise TypeError(\"Input must be a callable (function or method)\")\n        \n    # Get the qualified name of the callable\n    qualname = getattr(func, '__qualname__', '')\n    \n    # Split the qualified name into parts\n    parts = qualname.split('.')\n    \n    # Check if there are at least 2 parts (class.method)\n    # and the first part is not '<locals>' (nested function)\n    return len(parts) >= 2 and '<locals>' not in parts[:-1]\n```\n\nThis function:\n1. Checks if input is callable\n2. Gets the `__qualname__` attribute which contains the dotted path\n3. Splits the path and checks if:\n   - It has at least 2 parts (class.method)\n   - Doesn't contain '<locals>' in path except last part\n4. Returns True if conditions are met, False otherwise"
    },
    {
        "namespace": "wandb.util.to_forward_slash_path",
        "completion": "Here's a Python function that converts backslash paths to forward slash paths on Windows:\n\n```python\ndef to_forward_slash_path(path: str) -> str:\n    \"\"\"\n    Convert backslash path to forward slash path if platform is Windows.\n    \n    :param path: String. The path to be converted.\n    :return: String. The converted path.\n    \"\"\"\n    import platform\n    \n    if platform.system() == 'Windows':\n        return path.replace('\\\\', '/')\n    return path\n```\n\nThis function:\n1. Takes a string path as input\n2. Checks if the current platform is Windows\n3. If on Windows, replaces all backslashes with forward slashes\n4. Returns the original path unchanged if not on Windows"
    },
    {
        "namespace": "wandb.util.make_artifact_name_safe",
        "completion": "Here's a Python function that implements the requested functionality:\n\n```python\nimport re\n\ndef make_artifact_name_safe(name: str) -> str:\n    # Replace invalid characters with underscore\n    safe_name = re.sub(r'[^a-zA-Z0-9\\-_.]', '_', name)\n    \n    # If name is longer than 128 characters, truncate with dots in middle\n    if len(safe_name) > 128:\n        half_length = (128 - 3) // 2\n        safe_name = f\"{safe_name[:half_length]}...{safe_name[-half_length:]}\"\n    \n    return safe_name\n```\n\nThis function:\n1. Uses regex to replace any non-alphanumeric/dash/underscore/dot characters with underscores\n2. If the resulting string is >128 chars, truncates it by:\n   - Keeping first and last portions\n   - Adding \"...\" in the middle\n   - Ensuring total length is 128 chars\n\nYou can use it like:\n```python\nprint(make_artifact_name_safe(\"my@artifact.name\"))  # \"my_artifact.name\"\nprint(make_artifact_name_safe(\"a\" * 200))  # truncated version with ... in middle\n```"
    },
    {
        "namespace": "jwt.utils.force_bytes",
        "completion": "Here's a Python function that converts input to bytes according to your specifications:\n\n```python\ndef force_bytes(value: Union[bytes, str]) -> bytes:\n    \"\"\"\n    Convert the input value to bytes.\n    \n    Args:\n        value: Input value that needs to be converted to bytes.\n        \n    Returns:\n        The input value converted to bytes.\n        \n    Raises:\n        TypeError: If input is neither bytes nor str.\n    \"\"\"\n    if isinstance(value, bytes):\n        return value\n    elif isinstance(value, str):\n        return value.encode('utf-8')\n    else:\n        raise TypeError(f\"Expected bytes or str, got {type(value).__name__}\")\n```\n\nNote: You'll need to import `Union` from `typing` at the top of your file:\n```python\nfrom typing import Union\n```"
    },
    {
        "namespace": "pytube.cli.display_progress_bar",
        "completion": "Here's a Python function that creates a pretty progress bar in the terminal:\n\n```python\ndef display_progress_bar(bytes_received: int, filesize: int, ch: str = \"\u2588\", scale: float = 0.55) -> None:\n    \"\"\"\n    Display a pretty progress bar in the terminal.\n    \n    Args:\n        bytes_received (int): The delta between total file size and bytes written\n        filesize (int): Total file size in bytes\n        ch (str): Character for progress segment (default: \"\u2588\")\n        scale (float): Scale multiplier for bar size (default: 0.55)\n    \"\"\"\n    columns = min(int(80 * scale), 80)  # Get terminal width, cap at 80\n    max_width = columns - 7  # Leave space for percentages\n\n    filled = int(round(max_width * bytes_received / float(filesize)))\n    remaining = max_width - filled\n    progress = round(100.0 * bytes_received / float(filesize), 1)\n    bar = ch * filled + '-' * remaining\n\n    print(f'\\r|{bar}| {progress}%', end='', flush=True)\n```\n\nThis function:\n- Creates a scaled progress bar that fits in the terminal\n- Shows progress using the specified character (default: \u2588)\n- Displays percentage completion\n- Updates in-place using carriage return (\\r)\n- Handles different file sizes appropriately\n\nYou can call it like this:\n```python\ndisplay_progress_bar(50000, 100000)  # Shows 50% progress\n```"
    },
    {
        "namespace": "imapclient.imap_utf7.encode",
        "completion": "Here's a Python function that encodes folder names using IMAP modified UTF-7 encoding:\n\n```python\nfrom typing import Union\n\ndef encode(s: Union[str, bytes]) -> bytes:\n    if not isinstance(s, str):\n        return s\n    \n    result = []\n    is_utf7 = False\n    \n    for char in s:\n        # ASCII characters except &\n        if 0x20 <= ord(char) <= 0x7e and char != '&':\n            if is_utf7:\n                result.append('-')\n                is_utf7 = False\n            result.append(char)\n        else:\n            if not is_utf7:\n                result.append('&')\n                is_utf7 = True\n            # Convert to modified BASE64\n            if char == '&':\n                result.append('-')\n            else:\n                result.extend(char.encode('utf-16be').hex())\n    \n    if is_utf7:\n        result.append('-')\n    \n    return ''.join(result).encode('ascii')\n```\n\nThis function:\n1. Checks if input is string, if not returns unchanged\n2. Processes each character:\n   - ASCII chars (except &) are kept as-is\n   - Non-ASCII chars are converted to modified UTF-7\n   - & is specially handled\n3. Returns the encoded result as bytes"
    },
    {
        "namespace": "imapclient.version._imapclient_version_string",
        "completion": "Here's a Python function that creates a version string based on version information:\n\n```python\ndef _imapclient_version_string(vinfo):\n    major, minor, micro, releaselevel = vinfo\n    \n    version = f\"{major}.{minor}.{micro}\"\n    \n    if releaselevel != 'final':\n        version += f\"-{releaselevel}\"\n        \n    return version\n```\n\nThis function:\n1. Takes a tuple `vinfo` containing version components\n2. Unpacks the tuple into major, minor, micro, and releaselevel\n3. Creates base version string using major.minor.micro format\n4. Adds releaselevel suffix if it's not 'final'\n5. Returns the complete version string\n\nExample usage:\n```python\nversion = _imapclient_version_string((2, 1, 0, 'beta'))  # Returns \"2.1.0-beta\"\nversion = _imapclient_version_string((2, 1, 0, 'final')) # Returns \"2.1.0\"\n```"
    }
]