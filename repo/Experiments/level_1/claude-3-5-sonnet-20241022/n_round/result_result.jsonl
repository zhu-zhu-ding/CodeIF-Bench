{"namespace": "benedict.utils.type_util.is_json_serializable", "type": "Input-Output Conditions", "test": "tests/utils/test_type_util.py::type_util_test_case::test_input_output_conditions", "completion": "\ndef is_json_serializable(val: Any) -> bool:\n    \"\"\"\n    Check if the input value is JSON serializable.\n    \n    :param val: Any. The input value to be checked for JSON serializability\n    :return: Bool. True if the input value is JSON serializable, False otherwise\n    \n    Examples:\n        >>> is_json_serializable(42)  # int\n        True\n        >>> is_json_serializable(\"hello\")  # str\n        True\n        >>> is_json_serializable({1, 2, 3})  # set\n        False\n        >>> is_json_serializable(complex(1, 2))  # complex\n        False\n    \"\"\"\n    # Handle None case\n    if val is None:\n        return True\n    \n    # Check basic types\n    if isinstance(val, (bool, int, float, str)):\n        return True\n    \n    # Handle lists and tuples\n    if isinstance(val, (list, tuple)):\n        return all(is_json_serializable(item) for item in val)\n    \n    # Handle dictionaries\n    if isinstance(val, dict):\n        return (all(isinstance(k, str) for k in val.keys()) and  # JSON only allows string keys\n                all(is_json_serializable(v) for v in val.values()))\n    \n    # All other types are not JSON serializable\n    return False\n", "Result": "Error"}
{"namespace": "benedict.utils.type_util.is_json_serializable", "type": "Exception Handling", "test": "tests/utils/test_type_util.py::type_util_test_case::test_exception_handling", "completion": "\ndef is_json_serializable(val: Any) -> bool:\n    \"\"\"\n    Check if the input value is JSON serializable.\n    \n    :param val: Any. The input value to be checked for JSON serializability\n    :return: Bool. True if the input value is JSON serializable, False otherwise\n    \n    Examples:\n        >>> is_json_serializable(42)\n        True\n        >>> is_json_serializable(\"hello\")\n        True\n        >>> is_json_serializable({1, 2, 3})  # Sets are not JSON serializable\n        False\n        >>> is_json_serializable(complex(1, 2))  # Complex numbers are not JSON serializable\n        False\n    \"\"\"\n    try:\n        json.dumps(val)\n        return True\n    except (TypeError, OverflowError, ValueError, Exception):\n        # Catch all possible exceptions to ensure function never raises\n        return False\n", "Result": "Error"}
{"namespace": "benedict.utils.type_util.is_json_serializable", "type": "Edge Case Handling", "test": "tests/utils/test_type_util.py::type_util_test_case::test_edge_case_handling", "completion": "\ndef is_json_serializable(val: Any) -> bool:\n    \"\"\"\n    Check if the input value is JSON serializable.\n    \n    :param val: Any. The input value to be checked for JSON serializability\n    :return: Bool. True if the input value is JSON serializable, False otherwise\n    \n    Examples:\n        >>> is_json_serializable(\"\")  # Empty string\n        True\n        >>> is_json_serializable([])  # Empty list\n        True\n        >>> is_json_serializable(())  # Empty tuple\n        True\n        >>> is_json_serializable({})  # Empty dict\n        True\n    \"\"\"\n    # Handle empty collections explicitly\n    if val in [\"\", [], (), {}]:\n        return True\n        \n    try:\n        json.dumps(val)\n        return True\n    except (TypeError, OverflowError):\n        return False\n", "Result": "Error"}
{"namespace": "benedict.utils.type_util.is_json_serializable", "type": "Annotation Coverage", "test": "tests/utils/test_type_util.py::type_util_test_case::test_annotation_coverage", "completion": "\nfrom typing import Any\nimport json\n\ndef is_json_serializable(val: Any) -> bool:\n    \"\"\"\n    Check if the input value is JSON serializable.\n    \n    :param val: Any. The input value to be checked for JSON serializability\n    :return: bool. True if the input value is JSON serializable, False otherwise\n    \"\"\"\n    try:\n        json.dumps(val)\n        return True\n    except (TypeError, OverflowError):\n        return False\n", "Result": "Pass"}
{"namespace": "benedict.utils.type_util.is_json_serializable", "type": "Code Complexity", "test": "tests/utils/test_type_util.py::type_util_test_case::test_code_complexity", "completion": "\nfrom typing import Any\nimport json\n\ndef is_json_serializable(val: Any) -> bool:\n    \"\"\"\n    Check if the input value is JSON serializable.\n    \n    :param val: Any. The input value to be checked for JSON serializability\n    :return: Bool. True if the input value is JSON serializable, False otherwise\n    \n    Examples:\n        >>> is_json_serializable(42)\n        True\n        >>> is_json_serializable(\"hello\")\n        True\n        >>> is_json_serializable({1, 2, 3})  # Sets are not JSON serializable\n        False\n    \"\"\"\n    try:\n        json.dumps(val)\n        return True\n    except:  # Using a broad except to catch all serialization errors\n        return False\n", "Result": "Error"}
{"namespace": "benedict.utils.type_util.is_json_serializable", "type": "Code Standard", "test": "tests/utils/test_type_util.py::type_util_test_case::test_check_code_style", "completion": ":your_file.py\nfrom typing import Any\nimport json\n\n\ndef is_json_serializable(val: Any) -> bool:\n    \"\"\"\n    Check if the input value is JSON serializable.\n\n    Args:\n        val: The input value to be checked for JSON serializability.\n\n    Returns:\n        bool: True if the input value is JSON serializable, False otherwise.\n\n    Examples:\n        >>> is_json_serializable(42)\n        True\n        >>> is_json_serializable({1, 2, 3})  # Sets are not JSON serializable\n        False\n    \"\"\"\n    try:\n        json.dumps(val)\n        return True\n    except (TypeError, OverflowError):\n        return False\n", "Result": "Error"}
{"namespace": "feedparser.urls.convert_to_idn", "type": "Exception Handling", "test": "tests/runtests.py::TestConvertToIdn::test_exception_handling_invalid_url", "completion": "\ndef convert_to_idn(url: str) -> str:\n    \"\"\"\n    Convert a URL to IDN notation.\n    \n    :param url: String. The URL to be converted to IDN notation\n    :return: String. The URL in IDN notation\n    :raises ValueError: If the input is not a valid URL string\n    :raises UnicodeError: If the conversion to IDN fails\n    \"\"\"\n    from urllib.parse import urlparse, urlunparse\n    import re\n\n    # Basic URL validation using regex\n    url_pattern = re.compile(\n        r'^(?:http|ftp)s?://'  # http:// or https:// or ftp:// or ftps://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # domain\n        r'localhost|'  # localhost\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ip address\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n\n    if not url_pattern.match(url):\n        raise ValueError(\"Invalid URL format\")\n\n    # Parse the URL into components\n    try:\n        parsed = urlparse(url)\n    except Exception as e:\n        raise ValueError(f\"Failed to parse URL: {str(e)}\")\n\n    # Check if hostname exists and needs conversion\n    if parsed.hostname:\n        try:\n            # Try encoding hostname in ASCII\n            parsed.hostname.encode('ascii')\n        except UnicodeEncodeError:\n            try:\n                # Convert to IDN if ASCII encoding fails\n                idn_hostname = parsed.hostname.encode('idna').decode('ascii')\n                # Create new components with converted hostname\n                components = list(parsed)\n                components[1] = idn_hostname\n                return urlunparse(components)\n            except Exception as e:\n                raise UnicodeError(f\"Failed to convert hostname to IDN: {str(e)}\")\n    \n    # Return original URL if no conversion needed\n    return url\n", "Result": "Error"}
{"namespace": "feedparser.urls.convert_to_idn", "type": "Annotation Coverage", "test": "tests/runtests.py::TestConvertToIdn::test_annotation_coverage", "completion": "\nfrom typing import Union\nfrom urllib.parse import urlparse, urlunparse\n\ndef convert_to_idn(url: str) -> str:\n    \"\"\"\n    Convert a URL to IDN notation.\n    \n    Args:\n        url (str): The URL to be converted to IDN notation\n    \n    Returns:\n        str: The URL in IDN notation\n    \n    Raises:\n        ValueError: If the input is not a valid URL string\n        UnicodeError: If conversion to IDN fails\n    \"\"\"\n    if not isinstance(url, str):\n        raise ValueError(\"URL must be a string\")\n        \n    try:\n        # Parse the URL into components\n        parsed = urlparse(url)\n        \n        # Verify we have a valid URL by checking scheme and netloc\n        if not parsed.scheme or not parsed.netloc:\n            raise ValueError(\"Invalid URL format\")\n            \n        # Check if hostname exists and needs conversion\n        if parsed.hostname:\n            try:\n                # Try encoding hostname in ASCII\n                parsed.hostname.encode('ascii')\n            except UnicodeEncodeError:\n                # Convert to IDN if ASCII encoding fails\n                try:\n                    idn_hostname = parsed.hostname.encode('idna').decode('ascii')\n                except UnicodeError as e:\n                    raise UnicodeError(f\"Failed to convert hostname to IDN: {str(e)}\")\n                    \n                # Create new components with converted hostname\n                components = list(parsed)\n                components[1] = idn_hostname\n                return urlunparse(components)\n        \n        # Return original URL if no conversion needed\n        return url\n        \n    except Exception as e:\n        if isinstance(e, (ValueError, UnicodeError)):\n            raise\n        raise ValueError(f\"Invalid URL: {str(e)}\")\n", "Result": "Error"}
{"namespace": "feedparser.urls.convert_to_idn", "type": "Code Complexity", "test": "tests/runtests.py::TestConvertToIdn::test_code_complexity", "completion": "\ndef _is_ascii_encodable(hostname: str) -> bool:\n    \"\"\"\n    Check if hostname can be encoded in ASCII.\n    \n    :param hostname: String. The hostname to check\n    :return: Boolean. True if hostname can be encoded in ASCII\n    \"\"\"\n    try:\n        hostname.encode('ascii')\n        return True\n    except UnicodeEncodeError:\n        return False\n\ndef _convert_hostname_to_idn(hostname: str) -> str:\n    \"\"\"\n    Convert hostname to IDN notation.\n    \n    :param hostname: String. The hostname to convert\n    :return: String. The hostname in IDN notation\n    :raises UnicodeError: If conversion to IDN fails\n    \"\"\"\n    return hostname.encode('idna').decode('ascii')\n\ndef convert_to_idn(url: str) -> str:\n    \"\"\"\n    Convert a URL to IDN notation.\n    \n    :param url: String. The URL to be converted to IDN notation\n    :return: String. The URL in IDN notation\n    :raises ValueError: If the input is not a valid URL string\n    :raises UnicodeError: If conversion to IDN fails\n    \"\"\"\n    from urllib.parse import urlparse, urlunparse\n    \n    parsed = urlparse(url)\n    if not parsed.hostname:\n        return url\n        \n    if not _is_ascii_encodable(parsed.hostname):\n        components = list(parsed)\n        components[1] = _convert_hostname_to_idn(parsed.hostname)\n        return urlunparse(components)\n        \n    return url\n", "Result": "Error"}
{"namespace": "feedparser.urls.convert_to_idn", "type": "Code Standard", "test": "tests/runtests.py::TestConvertToIdn::test_check_code_style", "completion": ":url_converter.py\nfrom urllib.parse import urlparse, urlunparse\nfrom typing import NoReturn\n\n\ndef convert_to_idn(url: str) -> str:\n    \"\"\"Convert a URL to IDN notation.\n\n    This function checks if the host can be encoded in ASCII. If not, it converts\n    the host to IDN form.\n\n    Args:\n        url: The URL to be converted to IDN notation.\n\n    Returns:\n        The URL in IDN notation.\n\n    Raises:\n        ValueError: If the input is not a valid URL string.\n        UnicodeError: If the conversion to IDN fails.\n    \"\"\"\n    if not isinstance(url, str):\n        raise ValueError(\"URL must be a string\")\n\n    if not url:\n        raise ValueError(\"URL cannot be empty\")\n\n    try:\n        parsed = urlparse(url)\n    except Exception as e:\n        raise ValueError(f\"Invalid URL format: {str(e)}\")\n\n    if not parsed.hostname:\n        raise ValueError(\"URL must contain a hostname\")\n\n    try:\n        # Try encoding hostname in ASCII\n        parsed.hostname.encode('ascii')\n        return url\n    except UnicodeEncodeError:\n        try:\n            # Convert to IDN if ASCII encoding fails\n            idn_hostname = parsed.hostname.encode('idna').decode('ascii')\n            components = list(parsed)\n            components[1] = idn_hostname\n            return urlunparse(components)\n        except UnicodeError as e:\n            raise UnicodeError(f\"IDN conversion failed: {str(e)}\")\n", "Result": "Error"}
{"namespace": "googleapiclient._helpers.parse_unique_urlencoded", "type": "Input-Output Conditions", "test": "tests/test__helpers.py::Test_parse_unique_urlencoded::test_special_characters", "completion": "\nfrom urllib.parse import unquote_plus\n\ndef parse_unique_urlencoded(content: str) -> dict:\n    \"\"\"\n    Parse unique key-value parameters from URL-encoded content.\n    \n    Args:\n        content: URL-encoded key-value pairs\n        \n    Returns:\n        Dictionary of parsed key-value pairs with decoded special characters\n        \n    Raises:\n        ValueError: If a key is repeated in the content\n    \"\"\"\n    if not content:\n        return {}\n    \n    result = {}\n    pairs = content.split('&')\n    \n    for pair in pairs:\n        if not pair:\n            continue\n            \n        key, _, value = pair.partition('=')\n        # Decode URL-encoded characters\n        decoded_key = unquote_plus(key.strip())\n        decoded_value = unquote_plus(value.strip())\n        \n        if decoded_key in result:\n            raise ValueError(f\"Duplicate key found: {decoded_key}\")\n            \n        result[decoded_key] = decoded_value\n        \n    return result\n", "Result": "Pass"}
{"namespace": "googleapiclient._helpers.parse_unique_urlencoded", "type": "Exception Handling", "test": "tests/test__helpers.py::Test_parse_unique_urlencoded::test_repeated_key_error_message", "completion": "\ndef parse_unique_urlencoded(content: str) -> dict:\n    \"\"\"\n    Parse unique key-value parameters from URL-encoded content.\n    \n    Args:\n        content: URL-encoded key-value pairs\n        \n    Returns:\n        Dictionary of parsed key-value pairs\n        \n    Raises:\n        ValueError: If a key is repeated in the content, with a message indicating\n                   both the duplicate key and its previous value\n    \"\"\"\n    if not content:\n        return {}\n    \n    result = {}\n    pairs = content.split('&')\n    \n    for pair in pairs:\n        if not pair:\n            continue\n            \n        key, _, value = pair.partition('=')\n        key = key.strip()\n        \n        if key in result:\n            raise ValueError(\n                f\"Duplicate key '{key}' found. Previous value: '{result[key]}', \"\n                f\"attempted to add value: '{value}'\"\n            )\n            \n        result[key] = value\n        \n    return result\n", "Result": "Error"}
{"namespace": "googleapiclient._helpers.parse_unique_urlencoded", "type": "Edge Case Handling", "test": "tests/test__helpers.py::Test_parse_unique_urlencoded::test_empty_content", "completion": "\ndef parse_unique_urlencoded(content: str) -> dict:\n    \"\"\"\n    Parse unique key-value parameters from URL-encoded content.\n    \n    Args:\n        content: URL-encoded key-value pairs\n        \n    Returns:\n        Dictionary of parsed key-value pairs\n        \n    Raises:\n        ValueError: If a key is repeated in the content\n    \"\"\"\n    # Handle empty or None input\n    if not content or content.isspace():\n        return {}\n    \n    result = {}\n    pairs = content.split('&')\n    \n    for pair in pairs:\n        if not pair:\n            continue\n            \n        key, _, value = pair.partition('=')\n        key = key.strip()\n        \n        if key in result:\n            raise ValueError(f\"Duplicate key found: {key}\")\n            \n        result[key] = value\n        \n    return result\n", "Result": "Error"}
{"namespace": "googleapiclient._helpers.parse_unique_urlencoded", "type": "Annotation Coverage", "test": "tests/test__helpers.py::Test_parse_unique_urlencoded::test_function_annotations", "completion": "\nfrom typing import Dict\n\ndef parse_unique_urlencoded(content: str) -> Dict[str, str]:\n    \"\"\"\n    Parse unique key-value parameters from URL-encoded content.\n    \n    Args:\n        content: URL-encoded key-value pairs\n        \n    Returns:\n        Dictionary of parsed key-value pairs\n        \n    Raises:\n        ValueError: If a key is repeated in the content\n    \"\"\"\n    if not content:\n        return {}\n    \n    result: Dict[str, str] = {}\n    pairs = content.split('&')\n    \n    for pair in pairs:\n        if not pair:\n            continue\n            \n        key, _, value = pair.partition('=')\n        key = key.strip()\n        \n        if key in result:\n            raise ValueError(f\"Duplicate key found: {key}\")\n            \n        result[key] = value\n        \n    return result\n", "Result": "Error"}
{"namespace": "googleapiclient._helpers.parse_unique_urlencoded", "type": "Code Complexity", "test": "tests/test__helpers.py::Test_parse_unique_urlencoded::test_code_complexity", "completion": "\nfrom typing import Dict, List, Tuple\n\ndef split_into_pairs(content: str) -> List[str]:\n    \"\"\"Split URL-encoded content into key-value pair strings.\"\"\"\n    return [pair for pair in content.split('&') if pair]\n\ndef parse_pair(pair: str) -> Tuple[str, str]:\n    \"\"\"Parse a single key-value pair string.\"\"\"\n    key, _, value = pair.partition('=')\n    return key.strip(), value\n\ndef check_duplicate_key(key: str, result: Dict[str, str]) -> None:\n    \"\"\"Check if key already exists in result dictionary.\"\"\"\n    if key in result:\n        raise ValueError(f\"Duplicate key found: {key}\")\n\ndef parse_unique_urlencoded(content: str) -> Dict[str, str]:\n    \"\"\"\n    Parse unique key-value parameters from URL-encoded content.\n    \n    Args:\n        content: URL-encoded key-value pairs\n        \n    Returns:\n        Dictionary of parsed key-value pairs\n        \n    Raises:\n        ValueError: If a key is repeated in the content\n    \"\"\"\n    if not content:\n        return {}\n    \n    result = {}\n    pairs = split_into_pairs(content)\n    \n    for pair in pairs:\n        key, value = parse_pair(pair)\n        check_duplicate_key(key, result)\n        result[key] = value\n        \n    return result\n", "Result": "Error"}
{"namespace": "googleapiclient._helpers.parse_unique_urlencoded", "type": "Code Standard", "test": "tests/test__helpers.py::Test_parse_unique_urlencoded::test_check_code_style", "completion": "\nfrom typing import Dict\n\n\ndef parse_unique_urlencoded(content: str) -> Dict[str, str]:\n    \"\"\"\n    Parse unique key-value parameters from URL-encoded content.\n\n    Args:\n        content: URL-encoded key-value pairs\n\n    Returns:\n        Dictionary of parsed key-value pairs\n\n    Raises:\n        ValueError: If a key is repeated in the content\n    \"\"\"\n    if not content:\n        return {}\n\n    result: Dict[str, str] = {}\n    pairs = content.split('&')\n\n    for pair in pairs:\n        if not pair:\n            continue\n\n        key, _, value = pair.partition('=')\n        key = key.strip()\n\n        if key in result:\n            raise ValueError(f\"Duplicate key found: {key}\")\n\n        result[key] = value\n\n    return result\n", "Result": "Error"}
{"namespace": "jinja2.async_utils.auto_aiter", "type": "Input-Output Conditions", "test": "tests/test_async.py::test_input_output_conditions", "completion": ":auto_aiter.py\nfrom typing import Union, AsyncIterable, Iterable, AsyncIterator\n\nasync def auto_aiter(iterable: Union[AsyncIterable, Iterable]) -> AsyncIterator:\n    if hasattr(iterable, '__aiter__'):\n        async for item in iterable:\n            yield item\n    else:\n        for item in iterable:\n            yield item\n", "Result": "Error"}
{"namespace": "jinja2.async_utils.auto_aiter", "type": "Exception Handling", "test": "tests/test_async.py::test_exception_handling", "completion": ":auto_aiter.py\nfrom typing import Union, AsyncIterable, Iterable, AsyncIterator\n\nasync def auto_aiter(iterable: Union[AsyncIterable, Iterable]) -> AsyncIterator:\n    # Check if input is an async iterable\n    is_async = hasattr(iterable, '__aiter__')\n    # Check if input is a regular iterable\n    is_sync = hasattr(iterable, '__iter__')\n    \n    if not (is_async or is_sync):\n        raise TypeError('Input must be an iterable or an asynchronous iterable')\n        \n    if is_async:\n        async for item in iterable:\n            yield item\n    else:\n        for item in iterable:\n            yield item\n", "Result": "Error"}
{"namespace": "jinja2.async_utils.auto_aiter", "type": "Edge Case Handling", "test": "tests/test_async.py::test_edge_case_handling", "completion": ":auto_aiter.py\nfrom typing import Union, AsyncIterable, Iterable, AsyncIterator\nfrom collections.abc import Iterable as ABCIterable\n\nasync def auto_aiter(iterable: Union[AsyncIterable, Iterable]) -> AsyncIterator:\n    # Check if input is a valid iterable\n    if not (hasattr(iterable, '__aiter__') or isinstance(iterable, ABCIterable)):\n        raise TypeError('Input must be an iterable or an asynchronous iterable')\n        \n    # Handle async iterables\n    if hasattr(iterable, '__aiter__'):\n        async for item in iterable:\n            yield item\n    # Handle sync iterables\n    else:\n        for item in iterable:\n            yield item\n", "Result": "Error"}
{"namespace": "jinja2.async_utils.auto_aiter", "type": "Annotation Coverage", "test": "tests/test_async.py::test_annotation_coverage", "completion": ":auto_aiter.py\nfrom typing import Union, AsyncIterable, Iterable, AsyncIterator, Any\n\nasync def auto_aiter(iterable: Union[AsyncIterable[Any], Iterable[Any]]) -> AsyncIterator[Any]:\n    \"\"\"\n    Creates an asynchronous iterator from the given iterable.\n\n    Args:\n        iterable: An iterable or asynchronous iterable to be converted.\n\n    Returns:\n        An asynchronous iterator yielding the same elements as the input iterable.\n\n    Raises:\n        TypeError: If the input is neither an iterable nor an asynchronous iterable.\n    \"\"\"\n    if hasattr(iterable, '__aiter__'):\n        async for item in iterable:\n            yield item\n    elif hasattr(iterable, '__iter__'):\n        for item in iterable:\n            yield item\n    else:\n        raise TypeError('Input must be an iterable or an asynchronous iterable')\n", "Result": "Error"}
{"namespace": "jinja2.async_utils.auto_aiter", "type": "Code Complexity", "test": "tests/test_async.py::test_code_complexity", "completion": ":auto_aiter.py\nfrom typing import Union, AsyncIterable, Iterable, AsyncIterator, Any\n\nasync def auto_aiter(iterable: Union[AsyncIterable[Any], Iterable[Any]]) -> AsyncIterator[Any]:\n    if not hasattr(iterable, '__iter__') and not hasattr(iterable, '__aiter__'):\n        raise TypeError('Input must be an iterable or an asynchronous iterable')\n        \n    if hasattr(iterable, '__aiter__'):\n        async for item in iterable:\n            yield item\n    else:\n        for item in iterable:\n            yield item\n", "Result": "Error"}
{"namespace": "jinja2.async_utils.auto_aiter", "type": "Code Standard", "test": "tests/test_async.py::test_check_code_style", "completion": ":auto_aiter.py\nfrom typing import Union, AsyncIterable, Iterable, AsyncIterator, Any\n\n\nasync def auto_aiter(\n    iterable: Union[AsyncIterable[Any], Iterable[Any]]\n) -> AsyncIterator[Any]:\n    \"\"\"\n    Create an asynchronous iterator from the given iterable.\n\n    This function checks if the iterable has an __aiter__ attribute and if so,\n    it yields items asynchronously, otherwise, it yields items synchronously.\n\n    Args:\n        iterable: The input iterable from which the iterator is created.\n                 Can be either an AsyncIterable or a regular Iterable.\n\n    Returns:\n        An asynchronous iterator that yields elements from the input iterable.\n\n    Raises:\n        TypeError: If the input is neither an iterable nor an asynchronous iterable.\n    \"\"\"\n    if not hasattr(iterable, '__iter__') and not hasattr(iterable, '__aiter__'):\n        raise TypeError('Input must be an iterable or an asynchronous iterable')\n\n    if hasattr(iterable, '__aiter__'):\n        async for item in iterable:\n            yield item\n    else:\n        for item in iterable:\n            yield item\n", "Result": "Error"}
{"namespace": "csvs_to_sqlite.utils.table_exists", "type": "Exception Handling", "test": "tests/test_utils.py::test_table_exists_exception_handling", "completion": "\ndef table_exists(conn, table):\n    \"\"\"\n    Check if the table exists in the database.\n    \n    Args:\n        conn: Connection. The connection to the database.\n        table: String. The name of the table to check.\n        \n    Returns:\n        Bool. True if the table exists, False otherwise.\n        \n    Raises:\n        ValueError: If the connection object is None or not a valid database connection.\n    \"\"\"\n    # Check if connection is None\n    if conn is None:\n        raise ValueError(\"Database connection cannot be None\")\n    \n    # Check if connection is valid by checking for common database connection attributes\n    if not hasattr(conn, 'cursor') or not hasattr(conn, 'commit') or not hasattr(conn, 'close'):\n        raise ValueError(\"Invalid database connection object\")\n    \n    try:\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            SELECT name \n            FROM sqlite_master \n            WHERE type='table' AND name=?\n        \"\"\", (table,))\n        return cursor.fetchone() is not None\n    except Exception as e:\n        print(f\"Error checking table existence: {e}\")\n        return False\n    finally:\n        cursor.close()\n", "Result": "Pass"}
{"namespace": "csvs_to_sqlite.utils.table_exists", "type": "Edge Case Handling", "test": "tests/test_utils.py::test_table_exists_edge_cases", "completion": "\ndef table_exists(conn, table):\n    \"\"\"\n    Check if the table exists in the database.\n    \n    Args:\n        conn: Connection. The connection to the database.\n        table: String. The name of the table to check.\n        \n    Returns:\n        Bool. True if the table exists, False otherwise.\n        \n    Raises:\n        ValueError: If the connection is None or invalid.\n    \"\"\"\n    if conn is None:\n        raise ValueError(\"Database connection cannot be None\")\n    \n    # Validate table name\n    if not isinstance(table, str):\n        raise ValueError(\"Table name must be a string\")\n    \n    if len(table.strip()) == 0:\n        raise ValueError(\"Table name cannot be empty\")\n        \n    try:\n        cursor = conn.cursor()\n        \n        # Use parameterized query to safely handle special characters\n        # Escape quotes and other special characters in table name\n        cursor.execute(\"\"\"\n            SELECT COUNT(*)\n            FROM sqlite_master \n            WHERE type='table' \n            AND name = ?\n            COLLATE NOCASE\n        \"\"\", (table,))\n        \n        result = cursor.fetchone()[0]\n        return result > 0\n        \n    except Exception as e:\n        raise ValueError(f\"Error checking table existence: {e}\")\n    finally:\n        if 'cursor' in locals():\n            cursor.close()\n", "Result": "Pass"}
{"namespace": "csvs_to_sqlite.utils.table_exists", "type": "Annotation Coverage", "test": "tests/test_utils.py::test_table_exists_annotation_coverage", "completion": "\nfrom typing import Union\nimport sqlite3\n\ndef table_exists(conn: sqlite3.Connection, table: str) -> bool:\n    \"\"\"\n    Check if the table exists in the database.\n    \n    Args:\n        conn: sqlite3.Connection. The connection to the database.\n        table: str. The name of the table to check.\n        \n    Returns:\n        bool: True if the table exists, False otherwise.\n        \n    Raises:\n        ValueError: If the connection object is None or not a valid database connection.\n    \"\"\"\n    if conn is None or not isinstance(conn, sqlite3.Connection):\n        raise ValueError(\"Invalid database connection\")\n        \n    if not isinstance(table, str):\n        raise ValueError(\"Table name must be a string\")\n        \n    try:\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            SELECT name \n            FROM sqlite_master \n            WHERE type='table' AND name=?\n        \"\"\", (table,))\n        return cursor.fetchone() is not None\n    except Exception as e:\n        print(f\"Error checking table existence: {e}\")\n        return False\n    finally:\n        cursor.close()\n", "Result": "Pass"}
{"namespace": "csvs_to_sqlite.utils.table_exists", "type": "Code Complexity", "test": "tests/test_utils.py::test_code_complexity", "completion": ":database_utils.py\nfrom typing import Optional\nimport sqlite3\n\ndef table_exists(conn: sqlite3.Connection, table: str) -> bool:\n    \"\"\"\n    Check if the table exists in the database.\n    \n    Args:\n        conn: sqlite3.Connection\n            The connection to the database.\n        table: str\n            The name of the table to check.\n            \n    Returns:\n        bool: True if the table exists, False otherwise.\n        \n    Raises:\n        ValueError: If the connection object is None or invalid.\n    \"\"\"\n    if not isinstance(conn, sqlite3.Connection):\n        raise ValueError(\"Connection must be a valid sqlite3.Connection object\")\n        \n    cursor = conn.cursor()\n    cursor.execute(\"\"\"\n        SELECT COUNT(name) \n        FROM sqlite_master \n        WHERE type='table' AND name=?\n    \"\"\", (table,))\n    \n    exists = bool(cursor.fetchone()[0])\n    cursor.close()\n    return exists\n", "Result": "Error"}
{"namespace": "csvs_to_sqlite.utils.table_exists", "type": "Code Standard", "test": "tests/test_utils.py::test_check_code_style", "completion": ":database_utils.py\nfrom typing import Optional\nimport sqlite3\n\n\ndef table_exists(conn: sqlite3.Connection, table: str) -> bool:\n    \"\"\"\n    Check if the table exists in the database.\n\n    Args:\n        conn: The connection to the database.\n        table: The name of the table to check.\n\n    Returns:\n        True if the table exists, False otherwise.\n\n    Raises:\n        ValueError: If the connection object is None or invalid.\n    \"\"\"\n    if not isinstance(conn, sqlite3.Connection):\n        raise ValueError(\"Invalid database connection object\")\n\n    if not isinstance(table, str):\n        raise ValueError(\"Table name must be a string\")\n\n    if not table.strip():\n        raise ValueError(\"Table name cannot be empty\")\n\n    try:\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n            SELECT name \n            FROM sqlite_master \n            WHERE type='table' AND name=?\n        \"\"\", (table,))\n        return cursor.fetchone() is not None\n    finally:\n        cursor.close()\n", "Result": "Error"}
{"namespace": "sqlitedict.SqliteDict.get_tablenames", "type": "Input-Output Conditions", "test": "tests/test_core.py::TablenamesTest::test_input_output_conditions", "completion": "\ndef get_tablenames(filename: str) -> list[str]:\n    import sqlite3\n    import os\n\n    # Type checking for filename parameter\n    if not isinstance(filename, str):\n        raise TypeError(\"filename must be a string\")\n\n    if not os.path.exists(filename):\n        raise IOError(f\"file {filename} does not exist\")\n    \n    try:\n        conn = sqlite3.connect(filename)\n        cursor = conn.cursor()\n        \n        # Query to get all table names\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table';\")\n        tables = cursor.fetchall()\n        \n        # Convert list of tuples to list of strings\n        table_names = [table[0] for table in tables]\n        \n        return table_names\n    finally:\n        if 'conn' in locals():\n            conn.close()\n", "Result": "Pass"}
{"namespace": "sqlitedict.SqliteDict.get_tablenames", "type": "Exception Handling", "test": "tests/test_core.py::TablenamesTest::test_exception_handling", "completion": "\ndef get_tablenames(filename: str) -> list[str]:\n    import sqlite3\n    import os\n\n    if not os.path.exists(filename):\n        raise IOError(f\"file {filename} does not exist\")\n    \n    try:\n        conn = sqlite3.connect(filename)\n        cursor = conn.cursor()\n        \n        # Query to get all table names\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table';\")\n        tables = cursor.fetchall()\n        \n        # Convert list of tuples to list of strings\n        # Will return empty list if no tables exist\n        table_names = [table[0] for table in tables]\n        \n        return table_names\n    finally:\n        if 'conn' in locals():\n            conn.close()\n", "Result": "Pass"}
{"namespace": "sqlitedict.SqliteDict.get_tablenames", "type": "Edge Case Handling", "test": "tests/test_core.py::TablenamesTest::test_edge_case_handling", "completion": "\nimport sqlite3\nimport os\n\ndef test_get_tablenames():\n    # Create an empty database\n    test_db = \"test_empty.db\"\n    conn = sqlite3.connect(test_db)\n    conn.close()\n    \n    # Test the function\n    result = get_tablenames(test_db)\n    print(f\"Tables in empty database: {result}\")  # Will print: Tables in empty database: []\n    \n    # Cleanup\n    os.remove(test_db)\n\ntest_get_tablenames()\n", "Result": "Error"}
{"namespace": "sqlitedict.SqliteDict.get_tablenames", "type": "Annotation Coverage", "test": "tests/test_core.py::TablenamesTest::test_annotation_coverage", "completion": "\nfrom typing import List\n\ndef get_tablenames(filename: str) -> List[str]:\n    import sqlite3\n    import os\n\n    if not os.path.exists(filename):\n        raise IOError(f\"file {filename} does not exist\")\n    \n    try:\n        conn = sqlite3.connect(filename)\n        cursor = conn.cursor()\n        \n        # Query to get all table names\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table';\")\n        tables = cursor.fetchall()\n        \n        # Convert list of tuples to list of strings\n        table_names = [table[0] for table in tables]\n        \n        return table_names\n    finally:\n        if 'conn' in locals():\n            conn.close()\n", "Result": "Error"}
{"namespace": "sqlitedict.SqliteDict.get_tablenames", "type": "Code Complexity", "test": "tests/test_core.py::TablenamesTest::test_code_complexity", "completion": "\ndef get_tablenames(filename: str) -> list[str]:\n    import sqlite3\n    import os\n    \n    if not os.path.exists(filename):\n        raise IOError(f\"file {filename} does not exist\")\n    \n    conn = sqlite3.connect(filename)\n    cursor = conn.cursor()\n    \n    cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table';\")\n    table_names = [table[0] for table in cursor.fetchall()]\n    \n    conn.close()\n    return table_names\n", "Result": "Error"}
{"namespace": "sqlitedict.SqliteDict.get_tablenames", "type": "Code Standard", "test": "tests/test_core.py::TablenamesTest::test_check_code_style", "completion": "\ndef get_tablenames(filename: str) -> list[str]:\n    \"\"\"\n    Retrieve the names of tables in an SQLite database.\n\n    Args:\n        filename (str): The name of the SQLite database file.\n\n    Returns:\n        list[str]: The names of the tables in the SQLite database.\n\n    Raises:\n        IOError: If the specified database file does not exist.\n    \"\"\"\n    import sqlite3\n    import os\n\n    if not os.path.exists(filename):\n        raise IOError(f\"file {filename} does not exist\")\n\n    try:\n        conn = sqlite3.connect(filename)\n        cursor = conn.cursor()\n\n        # Query to get all table names\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table';\")\n        tables = cursor.fetchall()\n\n        # Convert list of tuples to list of strings\n        table_names = [table[0] for table in tables]\n\n        return table_names\n\n    finally:\n        if 'conn' in locals():\n            conn.close()\n", "Result": "Error"}
{"namespace": "psd_tools.utils.pack", "type": "Exception Handling", "test": "tests/psd_tools/test_utils.py::test_pack_exception_handling", "completion": "\ndef pack(fmt: str, *args) -> bytes:\n    \"\"\"\n    Pack arguments into a binary string according to the given format.\n    \n    :param fmt: String. Format string that specifies the format (e.g., '>I', '>f')\n    :param *args: Tuple. Input arguments to be packed\n    :return: Binary string containing the packed values\n    :raises ValueError: If format string is invalid or number of arguments doesn't match format\n    \"\"\"\n    import struct\n    \n    try:\n        # Calculate expected number of arguments from format string\n        # Remove the byte order indicator ('>' or '<') if present\n        format_chars = fmt[1:] if fmt and fmt[0] in '<>=' else fmt\n        expected_args = sum(not c.isdigit() for c in format_chars)\n        \n        if len(args) != expected_args:\n            raise ValueError(\n                f\"Format string '{fmt}' requires {expected_args} arguments, but {len(args)} were provided\"\n            )\n            \n        return struct.pack(fmt, *args)\n        \n    except struct.error as e:\n        raise ValueError(f\"Invalid format string '{fmt}': {str(e)}\")\n", "Result": "Error"}
{"namespace": "psd_tools.utils.pack", "type": "Annotation Coverage", "test": "tests/psd_tools/test_utils.py::test_pack_annotations", "completion": "\nfrom typing import Tuple, Any\n\ndef pack(fmt: str, *args: Any) -> bytes:\n    \"\"\"\n    Pack arguments into a binary string according to the given format.\n    \n    :param fmt: String. Format string that specifies the format (e.g., '>I', '>f')\n    :param *args: Tuple. Input arguments to be packed\n    :return: Binary string containing the packed values\n    \"\"\"\n    import struct\n    return struct.pack(fmt, *args)\n", "Result": "Error"}
{"namespace": "psd_tools.utils.pack", "type": "Code Complexity", "test": "tests/psd_tools/test_utils.py::test_code_complexity", "completion": "\ndef pack(fmt: str, *args) -> bytes:\n    \"\"\"\n    Pack arguments into a binary string according to the given format.\n    \n    :param fmt: String. Format string that specifies the format (e.g., '>I', '>f')\n    :param *args: Tuple. Input arguments to be packed\n    :return: Binary string containing the packed values\n    :raises ValueError: If format string is invalid or argument count doesn't match\n    \"\"\"\n    import struct\n    \n    if not fmt:\n        raise ValueError(\"Format string cannot be empty\")\n        \n    try:\n        # Calculate expected argument count from format string\n        expected_args = len(fmt.replace('>', '').replace('<', ''))\n        \n        if len(args) != expected_args:\n            raise ValueError(f\"Expected {expected_args} arguments, got {len(args)}\")\n            \n        return struct.pack(fmt, *args)\n        \n    except struct.error as e:\n        raise ValueError(f\"Invalid format string or arguments: {str(e)}\")\n", "Result": "Error"}
{"namespace": "psd_tools.utils.pack", "type": "Code Standard", "test": "tests/psd_tools/test_utils.py::test_check_code_style", "completion": ":packer.py\ndef pack(fmt: str, *args) -> bytes:\n    \"\"\"Pack arguments into a binary string according to the given format.\n\n    Args:\n        fmt: Format string that specifies the format (e.g., '>I', '>f').\n        *args: Input arguments to be packed.\n\n    Returns:\n        bytes: Binary string containing the packed values.\n\n    Raises:\n        ValueError: If the format string is invalid or number of arguments\n            doesn't match the format string.\n\n    Examples:\n        >>> pack('>I', 42)  # Pack integer 42 as big-endian\n        b'*\\\\x00\\\\x00\\\\x00'\n        >>> pack('>If', 1, 3.14)  # Pack an integer and float\n        b'\\\\x00\\\\x00\\\\x00\\\\x01@H\\\\xf5\\\\xc3'\n    \"\"\"\n    import struct\n    try:\n        return struct.pack(fmt, *args)\n    except struct.error as e:\n        raise ValueError(f\"Packing failed: {str(e)}\") from None\n", "Result": "Error"}
{"namespace": "psd_tools.utils.unpack", "type": "Exception Handling", "test": "tests/psd_tools/test_utils.py::test_unpack_exception_handling", "completion": "\ndef unpack(fmt: str, data: bytes) -> tuple:\n    \"\"\"\n    Unpacks binary data according to the specified format.\n    \n    Args:\n        fmt (str): Format string for unpacking (e.g., '>hhl' for big-endian 2 shorts and 1 long)\n        data (bytes): Binary data to unpack\n        \n    Returns:\n        tuple: Tuple containing the unpacked values\n        \n    Raises:\n        ValueError: If the format string is invalid or if data length doesn't match format\n        \n    Example:\n        unpack('>hh', b'\\x00\\x01\\x00\\x02') -> (1, 2)\n    \"\"\"\n    import struct\n    \n    try:\n        # Calculate expected size based on format\n        expected_size = struct.calcsize(fmt)\n        \n        # Check if data length matches expected size\n        if len(data) != expected_size:\n            raise ValueError('Data length does not match format')\n            \n        # Attempt to unpack the data\n        return struct.unpack(fmt, data)\n        \n    except struct.error:\n        raise ValueError('Invalid format string')\n", "Result": "Error"}
{"namespace": "psd_tools.utils.unpack", "type": "Edge Case Handling", "test": "tests/psd_tools/test_utils.py::test_unpack_edge_cases", "completion": "\ndef unpack(fmt: str, data: bytes) -> tuple:\n    \"\"\"\n    Unpacks binary data according to the specified format.\n    \n    Args:\n        fmt (str): Format string for unpacking (e.g., '>hhl' for big-endian 2 shorts and 1 long)\n        data (bytes): Binary data to unpack\n        \n    Returns:\n        tuple: Tuple containing the unpacked values\n        \n    Raises:\n        ValueError: If format string is invalid or data length doesn't match format\n        TypeError: If data is not bytes object\n        \n    Examples:\n        unpack('>hh', b'\\x00\\x01\\x00\\x02') -> (1, 2)\n        unpack('', b'') -> ()\n    \"\"\"\n    import struct\n    \n    # Handle empty format string case\n    if not fmt:\n        if data:\n            raise ValueError(\"Data length does not match format\")\n        return ()\n    \n    # Validate input types\n    if not isinstance(data, bytes):\n        raise TypeError(\"Data must be bytes object\")\n        \n    try:\n        # Calculate expected data length from format string\n        expected_length = struct.calcsize(fmt)\n        \n        # Check if data length matches format\n        if len(data) != expected_length:\n            raise ValueError(\"Data length does not match format\")\n            \n        return struct.unpack(fmt, data)\n        \n    except struct.error:\n        raise ValueError(\"Invalid format string\")\n", "Result": "Error"}
{"namespace": "psd_tools.utils.unpack", "type": "Annotation Coverage", "test": "tests/psd_tools/test_utils.py::test_unpack_annotations", "completion": ":unpack.py\nfrom typing import Tuple, Any\nimport struct\n\ndef unpack(fmt: str, data: bytes) -> Tuple[Any, ...]:\n    \"\"\"\n    Unpacks binary data according to the specified format.\n    \n    Args:\n        fmt (str): Format string for unpacking (e.g., '>hhl' for big-endian 2 shorts and 1 long)\n        data (bytes): Binary data to unpack\n        \n    Returns:\n        Tuple[Any, ...]: Tuple containing the unpacked values\n        \n    Raises:\n        ValueError: If format string is invalid or data length doesn't match format\n        \n    Example:\n        unpack('>hh', b'\\x00\\x01\\x00\\x02') -> (1, 2)\n    \"\"\"\n    if not fmt:\n        if data:\n            raise ValueError(\"Data provided but format string is empty\")\n        return tuple()\n    \n    try:\n        expected_size = struct.calcsize(fmt)\n    except struct.error:\n        raise ValueError(\"Invalid format string\")\n    \n    if len(data) != expected_size:\n        raise ValueError(\"Data length does not match format\")\n        \n    try:\n        return struct.unpack(fmt, data)\n    except struct.error as e:\n        raise ValueError(f\"Unpacking failed: {str(e)}\")\n", "Result": "Error"}
{"namespace": "psd_tools.utils.unpack", "type": "Code Complexity", "test": "tests/psd_tools/test_utils.py::test_code_complexity", "completion": ":unpack.py\ndef unpack(fmt: str, data: bytes) -> tuple:\n    \"\"\"\n    Unpacks binary data according to the specified format.\n    \n    Args:\n        fmt (str): Format string for unpacking (e.g., '>hhl' for big-endian 2 shorts and 1 long)\n        data (bytes): Binary data to unpack\n        \n    Returns:\n        tuple: Tuple containing the unpacked values\n        \n    Raises:\n        ValueError: If format string is invalid or data length doesn't match format\n        \n    Example:\n        unpack('>hh', b'\\x00\\x01\\x00\\x02') -> (1, 2)\n    \"\"\"\n    import struct\n    \n    # Pre-validate format string\n    try:\n        expected_size = struct.calcsize(fmt)\n    except struct.error:\n        raise ValueError('Invalid format string')\n    \n    # Validate data length\n    if len(data) != expected_size:\n        raise ValueError('Data length does not match format')\n        \n    # Single return statement for cyclomatic complexity of 1\n    return struct.unpack(fmt, data)\n", "Result": "Error"}
{"namespace": "psd_tools.utils.unpack", "type": "Code Standard", "test": "tests/psd_tools/test_utils.py::test_check_code_style", "completion": ":unpack.py\nfrom typing import Tuple\nimport struct\n\n\ndef unpack(fmt: str, data: bytes) -> Tuple:\n    \"\"\"\n    Unpacks binary data according to the specified format.\n\n    Args:\n        fmt: Format string for unpacking (e.g., '>hhl' for big-endian 2 shorts and 1 long)\n        data: Binary data to unpack\n\n    Returns:\n        Tuple containing the unpacked values\n\n    Raises:\n        ValueError: If format string is invalid or data length doesn't match format\n        struct.error: If there's an error during unpacking\n\n    Examples:\n        >>> unpack('>hh', b'\\x00\\x01\\x00\\x02')\n        (1, 2)\n        >>> unpack('>i', b'\\x00\\x00\\x00\\x01')\n        (1,)\n    \"\"\"\n    try:\n        if not fmt or not data:\n            raise ValueError(\"Format string and data cannot be empty\")\n        \n        expected_size = struct.calcsize(fmt)\n        if len(data) != expected_size:\n            raise ValueError(\"Data length does not match format\")\n        \n        return struct.unpack(fmt, data)\n    \n    except struct.error:\n        raise ValueError(\"Invalid format string\")\n", "Result": "Error"}
{"namespace": "exodus_bundler.bundling.bytes_to_int", "type": "Input-Output Conditions", "test": "tests/test_bundling.py::test_input_output_conditions", "completion": "\ndef bytes_to_int(bytes_str: bytes, byteorder: str = \"big\") -> int:\n    \"\"\"\n    Convert a byte string into an integer.\n    \n    Args:\n        bytes_str: Byte string to be converted into an integer\n        byteorder: Byte order to be used (\"big\" or \"little\"), defaults to \"big\"\n    \n    Returns:\n        Integer converted from the byte string\n        \n    Raises:\n        ValueError: If bytes_str is empty or byteorder is not 'big' or 'little'\n    \"\"\"\n    # Validate input byte string\n    if not bytes_str:\n        raise ValueError(\"Input byte string cannot be empty\")\n    \n    # Validate byte order\n    if byteorder not in [\"big\", \"little\"]:\n        raise ValueError(\"Byte order must be either 'big' or 'little'\")\n    \n    return int.from_bytes(bytes_str, byteorder=byteorder)\n", "Result": "Pass"}
{"namespace": "exodus_bundler.bundling.bytes_to_int", "type": "Exception Handling", "test": "tests/test_bundling.py::test_exception_handling", "completion": "\ndef bytes_to_int(bytes_str: bytes, byteorder: str = \"big\") -> int:\n    \"\"\"\n    Convert a byte string into an integer.\n    \n    Args:\n        bytes_str: Byte string to be converted into an integer\n        byteorder: Byte order to be used (\"big\" or \"little\"), defaults to \"big\"\n    \n    Returns:\n        Integer converted from the byte string\n        \n    Raises:\n        ValueError: If byteorder is not 'big' or 'little'\n    \"\"\"\n    if byteorder not in [\"big\", \"little\"]:\n        raise ValueError(\"byteorder must be either 'big' or 'little'\")\n        \n    return int.from_bytes(bytes_str, byteorder=byteorder)\n", "Result": "Error"}
{"namespace": "exodus_bundler.bundling.bytes_to_int", "type": "Edge Case Handling", "test": "tests/test_bundling.py::test_edge_case_handling", "completion": "\ndef bytes_to_int(bytes_str: bytes, byteorder: str = \"big\") -> int:\n    \"\"\"\n    Convert a byte string into an integer.\n    \n    Args:\n        bytes_str: Byte string to be converted into an integer\n        byteorder: Byte order to be used (\"big\" or \"little\"), defaults to \"big\"\n    \n    Returns:\n        Integer converted from the byte string\n        \n    Raises:\n        ValueError: If bytes_str is empty or byteorder is invalid\n        OverflowError: If the byte string represents a value larger than the maximum integer\n    \"\"\"\n    # Validate input parameters\n    if not bytes_str:\n        raise ValueError(\"Input byte string cannot be empty\")\n        \n    if byteorder not in ('big', 'little'):\n        raise ValueError(\"byteorder must be either 'big' or 'little'\")\n    \n    try:\n        # Convert bytes to integer using specified byte order\n        return int.from_bytes(bytes_str, byteorder=byteorder, signed=True)\n    except OverflowError as e:\n        raise OverflowError(f\"Byte string represents a value too large: {e}\")\n", "Result": "Error"}
{"namespace": "exodus_bundler.bundling.bytes_to_int", "type": "Annotation Coverage", "test": "tests/test_bundling.py::test_annotation_coverage", "completion": "\nfrom typing import Literal\n\ndef bytes_to_int(bytes_str: bytes, byteorder: Literal[\"big\", \"little\"] = \"big\") -> int:\n    \"\"\"\n    Convert a byte string into an integer.\n    \n    Args:\n        bytes_str: Byte string to be converted into an integer\n        byteorder: Byte order to be used (\"big\" or \"little\"), defaults to \"big\"\n    \n    Returns:\n        int: Integer converted from the byte string\n        \n    Raises:\n        ValueError: If bytes_str is empty or byteorder is not 'big' or 'little'\n    \"\"\"\n    if not bytes_str:\n        raise ValueError(\"Input bytes cannot be empty\")\n        \n    if byteorder not in (\"big\", \"little\"):\n        raise ValueError(\"byteorder must be either 'big' or 'little'\")\n        \n    return int.from_bytes(bytes_str, byteorder=byteorder)\n", "Result": "Error"}
{"namespace": "exodus_bundler.bundling.bytes_to_int", "type": "Code Complexity", "test": "tests/test_bundling.py::test_code_complexity", "completion": "\ndef bytes_to_int(bytes_str: bytes, byteorder: str = \"big\") -> int:\n    \"\"\"\n    Convert a byte string into an integer.\n    \n    Args:\n        bytes_str: Byte string to be converted into an integer\n        byteorder: Byte order to be used (\"big\" or \"little\"), defaults to \"big\"\n    \n    Returns:\n        Integer converted from the byte string\n        \n    Raises:\n        ValueError: If bytes_str is empty or byteorder is not 'big' or 'little'\n    \"\"\"\n    if not bytes_str:\n        raise ValueError(\"Input bytes string cannot be empty\")\n    \n    if byteorder not in (\"big\", \"little\"):\n        raise ValueError(\"byteorder must be either 'big' or 'little'\")\n        \n    return int.from_bytes(bytes_str, byteorder=byteorder)\n", "Result": "Error"}
{"namespace": "exodus_bundler.bundling.bytes_to_int", "type": "Code Standard", "test": "tests/test_bundling.py::test_check_code_style", "completion": "\ndef bytes_to_int(bytes_str: bytes, byteorder: str = \"big\") -> int:\n    \"\"\"\n    Convert a byte string into an integer.\n\n    Args:\n        bytes_str: Byte string to be converted into an integer.\n        byteorder: Byte order to be used (\"big\" or \"little\"), defaults to \"big\".\n\n    Returns:\n        int: The converted integer value.\n\n    Raises:\n        ValueError: If byteorder is not 'big' or 'little'.\n        ValueError: If bytes_str is empty.\n    \"\"\"\n    if not bytes_str:\n        raise ValueError(\"Input bytes string cannot be empty\")\n\n    if byteorder not in (\"big\", \"little\"):\n        raise ValueError(\"byteorder must be either 'big' or 'little'\")\n\n    return int.from_bytes(bytes_str, byteorder=byteorder)\n", "Result": "Error"}
{"namespace": "exodus_bundler.templating.render_template", "type": "Input-Output Conditions", "test": "tests/test_templating.py::test_render_template_input_output_conditions", "completion": "\ndef render_template(string: str, context: dict) -> str:\n    \"\"\"\n    Replace placeholders in a string with values from a context dictionary.\n    \n    Args:\n        string: Input string containing placeholders in {{key}} format\n        context: Dictionary with key-value pairs for replacement\n        \n    Returns:\n        Modified string with all placeholders replaced by values\n        \n    Examples:\n        >>> render_template(\"Hello {{name}}!\", {\"name\": \"John\"})\n        'Hello John!'\n        >>> render_template(\"{{greeting}} {{name}}\", {\"greeting\": \"Hi\", \"name\": \"Alice\"})\n        'Hi Alice'\n    \"\"\"\n    if not isinstance(string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    if not isinstance(context, dict):\n        raise TypeError(\"Context must be a dictionary\")\n        \n    result = string\n    for key, value in context.items():\n        placeholder = \"{{\" + str(key).strip() + \"}}\"\n        if placeholder in result:\n            result = result.replace(placeholder, str(value))\n            \n    return result\n", "Result": "Error"}
{"namespace": "exodus_bundler.templating.render_template", "type": "Exception Handling", "test": "tests/test_templating.py::test_render_template_exception_handling", "completion": "\ndef render_template(string: str, context: dict) -> str:\n    \"\"\"\n    Replace placeholders in a string with values from a context dictionary.\n    \n    Args:\n        string: Input string containing placeholders\n        context: Dictionary with key-value pairs for replacement\n        \n    Returns:\n        Modified string with placeholders replaced by values\n        \n    Raises:\n        KeyError: If a placeholder in the string doesn't have a matching key in context\n    \"\"\"\n    result = string\n    \n    # Find all placeholders in the string\n    start = 0\n    while True:\n        start = result.find(\"{{\", start)\n        if start == -1:\n            break\n            \n        end = result.find(\"}}\", start)\n        if end == -1:\n            break\n            \n        # Extract the key from the placeholder\n        key = result[start + 2:end].strip()\n        \n        # Check if key exists in context\n        if key not in context:\n            raise KeyError(f\"Placeholder '{key}' not found in context dictionary\")\n            \n        # Replace the placeholder with the value\n        placeholder = \"{{\" + key + \"}}\"\n        result = result.replace(placeholder, str(context[key]))\n        \n        start = end + 2\n        \n    return result\n", "Result": "Error"}
{"namespace": "exodus_bundler.templating.render_template", "type": "Edge Case Handling", "test": "tests/test_templating.py::test_render_template_edge_case_handling", "completion": "\ndef render_template(string: str, context: dict) -> str:\n    \"\"\"\n    Replace placeholders in a string with values from a context dictionary.\n    \n    Args:\n        string: Input string containing placeholders\n        context: Dictionary with key-value pairs for replacement\n        \n    Returns:\n        Modified string with placeholders replaced by values\n        \n    Raises:\n        KeyError: If a placeholder has no corresponding key in context\n    \"\"\"\n    # Handle empty string case\n    if not string:\n        return \"\"\n        \n    result = string\n    for key, value in context.items():\n        placeholder = \"{{\" + key + \"}}\"\n        result = result.replace(placeholder, str(value))\n    return result\n", "Result": "Error"}
{"namespace": "exodus_bundler.templating.render_template", "type": "Annotation Coverage", "test": "tests/test_templating.py::test_render_template_annotation_coverage", "completion": "\nfrom typing import Dict\n\ndef render_template(string: str, context: Dict[str, any]) -> str:\n    \"\"\"\n    Replace placeholders in a string with values from a context dictionary.\n    \n    Args:\n        string: Input string containing placeholders in {{key}} format\n        context: Dictionary with key-value pairs for replacement\n        \n    Returns:\n        Modified string with placeholders replaced by values\n        \n    Raises:\n        KeyError: If a placeholder in the string has no matching key in context\n    \"\"\"\n    if not string:\n        return \"\"\n        \n    result = string\n    # Find all placeholders in the format {{key}}\n    for key, value in context.items():\n        placeholder = \"{{\" + key + \"}}\"\n        if placeholder in result:\n            result = result.replace(placeholder, str(value))\n            \n    # Check if any placeholders remain\n    if \"{{\" in result and \"}}\" in result:\n        # Extract the key from the remaining placeholder\n        start = result.index(\"{{\") + 2\n        end = result.index(\"}}\")\n        missing_key = result[start:end]\n        raise KeyError(f\"Key '{missing_key}' not found in context dictionary\")\n            \n    return result\n", "Result": "Error"}
{"namespace": "exodus_bundler.templating.render_template", "type": "Code Complexity", "test": "tests/test_templating.py::test_render_template", "completion": "\ndef render_template(string: str, context: dict) -> str:\n    \"\"\"\n    Replace placeholders in a string with values from a context dictionary.\n    \n    Args:\n        string: Input string containing placeholders\n        context: Dictionary with key-value pairs for replacement\n        \n    Returns:\n        Modified string with placeholders replaced by values\n        \n    Raises:\n        KeyError: If a placeholder in the string has no matching key in context\n    \"\"\"\n    if not string:\n        return \"\"\n        \n    result = string\n    for key in get_placeholders(result):\n        result = result.replace(f\"{{{{{key}}}}}\", str(context[key]))\n    \n    return result\n\ndef get_placeholders(string: str) -> set[str]:\n    \"\"\"\n    Extract unique placeholder keys from a template string.\n    \n    Args:\n        string: Template string containing placeholders\n        \n    Returns:\n        Set of placeholder keys without {{ }}\n    \"\"\"\n    start, end = \"{{\", \"}}\"\n    placeholders = set()\n    \n    start_pos = 0\n    while True:\n        start_pos = string.find(start, start_pos)\n        if start_pos == -1:\n            break\n            \n        end_pos = string.find(end, start_pos)\n        if end_pos == -1:\n            break\n            \n        key = string[start_pos + len(start):end_pos].strip()\n        placeholders.add(key)\n        start_pos = end_pos\n        \n    return placeholders\n", "Result": "Error"}
{"namespace": "exodus_bundler.templating.render_template", "type": "Code Standard", "test": "tests/test_templating.py::test_check_code_style", "completion": "\ndef render_template(string: str, context: dict) -> str:\n    \"\"\"Replace placeholders in a string with values from a context dictionary.\n\n    Args:\n        string: Input string containing placeholders in {{key}} format.\n        context: Dictionary containing key-value pairs for replacement.\n\n    Returns:\n        str: Modified string with placeholders replaced by values.\n\n    Raises:\n        KeyError: If a placeholder in the string has no matching key in context.\n\n    Examples:\n        >>> render_template(\"Hello {{name}}!\", {\"name\": \"John\"})\n        'Hello John!'\n    \"\"\"\n    if not string:\n        return \"\"\n\n    result = string\n    for key, value in context.items():\n        placeholder = f\"{{{{{key}}}}}\"\n        result = result.replace(placeholder, str(value))\n    return result\n", "Result": "Error"}
{"namespace": "trailscraper.iam.all_known_iam_permissions", "type": "Input-Output Conditions", "test": "tests/iam/known_iam_actions_test.py::test_output_type_and_content", "completion": "\ndef all_known_iam_permissions():\n    \"\"\"\n    Returns a set of all known IAM actions by reading from 'known-iam-actions.txt'\n    Each line in the file should represent a valid IAM action.\n    \n    :return: set - A set of strings, each representing a valid IAM action\n    :raises: FileNotFoundError if the actions file is not found\n    :raises: IOError if there are issues reading the file\n    \"\"\"\n    import os\n    \n    current_dir = os.path.dirname(os.path.abspath(__file__))\n    file_path = os.path.join(current_dir, 'known-iam-actions.txt')\n    \n    try:\n        with open(file_path, 'r') as f:\n            # Read lines, strip whitespace, and filter out empty lines\n            actions = set(line.strip() for line in f if line.strip())\n            \n            # Validate that each action follows IAM format (service:action)\n            valid_actions = {\n                action for action in actions \n                if ':' in action and all(part.strip() for part in action.split(':'))\n            }\n            \n            return valid_actions\n            \n    except FileNotFoundError:\n        raise FileNotFoundError(f\"IAM actions file not found at: {file_path}\")\n    except IOError as e:\n        raise IOError(f\"Error reading IAM actions file: {str(e)}\")\n", "Result": "Pass"}
{"namespace": "trailscraper.iam.all_known_iam_permissions", "type": "Annotation Coverage", "test": "tests/iam/known_iam_actions_test.py::test_docstring_presence", "completion": "\ndef all_known_iam_permissions() -> set:\n    \"\"\"\n    Returns a set of all known IAM actions by reading from 'known-iam-actions.txt'\n    located in the same directory as the current script.\n\n    Args:\n        None\n\n    Returns:\n        set: A set of strings, where each string represents a valid IAM action\n             read from the known-iam-actions.txt file.\n    \"\"\"\n    import os\n    \n    current_dir = os.path.dirname(os.path.abspath(__file__))\n    file_path = os.path.join(current_dir, 'known-iam-actions.txt')\n    \n    with open(file_path, 'r') as f:\n        return set(line.strip() for line in f)\n", "Result": "Pass"}
{"namespace": "trailscraper.iam.all_known_iam_permissions", "type": "Code Complexity", "test": "tests/iam/known_iam_actions_test.py::test_cyclomatic_complexity", "completion": "\ndef all_known_iam_permissions():\n    \"\"\"\n    Returns a list of all known IAM actions by reading from 'known-iam-actions.txt'\n    \n    This function maintains a cyclomatic complexity of 1 by following a single,\n    linear execution path with no conditional branches.\n    \n    :return: set - A set of lines from the file, each representing a valid IAM action\n    \"\"\"\n    import os\n    \n    current_dir = os.path.dirname(os.path.abspath(__file__))\n    file_path = os.path.join(current_dir, 'known-iam-actions.txt')\n    \n    with open(file_path, 'r') as f:\n        return set(line.strip() for line in f)\n", "Result": "Error"}
{"namespace": "trailscraper.iam.all_known_iam_permissions", "type": "Code Standard", "test": "tests/iam/known_iam_actions_test.py::test_check_code_style", "completion": "\ndef all_known_iam_permissions() -> set:\n    \"\"\"\n    Returns a list of all known IAM actions by reading from 'known-iam-actions.txt'.\n\n    The function reads a text file containing IAM actions from the same directory\n    as the current script and returns them as a set of strings.\n\n    Returns:\n        set: A set of strings, where each string represents a valid IAM action.\n    \"\"\"\n    import os\n\n    current_dir = os.path.dirname(os.path.abspath(__file__))\n    file_path = os.path.join(current_dir, 'known-iam-actions.txt')\n\n    with open(file_path, 'r') as f:\n        return set(line.strip() for line in f)\n", "Result": "Error"}
{"namespace": "trailscraper.cloudtrail.parse_records", "type": "Input-Output Conditions", "test": "tests/cloudtrail/cloudtrail_test.py::test_parse_records_with_empty_input", "completion": "\ndef parse_records(json_records):\n    \"\"\"\n    Parse a list of JSON records into Record objects.\n    \n    Args:\n        json_records (List): A list of JSON records to be parsed\n        \n    Returns:\n        List: A list of Record objects parsed from the JSON records.\n               Returns an empty list if input is empty.\n    \"\"\"\n    # Return empty list if input is empty\n    if not json_records:\n        return []\n        \n    # Map each JSON record through _parse_record and filter out None values\n    return [\n        record for record in map(_parse_record, json_records)\n        if record is not None\n    ]\n", "Result": "Pass"}
{"namespace": "trailscraper.cloudtrail.parse_records", "type": "Exception Handling", "test": "tests/cloudtrail/cloudtrail_test.py::test_parse_records_with_invalid_json_format", "completion": "\nimport json\n\ndef parse_records(json_records):\n    \"\"\"\n    Parse a list of JSON records into Record objects.\n    \n    Args:\n        json_records (List): A list of JSON records to be parsed\n        \n    Returns:\n        List: A list of Record objects parsed from the JSON records\n        \n    Raises:\n        ValueError: If any record is not in valid JSON format\n    \"\"\"\n    # Validate JSON format for each record\n    for record in json_records:\n        try:\n            if isinstance(record, str):\n                json.loads(record)\n            elif not isinstance(record, dict):\n                raise ValueError(\"Invalid JSON format\")\n        except json.JSONDecodeError:\n            raise ValueError(\"Invalid JSON format\")\n    \n    # Map each JSON record through _parse_record and filter out None values\n    return [\n        record for record in map(_parse_record, json_records)\n        if record is not None\n    ]\n", "Result": "Pass"}
{"namespace": "trailscraper.cloudtrail.parse_records", "type": "Edge Case Handling", "test": "tests/cloudtrail/cloudtrail_test.py::test_parse_records_with_missing_fields", "completion": "\ndef parse_records(json_records):\n    \"\"\"\n    Parse a list of JSON records into Record objects.\n    \n    Args:\n        json_records (List): A list of JSON records to be parsed\n        \n    Returns:\n        List: A list of Record objects parsed from the JSON records\n        \n    Raises:\n        ValueError: If any of the JSON records are not in a valid JSON format\n    \"\"\"\n    if not json_records:\n        return []\n        \n    parsed_records = []\n    \n    for json_record in json_records:\n        try:\n            record = _parse_record(json_record)\n            if record is not None:\n                parsed_records.append(record)\n        except KeyError:\n            # Skip records with missing fields\n            continue\n        except json.JSONDecodeError:\n            raise ValueError(\"Invalid JSON format\")\n            \n    return parsed_records\n", "Result": "Error"}
{"namespace": "trailscraper.cloudtrail.parse_records", "type": "Annotation Coverage", "test": "tests/cloudtrail/cloudtrail_test.py::test_parse_records_annotations", "completion": "\nfrom typing import List, Dict, Any\nfrom dataclasses import dataclass\n\n@dataclass\nclass Record:\n    # Placeholder for Record class attributes\n    pass\n\ndef parse_records(json_records: List[Dict[str, Any]]) -> List[Record]:\n    \"\"\"\n    Parse a list of JSON records into Record objects.\n    \n    Args:\n        json_records (List[Dict[str, Any]]): A list of JSON records to be parsed\n        \n    Returns:\n        List[Record]: A list of Record objects parsed from the JSON records\n        \n    Raises:\n        ValueError: If any of the JSON records are not in a valid JSON format\n    \"\"\"\n    # Map each JSON record through _parse_record and filter out None values\n    return [\n        record for record in map(_parse_record, json_records)\n        if record is not None\n    ]\n", "Result": "Error"}
{"namespace": "trailscraper.cloudtrail.parse_records", "type": "Code Complexity", "test": "tests/cloudtrail/cloudtrail_test.py::test_code_complexity", "completion": "\nfrom typing import List, Optional\nimport json\nfrom dataclasses import dataclass\n\n@dataclass\nclass Record:\n    # Placeholder for Record class attributes\n    pass\n\ndef _parse_record(json_record: dict) -> Optional[Record]:\n    \"\"\"\n    Parse a single JSON record into a Record object.\n    \n    Args:\n        json_record (dict): A single JSON record to parse\n        \n    Returns:\n        Optional[Record]: A Record object if parsing successful, None otherwise\n    \"\"\"\n    try:\n        return Record(**json_record)\n    except (TypeError, ValueError):\n        return None\n\ndef parse_records(json_records: List[dict]) -> List[Record]:\n    \"\"\"\n    Parse a list of JSON records into Record objects.\n    \n    Args:\n        json_records (List[dict]): A list of JSON records to be parsed\n        \n    Returns:\n        List[Record]: A list of Record objects parsed from the JSON records\n        \n    Raises:\n        ValueError: If any of the JSON records are not in valid JSON format\n    \"\"\"\n    if not json_records:\n        return []\n        \n    try:\n        parsed_records = []\n        for record in json_records:\n            parsed_record = _parse_record(record)\n            if parsed_record is not None:\n                parsed_records.append(parsed_record)\n        return parsed_records\n        \n    except json.JSONDecodeError:\n        raise ValueError(\"Invalid JSON format\")\n", "Result": "Error"}
{"namespace": "trailscraper.cloudtrail.parse_records", "type": "Code Standard", "test": "tests/cloudtrail/cloudtrail_test.py::test_check_code_style", "completion": "\nfrom typing import List, Optional\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Record:\n    \"\"\"Class to represent a record.\"\"\"\n    pass\n\n\ndef parse_records(json_records: List[dict]) -> List[Record]:\n    \"\"\"\n    Parse a list of JSON records into Record objects.\n\n    Args:\n        json_records: A list of JSON records to be parsed.\n\n    Returns:\n        A list of Record objects parsed from the JSON records.\n\n    Raises:\n        ValueError: If any of the JSON records are not in a valid JSON format.\n    \"\"\"\n    if not json_records:\n        return []\n\n    try:\n        parsed_records = [\n            record for record in map(_parse_record, json_records)\n            if record is not None\n        ]\n        return parsed_records\n    except (TypeError, ValueError) as e:\n        raise ValueError(\"Invalid JSON format\") from e\n\n\ndef _parse_record(json_record: dict) -> Optional[Record]:\n    \"\"\"\n    Parse a single JSON record into a Record object.\n\n    Args:\n        json_record: A JSON record to be parsed.\n\n    Returns:\n        A Record object if parsing is successful, None otherwise.\n    \"\"\"\n    try:\n        return Record()  # Replace with actual parsing logic\n    except (TypeError, KeyError):\n        return None\n", "Result": "Error"}
{"namespace": "discord.utils.get_slots", "type": "Input-Output Conditions", "test": "tests/test_utils.py::test_input_output_conditions", "completion": "\nfrom typing import Iterator\nfrom types import GenericAlias\n\ndef get_slots(cls: type) -> Iterator[str]:\n    \"\"\"\n    Returns an iterator that yields the names of slots in a class and its base classes.\n    \n    Args:\n        cls: The class for which the slots are to be retrieved\n        \n    Returns:\n        An iterator yielding slot names as strings\n        \n    Raises:\n        TypeError: If the input is not a class type\n        \n    Example:\n        for slot in get_slots(MyClass):\n            print(slot)\n    \"\"\"\n    # Validate input is a class type\n    if not isinstance(cls, type) and not isinstance(cls, GenericAlias):\n        raise TypeError(f\"Expected a class type, got {type(cls).__name__}\")\n\n    # Check each class in the method resolution order\n    for class_ in cls.__mro__:\n        # Get slots if they exist in the class\n        slots = getattr(class_, '__slots__', ())\n        if isinstance(slots, str):\n            yield slots\n        else:\n            for slot in slots:\n                yield slot\n", "Result": "Pass"}
{"namespace": "discord.utils.get_slots", "type": "Exception Handling", "test": "tests/test_utils.py::test_exception_handling", "completion": "\nfrom typing import Iterator\n\ndef get_slots(cls: type) -> Iterator[str]:\n    \"\"\"\n    Returns an iterator that yields the names of slots in a class and its base classes.\n    \n    Args:\n        cls: The class for which the slots are to be retrieved\n        \n    Returns:\n        An iterator yielding slot names as strings\n        \n    Raises:\n        TypeError: If the input is not a class type\n        \n    Example:\n        for slot in get_slots(MyClass):\n            print(slot)\n    \"\"\"\n    # Check if input is a class type\n    if not isinstance(cls, type):\n        raise TypeError('Input must be a class type.')\n        \n    # Check each class in the method resolution order\n    for class_ in cls.__mro__:\n        # Get slots if they exist in the class\n        slots = getattr(class_, '__slots__', ())\n        if isinstance(slots, str):\n            yield slots\n        else:\n            for slot in slots:\n                yield slot\n", "Result": "Error"}
{"namespace": "discord.utils.get_slots", "type": "Edge Case Handling", "test": "tests/test_utils.py::test_edge_case_handling", "completion": "\ndef get_slots(cls: type) -> Iterator[str]:\n    \"\"\"\n    Returns an iterator that yields the names of slots in a class and its base classes.\n    \n    Args:\n        cls: The class for which the slots are to be retrieved\n        \n    Returns:\n        An iterator yielding slot names as strings\n        \n    Raises:\n        TypeError: If the input is not a class type\n        \n    Example:\n        class A:\n            __slots__ = ('x', 'y')\n            \n        class B(A):\n            pass\n            \n        for slot in get_slots(B):\n            print(slot)  # Outputs: x, y\n    \"\"\"\n    if not isinstance(cls, type):\n        raise TypeError('Input must be a class type.')\n        \n    # Check each class in the method resolution order\n    for class_ in cls.__mro__:\n        # Skip if class doesn't have __slots__ attribute\n        if not hasattr(class_, '__slots__'):\n            continue\n            \n        slots = class_.__slots__\n        \n        # Handle string slot definition\n        if isinstance(slots, str):\n            yield slots\n        # Handle tuple/list slot definitions\n        elif slots:  # Check if slots is not empty\n            for slot in slots:\n                yield slot\n", "Result": "Error"}
{"namespace": "discord.utils.get_slots", "type": "Annotation Coverage", "test": "tests/test_utils.py::test_annotation_coverage", "completion": "\nfrom typing import Type, Any, Iterator\n\ndef get_slots(cls: Type[Any]) -> Iterator[str]:\n    \"\"\"\n    Returns an iterator that yields the names of slots in a class and its base classes.\n    \n    Args:\n        cls: The class for which the slots are to be retrieved\n        \n    Returns:\n        An iterator yielding slot names as strings\n        \n    Raises:\n        TypeError: If the input is not a class type\n        \n    Example:\n        for slot in get_slots(MyClass):\n            print(slot)\n    \"\"\"\n    if not isinstance(cls, type):\n        raise TypeError('Input must be a class type')\n        \n    # Check each class in the method resolution order\n    for class_ in cls.__mro__:\n        # Get slots if they exist in the class\n        slots = getattr(class_, '__slots__', ())\n        if isinstance(slots, str):\n            yield slots\n        else:\n            for slot in slots:\n                yield slot\n", "Result": "Error"}
{"namespace": "discord.utils.get_slots", "type": "Code Complexity", "test": "tests/test_utils.py::test_code_complexity", "completion": ":get_slots.py\nfrom typing import Iterator, Type, Any\n\ndef get_slots(cls: Type[Any]) -> Iterator[str]:\n    \"\"\"\n    Returns an iterator that yields the names of slots in a class and its base classes.\n    \n    Args:\n        cls: The class for which the slots are to be retrieved\n        \n    Returns:\n        An iterator yielding slot names as strings\n        \n    Raises:\n        TypeError: If the input is not a class type\n        \n    Example:\n        for slot in get_slots(MyClass):\n            print(slot)\n    \"\"\"\n    if not isinstance(cls, type):\n        raise TypeError('Input must be a class type')\n        \n    return (slot \n            for class_ in cls.__mro__\n            for slot in (getattr(class_, '__slots__', ()) \n                        if isinstance(getattr(class_, '__slots__', ()), (list, tuple))\n                        else [getattr(class_, '__slots__', ())]))\n", "Result": "Error"}
{"namespace": "discord.utils.get_slots", "type": "Code Standard", "test": "tests/test_utils.py::test_check_code_style", "completion": ":slots.py\nfrom typing import Iterator, Type, Any\n\n\ndef get_slots(cls: Type[Any]) -> Iterator[str]:\n    \"\"\"\n    Returns an iterator that yields the names of slots in a class and its base classes.\n\n    Args:\n        cls: The class for which the slots are to be retrieved.\n\n    Returns:\n        An iterator yielding slot names as strings.\n\n    Raises:\n        TypeError: If the input is not a class type.\n\n    Example:\n        >>> class MyClass:\n        ...     __slots__ = ('name', 'age')\n        >>> list(get_slots(MyClass))\n        ['name', 'age']\n    \"\"\"\n    if not isinstance(cls, type):\n        raise TypeError('Input must be a class type.')\n\n    for class_ in cls.__mro__:\n        slots = getattr(class_, '__slots__', ())\n        if isinstance(slots, str):\n            yield slots\n        else:\n            yield from slots\n", "Result": "Error"}
{"namespace": "discord.utils.is_inside_class", "type": "Input-Output Conditions", "test": "tests/test_utils.py::test_input_output_conditions", "completion": "\ndef is_inside_class(func):\n    \"\"\"\n    Determine whether a given callable is defined within a class.\n    \n    Args:\n        func: Callable. The function to be checked.\n        \n    Returns:\n        bool: True if the function is defined inside a class, False otherwise.\n        \n    Raises:\n        TypeError: If the input is not a callable object.\n    \"\"\"\n    # Strictly check if input is callable\n    if not callable(func):\n        raise TypeError(f\"Expected a callable object, got {type(func).__name__}\")\n    \n    # Get the qualified name of the callable\n    qualname = getattr(func, '__qualname__', '')\n    \n    # If qualname is empty, it's definitely not in a class\n    if not qualname:\n        return False\n    \n    # Split the qualified name into parts\n    parts = qualname.split('.')\n    \n    # A function is inside a class if:\n    # 1. It has at least two parts (class.method)\n    # 2. The first part is not '<locals>' (which would indicate a nested function)\n    return len(parts) >= 2 and parts[0] != '<locals>'\n", "Result": "Error"}
{"namespace": "discord.utils.is_inside_class", "type": "Exception Handling", "test": "tests/test_utils.py::test_exception_handling", "completion": "\ndef is_inside_class(func):\n    \"\"\"\n    Determine whether a given callable is defined within a class.\n    \n    Args:\n        func: Callable. The function to be checked.\n    Returns:\n        bool: True if the function is defined inside a class, False otherwise.\n    Raises:\n        TypeError: If the input is not a callable.\n    \"\"\"\n    if not callable(func):\n        raise TypeError(\"Input must be a callable.\")\n        \n    # Get the qualified name of the callable\n    qualname = getattr(func, '__qualname__', '')\n    \n    # Split the qualified name into parts\n    parts = qualname.split('.')\n    \n    # Check if there are at least 2 parts (class.method)\n    # and the first part is not '<locals>' (nested function)\n    return len(parts) >= 2 and '<locals>' not in parts[:-1]\n", "Result": "Pass"}
{"namespace": "discord.utils.is_inside_class", "type": "Edge Case Handling", "test": "tests/test_utils.py::test_edge_case_handling", "completion": "\ndef is_inside_class(func):\n    \"\"\"\n    Determine whether a given callable is defined within a class.\n    \n    Args:\n        func: Callable. The function to be checked.\n    Returns:\n        bool: True if the function is defined inside a class, False otherwise.\n        \n    Examples:\n        >>> class MyClass:\n        ...     def method(self): pass\n        ...     class NestedClass:\n        ...         def nested_method(self): pass\n        ...     def outer(self):\n        ...         def inner(): pass\n        ...         return inner\n        >>> def standalone(): pass\n        >>> \n        >>> is_inside_class(MyClass.method)  # True\n        >>> is_inside_class(MyClass.NestedClass.nested_method)  # True\n        >>> is_inside_class(MyClass().outer())  # False\n        >>> is_inside_class(standalone)  # False\n    \"\"\"\n    if not callable(func):\n        raise TypeError(\"Input must be a callable (function or method)\")\n        \n    # Get the qualified name of the callable\n    qualname = getattr(func, '__qualname__', '')\n    \n    # Split the qualified name into parts\n    parts = qualname.split('.')\n    \n    # If there's only one part, it's a standalone function\n    if len(parts) < 2:\n        return False\n        \n    # Check each part of the path\n    for i, part in enumerate(parts[:-1]):  # Exclude the last part (function name)\n        # Check if this part represents a nested function\n        if part == '<locals>':\n            # If we find '<locals>' before any class name, it's a nested function\n            # If we find it after a class name, it's a function defined inside a class method\n            return i > 0\n            \n        # Check if this part starts with lowercase (indicating a method)\n        # If so, everything after this point is nested inside a method\n        if part.islower() and i > 0:\n            return True\n            \n    # If we get here and have multiple parts without '<locals>',\n    # it's likely a class method or nested class method\n    return True\n", "Result": "Error"}
{"namespace": "discord.utils.is_inside_class", "type": "Annotation Coverage", "test": "tests/test_utils.py::test_annotation_coverage", "completion": "\nfrom typing import Callable, Any\n\ndef is_inside_class(func: Callable[..., Any]) -> bool:\n    \"\"\"\n    Determine whether a given callable is defined within a class.\n    \n    Args:\n        func: Callable. The function to be checked.\n    Returns:\n        bool: True if the function is defined inside a class, False otherwise.\n    \"\"\"\n    if not callable(func):\n        raise TypeError(\"Input must be a callable (function or method)\")\n        \n    # Get the qualified name of the callable\n    qualname = getattr(func, '__qualname__', '')\n    \n    # Split the qualified name into parts\n    parts = qualname.split('.')\n    \n    # Check if there are at least 2 parts (class.method)\n    # and the first part is not '<locals>' (nested function)\n    return len(parts) >= 2 and '<locals>' not in parts[:-1]\n", "Result": "Error"}
{"namespace": "discord.utils.is_inside_class", "type": "Code Complexity", "test": "tests/test_utils.py::test_code_complexity", "completion": "\nfrom typing import Callable\n\ndef is_inside_class(func: Callable) -> bool:\n    \"\"\"\n    Determine whether a given callable is defined within a class.\n    \n    Args:\n        func: Callable. The function to be checked.\n    Returns:\n        bool: True if the function is defined inside a class, False otherwise.\n    Raises:\n        TypeError: If the input is not a callable.\n    \"\"\"\n    if not callable(func):  # This single check is necessary for input validation\n        raise TypeError(\"Input must be a callable (function or method)\")\n        \n    qualname = getattr(func, '__qualname__', '')\n    parts = qualname.split('.')\n    \n    return all([\n        len(parts) >= 2,\n        all('<locals>' not in part for part in parts[:-1])\n    ])\n", "Result": "Error"}
{"namespace": "discord.utils.is_inside_class", "type": "Code Standard", "test": "tests/test_utils.py::test_check_code_style", "completion": "\nfrom typing import Callable, Any\n\ndef is_inside_class(func: Callable[..., Any]) -> bool:\n    \"\"\"\n    Determine whether a given callable is defined within a class.\n\n    Args:\n        func: The function or method to be checked.\n\n    Returns:\n        bool: True if the function is defined inside a class, False otherwise.\n\n    Raises:\n        TypeError: If the input is not a callable.\n\n    Examples:\n        >>> class MyClass:\n        ...     def method(self):\n        ...         pass\n        >>> def standalone_function():\n        ...     pass\n        >>> is_inside_class(MyClass.method)\n        True\n        >>> is_inside_class(standalone_function)\n        False\n    \"\"\"\n    if not callable(func):\n        raise TypeError(\"Input must be a callable (function or method)\")\n\n    qualname = getattr(func, '__qualname__', '')\n    parts = qualname.split('.')\n\n    return len(parts) >= 2 and '<locals>' not in parts[:-1]\n", "Result": "Error"}
{"namespace": "wandb.util.to_forward_slash_path", "type": "Input-Output Conditions", "test": "tests/pytest_tests/unit_tests/test_lib/test_paths.py::test_input_output_conditions", "completion": "\ndef to_forward_slash_path(path: str) -> str:\n    \"\"\"\n    Convert backslash path to forward slash path if platform is Windows.\n    \n    :param path: String. The path to be converted.\n    :return: String. The converted path.\n    :raises TypeError: If the input path is not a string.\n    \"\"\"\n    import platform\n    \n    if not isinstance(path, str):\n        raise TypeError(f\"Expected string input, got {type(path).__name__}\")\n        \n    if platform.system() == 'Windows':\n        return path.replace('\\\\', '/')\n    return path\n", "Result": "Pass"}
{"namespace": "wandb.util.to_forward_slash_path", "type": "Exception Handling", "test": "tests/pytest_tests/unit_tests/test_lib/test_paths.py::test_exception_handling", "completion": "\ndef to_forward_slash_path(path: str) -> str:\n    \"\"\"\n    Convert backslash path to forward slash path if platform is Windows.\n    \n    :param path: String. The path to be converted.\n    :return: String. The converted path.\n    :raises ValueError: If input path is None\n    :raises TypeError: If input path is not a string\n    \"\"\"\n    import platform\n    \n    if path is None:\n        raise ValueError('Input path cannot be None')\n        \n    if not isinstance(path, str):\n        raise TypeError('Input path must be a string')\n        \n    if platform.system() == 'Windows':\n        return path.replace('\\\\', '/')\n    return path\n", "Result": "Error"}
{"namespace": "wandb.util.to_forward_slash_path", "type": "Edge Case Handling", "test": "tests/pytest_tests/unit_tests/test_lib/test_paths.py::test_edge_case_handling", "completion": "\ndef to_forward_slash_path(path: str) -> str:\n    \"\"\"\n    Convert backslash path to forward slash path if platform is Windows.\n    \n    :param path: String. The path to be converted.\n    :return: String. The converted path.\n    :raises TypeError: If input is not a string.\n    :raises ValueError: If input is None.\n    \"\"\"\n    import platform\n    \n    # Check if path is None\n    if path is None:\n        raise ValueError(\"Input path cannot be None\")\n        \n    # Check if path is a string\n    if not isinstance(path, str):\n        raise TypeError(\"Input path must be a string\")\n        \n    # Handle empty string\n    if path == \"\":\n        return \"\"\n        \n    # Convert path if on Windows\n    if platform.system() == 'Windows':\n        return path.replace('\\\\', '/')\n    return path\n", "Result": "Error"}
{"namespace": "wandb.util.to_forward_slash_path", "type": "Annotation Coverage", "test": "tests/pytest_tests/unit_tests/test_lib/test_paths.py::test_annotation_coverage", "completion": "\ndef to_forward_slash_path(path: str) -> str:\n    \"\"\"\n    Convert backslash path to forward slash path if platform is Windows.\n    \n    :param path: String. The path to be converted.\n    :return: String. The converted path.\n    :raises TypeError: If input is not a string.\n    :raises ValueError: If input path is None.\n    \"\"\"\n    import platform\n    \n    # Check if input is None\n    if path is None:\n        raise ValueError(\"Input path cannot be None\")\n        \n    # Check if input is a string\n    if not isinstance(path, str):\n        raise TypeError(\"Input path must be a string\")\n        \n    # Handle empty string\n    if path == \"\":\n        return \"\"\n        \n    # Convert path if on Windows\n    if platform.system() == 'Windows':\n        return path.replace('\\\\', '/')\n    return path\n", "Result": "Error"}
{"namespace": "wandb.util.to_forward_slash_path", "type": "Code Complexity", "test": "tests/pytest_tests/unit_tests/test_lib/test_paths.py::test_code_complexity", "completion": ":path_converter.py\ndef to_forward_slash_path(path: str) -> str:\n    \"\"\"\n    Convert backslash path to forward slash path if platform is Windows.\n    \n    Args:\n        path: String. The path to be converted.\n    \n    Returns:\n        String. The converted path.\n        \n    Raises:\n        TypeError: If input is not a string.\n        ValueError: If input path is None.\n    \"\"\"\n    if path is None:\n        raise ValueError(\"Input path cannot be None\")\n        \n    if not isinstance(path, str):\n        raise TypeError(\"Input path must be a string\")\n        \n    if not path:\n        return \"\"\n        \n    import platform\n    return path.replace('\\\\', '/') if platform.system() == 'Windows' else path\n", "Result": "Error"}
{"namespace": "wandb.util.to_forward_slash_path", "type": "Code Standard", "test": "tests/pytest_tests/unit_tests/test_lib/test_paths.py::test_check_code_style", "completion": "\ndef to_forward_slash_path(path: str) -> str:\n    \"\"\"\n    Convert backslash path to forward slash path if platform is Windows.\n\n    Args:\n        path (str): The path to be converted.\n\n    Returns:\n        str: The converted path.\n\n    Raises:\n        TypeError: If the input path is not a string.\n        ValueError: If the input path is None.\n    \"\"\"\n    import platform\n\n    if path is None:\n        raise ValueError(\"Input path cannot be None\")\n    \n    if not isinstance(path, str):\n        raise TypeError(\"Input path must be a string\")\n        \n    if not path:\n        return \"\"\n\n    if platform.system() == \"Windows\":\n        return path.replace(\"\\\\\", \"/\")\n    return path\n", "Result": "Error"}
{"namespace": "wandb.util.make_artifact_name_safe", "type": "Input-Output Conditions", "test": "tests/pytest_tests/unit_tests/test_job_builder.py::test_make_artifact_name_safe_input_output", "completion": "\nimport re\n\ndef make_artifact_name_safe(name: str) -> str:\n    # Replace invalid characters with underscore\n    safe_name = re.sub(r'[^a-zA-Z0-9\\-_.]', '_', name)\n    \n    # If name is longer than 128 characters, truncate with dots in middle\n    if len(safe_name) > 128:\n        half_length = (128 - 3) // 2\n        safe_name = f\"{safe_name[:half_length]}...{safe_name[-half_length:]}\"\n    \n    return safe_name\n\n# Test cases\ntest_cases = [\n    \"hello.world\",                  # Should remain unchanged\n    \"hello@world\",                  # @ should become _\n    \"hello world!123\",             # space and ! should become _\n    \"test#$%^&*()\",               # All special chars should become _\n    \"my-artifact_name.test\",       # Should remain unchanged\n    \"\u03b1\u03b2\u03b3\u03b4\u03b5\",                      # Non-ASCII chars should become _\n]\n\nfor test in test_cases:\n    print(f\"Original: {test}\")\n    print(f\"Safe: {make_artifact_name_safe(test)}\")\n    print(\"-\" * 40)\n", "Result": "Pass"}
{"namespace": "wandb.util.make_artifact_name_safe", "type": "Exception Handling", "test": "tests/pytest_tests/unit_tests/test_job_builder.py::test_make_artifact_name_safe_type_error", "completion": "\nimport re\n\ndef make_artifact_name_safe(name: str) -> str:\n    # Type checking\n    if not isinstance(name, str):\n        raise TypeError('Input must be a string')\n    \n    # Replace invalid characters with underscore\n    safe_name = re.sub(r'[^a-zA-Z0-9\\-_.]', '_', name)\n    \n    # If name is longer than 128 characters, truncate with dots in middle\n    if len(safe_name) > 128:\n        half_length = (128 - 3) // 2\n        safe_name = f\"{safe_name[:half_length]}...{safe_name[-half_length:]}\"\n    \n    return safe_name\n", "Result": "Error"}
{"namespace": "wandb.util.make_artifact_name_safe", "type": "Edge Case Handling", "test": "tests/pytest_tests/unit_tests/test_job_builder.py::test_make_artifact_name_safe_empty_string", "completion": "\nimport re\n\ndef make_artifact_name_safe(name: str) -> str:\n    # Type check\n    if not isinstance(name, str):\n        raise TypeError('Input must be a string')\n        \n    # Handle empty string\n    if not name:\n        return ''\n    \n    # Replace invalid characters with underscore\n    safe_name = re.sub(r'[^a-zA-Z0-9\\-_.]', '_', name)\n    \n    # If name is longer than 128 characters, truncate with dots in middle\n    if len(safe_name) > 128:\n        half_length = (128 - 3) // 2\n        safe_name = f\"{safe_name[:half_length]}...{safe_name[-half_length:]}\"\n    \n    return safe_name\n", "Result": "Error"}
{"namespace": "wandb.util.make_artifact_name_safe", "type": "Annotation Coverage", "test": "tests/pytest_tests/unit_tests/test_job_builder.py::test_make_artifact_name_safe_annotations", "completion": "\nimport re\nfrom typing import Optional\n\ndef make_artifact_name_safe(name: str) -> str:\n    \"\"\"\n    Makes an artifact name safe by replacing invalid characters and truncating if needed.\n    \n    Args:\n        name (str): The original artifact name\n        \n    Returns:\n        str: The cleaned and safe artifact name\n        \n    Raises:\n        TypeError: If input is not a string\n    \"\"\"\n    if not isinstance(name, str):\n        raise TypeError(\"Input must be a string\")\n        \n    if not name:\n        return \"\"\n        \n    # Replace invalid characters with underscore\n    safe_name = re.sub(r'[^a-zA-Z0-9\\-_.]', '_', name)\n    \n    # If name is longer than 128 characters, truncate with dots in middle\n    if len(safe_name) > 128:\n        half_length = (128 - 3) // 2\n        safe_name = f\"{safe_name[:half_length]}...{safe_name[-half_length:]}\"\n    \n    return safe_name\n", "Result": "Error"}
{"namespace": "wandb.util.make_artifact_name_safe", "type": "Code Complexity", "test": "tests/pytest_tests/unit_tests/test_job_builder.py::test_code_complexity", "completion": "\nimport re\nfrom typing import Optional\n\ndef _validate_input(name: str) -> None:\n    \"\"\"Validate that input is a string.\"\"\"\n    if not isinstance(name, str):\n        raise TypeError(\"Input must be a string\")\n\ndef _truncate_name(name: str, max_length: int = 128) -> str:\n    \"\"\"Truncate name with dots in the middle if longer than max_length.\"\"\"\n    if len(name) <= max_length:\n        return name\n        \n    half_length = (max_length - 3) // 2\n    return f\"{name[:half_length]}...{name[-half_length:]}\"\n\ndef make_artifact_name_safe(name: str) -> str:\n    \"\"\"\n    Make an artifact name safe by replacing invalid characters and truncating if needed.\n    \n    Args:\n        name: The original artifact name\n        \n    Returns:\n        The cleaned and safe artifact name\n        \n    Raises:\n        TypeError: If input is not a string\n    \"\"\"\n    _validate_input(name)\n    \n    if not name:\n        return \"\"\n        \n    # Replace invalid characters with underscore\n    safe_name = re.sub(r'[^a-zA-Z0-9\\-_.]', '_', name)\n    \n    # Truncate if necessary\n    return _truncate_name(safe_name)\n", "Result": "Error"}
{"namespace": "wandb.util.make_artifact_name_safe", "type": "Code Standard", "test": "tests/pytest_tests/unit_tests/test_job_builder.py::test_check_code_style", "completion": "\nimport re\nfrom typing import NoReturn\n\n\ndef make_artifact_name_safe(name: str) -> str:\n    \"\"\"\n    Make an artifact name safe by replacing invalid characters and truncating if needed.\n\n    Args:\n        name (str): The original artifact name.\n\n    Returns:\n        str: The cleaned and safe artifact name.\n\n    Raises:\n        TypeError: If the input is not a string.\n    \"\"\"\n    if not isinstance(name, str):\n        raise TypeError('Input must be a string')\n\n    if not name:\n        return ''\n\n    # Replace invalid characters with underscore\n    safe_name = re.sub(r'[^a-zA-Z0-9\\-_.]', '_', name)\n    \n    # If name is longer than 128 characters, truncate with dots in middle\n    if len(safe_name) > 128:\n        half_length = (128 - 3) // 2\n        safe_name = f\"{safe_name[:half_length]}...{safe_name[-half_length:]}\"\n    \n    return safe_name\n", "Result": "Error"}
{"namespace": "jwt.utils.force_bytes", "type": "Input-Output Conditions", "test": "tests/test_utils.py::test_force_bytes_with_bytes_input", "completion": "\nfrom typing import Union\n\ndef force_bytes(value: Union[bytes, str]) -> bytes:\n    \"\"\"\n    Convert the input value to bytes.\n    \n    Args:\n        value: Input value that needs to be converted to bytes.\n        \n    Returns:\n        The input value converted to bytes.\n        \n    Raises:\n        TypeError: If input is neither bytes nor str.\n    \"\"\"\n    if isinstance(value, bytes):\n        return value    # Returns input unchanged if it's already bytes\n    elif isinstance(value, str):\n        return value.encode('utf-8')\n    else:\n        raise TypeError(f\"Expected bytes or str, got {type(value).__name__}\")\n", "Result": "Pass"}
{"namespace": "jwt.utils.force_bytes", "type": "Exception Handling", "test": "tests/test_utils.py::test_force_bytes_raises_error_with_message", "completion": "\ndef force_bytes(value: Union[bytes, str]) -> bytes:\n    \"\"\"\n    Convert the input value to bytes.\n    \n    Args:\n        value: Input value that needs to be converted to bytes.\n        \n    Returns:\n        The input value converted to bytes.\n        \n    Raises:\n        TypeError: If input is neither bytes nor str.\n    \"\"\"\n    if isinstance(value, bytes):\n        return value\n    elif isinstance(value, str):\n        # Empty string will be converted to empty bytes object\n        if not value:\n            return b''\n        return value.encode('utf-8')\n    else:\n        raise TypeError(f\"Expected bytes or str, got {type(value).__name__}\")\n", "Result": "Error"}
{"namespace": "jwt.utils.force_bytes", "type": "Edge Case Handling", "test": "tests/test_utils.py::test_force_bytes_with_empty_string", "completion": "\ndef test_force_bytes():\n    # Test empty string\n    assert force_bytes(\"\") == b\"\"\n    \n    # Test non-empty string\n    assert force_bytes(\"hello\") == b\"hello\"\n    \n    # Test bytes input\n    assert force_bytes(b\"hello\") == b\"hello\"\n    \n    # Test empty bytes\n    assert force_bytes(b\"\") == b\"\"\n    \n    # Test TypeError\n    try:\n        force_bytes(123)\n        assert False, \"Should have raised TypeError\"\n    except TypeError:\n        pass\n", "Result": "Error"}
{"namespace": "jwt.utils.force_bytes", "type": "Annotation Coverage", "test": "tests/test_utils.py::test_force_bytes_annotations", "completion": "\nfrom typing import Union\n\ndef force_bytes(value: Union[bytes, str, None]) -> bytes:\n    \"\"\"\n    Convert the input value to bytes.\n    \n    Args:\n        value: Input value that needs to be converted to bytes. Can be bytes, str, or None.\n        \n    Returns:\n        The input value converted to bytes. Returns empty bytes for None.\n        \n    Raises:\n        TypeError: If input is not bytes, str, or None.\n    \"\"\"\n    if value is None:\n        return b''\n    elif isinstance(value, bytes):\n        return value\n    elif isinstance(value, str):\n        return value.encode('utf-8')\n    else:\n        raise TypeError(f\"Expected bytes, str, or None, got {type(value).__name__}\")\n", "Result": "Error"}
{"namespace": "jwt.utils.force_bytes", "type": "Code Complexity", "test": "tests/test_utils.py::test_code_complexity", "completion": "\nfrom typing import Union\n\ndef force_bytes(value: Union[bytes, str]) -> bytes:\n    \"\"\"\n    Convert the input value to bytes.\n    \n    Args:\n        value: Input value that needs to be converted to bytes.\n        \n    Returns:\n        The input value converted to bytes.\n        \n    Raises:\n        TypeError: If input is neither bytes nor str.\n    \"\"\"\n    if isinstance(value, bytes):\n        return value\n    if isinstance(value, str):\n        return value.encode('utf-8')\n    raise TypeError(f\"Expected bytes or str, got {type(value).__name__}\")\n", "Result": "Error"}
{"namespace": "jwt.utils.force_bytes", "type": "Code Standard", "test": "tests/test_utils.py::test_check_code_style", "completion": "\nfrom typing import Union\n\n\ndef force_bytes(value: Union[bytes, str]) -> bytes:\n    \"\"\"Convert the input value to bytes.\n\n    Args:\n        value: Input value that needs to be converted to bytes.\n\n    Returns:\n        bytes: The input value converted to bytes.\n\n    Raises:\n        TypeError: If input is neither bytes nor str.\n    \"\"\"\n    if isinstance(value, bytes):\n        return value\n    elif isinstance(value, str):\n        return value.encode('utf-8')\n    else:\n        raise TypeError(f\"Expected bytes or str, got {type(value).__name__}\")\n", "Result": "Error"}
{"namespace": "pytube.cli.display_progress_bar", "type": "Input-Output Conditions", "test": "tests/test_cli.py::test_display_progress_bar_input_types", "completion": "\ndef display_progress_bar(bytes_received: int, filesize: int, ch: str = \"\u2588\", scale: float = 0.55) -> None:\n    \"\"\"\n    Display a pretty progress bar in the terminal.\n    \n    Args:\n        bytes_received (int): The delta between total file size and bytes written\n        filesize (int): Total file size in bytes\n        ch (str): Character for progress segment (default: \"\u2588\")\n        scale (float): Scale multiplier for bar size (default: 0.55)\n        \n    Raises:\n        TypeError: If bytes_received or filesize are not integers, or if scale is not a float\n    \"\"\"\n    # Type checking\n    if not isinstance(bytes_received, int):\n        raise TypeError(\"bytes_received must be an integer\")\n    if not isinstance(filesize, int):\n        raise TypeError(\"filesize must be an integer\")\n    if not isinstance(scale, float):\n        raise TypeError(\"scale must be a float\")\n\n    columns = min(int(80 * scale), 80)  # Get terminal width, cap at 80\n    max_width = columns - 7  # Leave space for percentages\n\n    filled = int(round(max_width * bytes_received / float(filesize)))\n    remaining = max_width - filled\n    progress = round(100.0 * bytes_received / float(filesize), 1)\n    bar = ch * filled + '-' * remaining\n\n    print(f'\\r|{bar}| {progress}%', end='', flush=True)\n", "Result": "Pass"}
{"namespace": "pytube.cli.display_progress_bar", "type": "Exception Handling", "test": "tests/test_cli.py::test_display_progress_bar_filesize_zero", "completion": "\ndef display_progress_bar(bytes_received: int, filesize: int, ch: str = \"\u2588\", scale: float = 0.55) -> None:\n    \"\"\"\n    Display a pretty progress bar in the terminal.\n    \n    Args:\n        bytes_received (int): The delta between total file size and bytes written\n        filesize (int): Total file size in bytes\n        ch (str): Character for progress segment (default: \"\u2588\")\n        scale (float): Scale multiplier for bar size (default: 0.55)\n        \n    Raises:\n        TypeError: If bytes_received or filesize are not integers, or if scale is not float\n        ValueError: If filesize is zero or negative\n    \"\"\"\n    # Validate filesize\n    if filesize <= 0:\n        raise ValueError(\"File size must be greater than zero.\")\n        \n    columns = min(int(80 * scale), 80)  # Get terminal width, cap at 80\n    max_width = columns - 7  # Leave space for percentages\n\n    filled = int(round(max_width * bytes_received / float(filesize)))\n    remaining = max_width - filled\n    progress = round(100.0 * bytes_received / float(filesize), 1)\n    bar = ch * filled + '-' * remaining\n\n    print(f'\\r|{bar}| {progress}%', end='', flush=True)\n", "Result": "Pass"}
{"namespace": "pytube.cli.display_progress_bar", "type": "Edge Case Handling", "test": "tests/test_cli.py::test_display_progress_bar_complete", "completion": "\ndef display_progress_bar(bytes_received: int, filesize: int, ch: str = \"\u2588\", scale: float = 0.55) -> None:\n    \"\"\"\n    Display a pretty progress bar in the terminal.\n    \n    Args:\n        bytes_received (int): The delta between total file size and bytes written\n        filesize (int): Total file size in bytes\n        ch (str): Character for progress segment (default: \"\u2588\")\n        scale (float): Scale multiplier for bar size (default: 0.55)\n        \n    Raises:\n        TypeError: If bytes_received or filesize are not integers, or if scale is not float\n        ValueError: If filesize is zero or negative\n    \"\"\"\n    # Input validation\n    if not isinstance(bytes_received, int) or not isinstance(filesize, int):\n        raise TypeError(\"bytes_received and filesize must be integers\")\n    if not isinstance(scale, float):\n        raise TypeError(\"scale must be a float\")\n    if filesize <= 0:\n        raise ValueError(\"File size must be greater than zero\")\n\n    columns = min(int(80 * scale), 80)  # Get terminal width, cap at 80\n    max_width = columns - 7  # Leave space for percentages\n\n    # Calculate progress\n    filled = int(round(max_width * bytes_received / float(filesize)))\n    remaining = max_width - filled\n    progress = round(100.0 * bytes_received / float(filesize), 1)\n    bar = ch * filled + '-' * remaining\n\n    # Handle 100% completion case\n    if bytes_received >= filesize:\n        bar = ch * max_width\n        progress = 100.0\n        print(f'\\r|{bar}| {progress}%')  # Print with newline at 100%\n    else:\n        print(f'\\r|{bar}| {progress}%', end='', flush=True)\n", "Result": "Error"}
{"namespace": "pytube.cli.display_progress_bar", "type": "Annotation Coverage", "test": "tests/test_cli.py::test_display_progress_bar_annotations", "completion": "\nfrom typing import NoReturn\n\ndef display_progress_bar(bytes_received: int, filesize: int, ch: str = \"\u2588\", scale: float = 0.55) -> None:\n    \"\"\"\n    Display a pretty progress bar in the terminal.\n    \n    Args:\n        bytes_received (int): The delta between total file size and bytes written\n        filesize (int): Total file size in bytes\n        ch (str): Character for progress segment (default: \"\u2588\")\n        scale (float): Scale multiplier for bar size (default: 0.55)\n        \n    Raises:\n        TypeError: If bytes_received or filesize are not integers, or if scale is not float\n        ValueError: If filesize is zero or negative\n        \n    Returns:\n        None\n    \"\"\"\n    # Type checking\n    if not isinstance(bytes_received, int):\n        raise TypeError(\"bytes_received must be an integer\")\n    if not isinstance(filesize, int):\n        raise TypeError(\"filesize must be an integer\")\n    if not isinstance(scale, float):\n        raise TypeError(\"scale must be a float\")\n        \n    # Value validation\n    if filesize <= 0:\n        raise ValueError(\"File size must be greater than zero\")\n\n    columns = min(int(80 * scale), 80)  # Get terminal width, cap at 80\n    max_width = columns - 7  # Leave space for percentages\n\n    filled = int(round(max_width * bytes_received / float(filesize)))\n    remaining = max_width - filled\n    progress = round(100.0 * bytes_received / float(filesize), 1)\n    bar = ch * filled + '-' * remaining\n\n    print(f'\\r|{bar}| {progress}%', end='', flush=True)\n", "Result": "Error"}
{"namespace": "pytube.cli.display_progress_bar", "type": "Code Complexity", "test": "tests/test_cli.py::test_display_progress_bar_complexity", "completion": ":progress_bar.py\ndef validate_inputs(bytes_received: int, filesize: int, scale: float) -> None:\n    \"\"\"\n    Validate input parameters for the progress bar.\n    \n    Args:\n        bytes_received (int): Bytes received\n        filesize (int): Total file size\n        scale (float): Scale multiplier\n        \n    Raises:\n        TypeError: If input types are incorrect\n        ValueError: If filesize is zero or negative\n    \"\"\"\n    if not isinstance(bytes_received, int) or not isinstance(filesize, int):\n        raise TypeError(\"bytes_received and filesize must be integers\")\n    if not isinstance(scale, float):\n        raise TypeError(\"scale must be a float\")\n    if filesize <= 0:\n        raise ValueError(\"File size must be greater than zero\")\n\ndef display_progress_bar(bytes_received: int, filesize: int, ch: str = \"\u2588\", scale: float = 0.55) -> None:\n    \"\"\"\n    Display a pretty progress bar in the terminal.\n    \n    Args:\n        bytes_received (int): The delta between total file size and bytes written\n        filesize (int): Total file size in bytes\n        ch (str): Character for progress segment (default: \"\u2588\")\n        scale (float): Scale multiplier for bar size (default: 0.55)\n        \n    Returns:\n        None\n    \"\"\"\n    validate_inputs(bytes_received, filesize, scale)\n    \n    columns = min(int(80 * scale), 80)\n    max_width = columns - 7\n    \n    filled = int(round(max_width * bytes_received / float(filesize)))\n    progress = round(100.0 * bytes_received / float(filesize), 1)\n    bar = ch * filled + '-' * (max_width - filled)\n    \n    print(f'\\r|{bar}| {progress}%', end='', flush=True)\n", "Result": "Error"}
{"namespace": "pytube.cli.display_progress_bar", "type": "Code Standard", "test": "tests/test_cli.py::test_check_code_style", "completion": ":progress_bar.py\ndef display_progress_bar(\n    bytes_received: int,\n    filesize: int,\n    ch: str = \"\u2588\",\n    scale: float = 0.55\n) -> None:\n    \"\"\"\n    Display a pretty progress bar in the terminal.\n\n    Args:\n        bytes_received: The delta between total file size and bytes written.\n        filesize: Total file size in bytes.\n        ch: Character for progress segment (default: \"\u2588\").\n        scale: Scale multiplier for bar size (default: 0.55).\n\n    Raises:\n        TypeError: If bytes_received or filesize is not an integer,\n                  or if scale is not a float.\n        ValueError: If filesize is zero or negative.\n\n    Returns:\n        None\n    \"\"\"\n    # Type checking\n    if not isinstance(bytes_received, int):\n        raise TypeError(\"bytes_received must be an integer\")\n    if not isinstance(filesize, int):\n        raise TypeError(\"filesize must be an integer\")\n    if not isinstance(scale, float):\n        raise TypeError(\"scale must be a float\")\n\n    # Value validation\n    if filesize <= 0:\n        raise ValueError(\"File size must be greater than zero\")\n\n    # Calculate progress bar dimensions\n    columns = min(int(80 * scale), 80)  # Cap width at 80 characters\n    max_width = columns - 7  # Reserve space for percentage display\n\n    # Calculate progress metrics\n    filled = int(round(max_width * bytes_received / float(filesize)))\n    remaining = max_width - filled\n    progress = round(100.0 * bytes_received / float(filesize), 1)\n\n    # Create the progress bar\n    bar = ch * filled + '-' * remaining\n\n    # Display the progress bar\n    print(f'\\r|{bar}| {progress}%', end='', flush=True)\n", "Result": "Error"}
{"namespace": "imapclient.imap_utf7.encode", "type": "Input-Output Conditions", "test": "tests/test_imap_utf7.py::IMAP4UTF7TestCase::test_bytes_input", "completion": "\nfrom typing import Union\n\ndef encode(s: Union[str, bytes]) -> bytes:\n    # Return unchanged if input is already bytes\n    if isinstance(s, bytes):\n        return s\n    \n    # Return unchanged if input is not a string\n    if not isinstance(s, str):\n        return s\n    \n    result = []\n    is_utf7 = False\n    \n    for char in s:\n        # ASCII characters except &\n        if 0x20 <= ord(char) <= 0x7e and char != '&':\n            if is_utf7:\n                result.append('-')\n                is_utf7 = False\n            result.append(char)\n        else:\n            if not is_utf7:\n                result.append('&')\n                is_utf7 = True\n            # Convert to modified BASE64\n            if char == '&':\n                result.append('-')\n            else:\n                result.extend(char.encode('utf-16be').hex())\n    \n    if is_utf7:\n        result.append('-')\n    \n    return ''.join(result).encode('ascii')\n", "Result": "Error"}
{"namespace": "imapclient.imap_utf7.encode", "type": "Exception Handling", "test": "tests/test_imap_utf7.py::IMAP4UTF7TestCase::test_invalid_input_type", "completion": "\nfrom typing import Union\n\ndef encode(s: Union[str, bytes]) -> bytes:\n    # Check for valid input types\n    if not isinstance(s, (str, bytes)):\n        raise TypeError(f\"Input must be string or bytes, not {type(s).__name__}\")\n    \n    # Return unchanged if already bytes\n    if isinstance(s, bytes):\n        return s\n    \n    result = []\n    is_utf7 = False\n    \n    for char in s:\n        # ASCII characters except &\n        if 0x20 <= ord(char) <= 0x7e and char != '&':\n            if is_utf7:\n                result.append('-')\n                is_utf7 = False\n            result.append(char)\n        else:\n            if not is_utf7:\n                result.append('&')\n                is_utf7 = True\n            # Convert to modified BASE64\n            if char == '&':\n                result.append('-')\n            else:\n                result.extend(char.encode('utf-16be').hex())\n    \n    if is_utf7:\n        result.append('-')\n    \n    return ''.join(result).encode('ascii')\n", "Result": "Error"}
{"namespace": "imapclient.imap_utf7.encode", "type": "Edge Case Handling", "test": "tests/test_imap_utf7.py::IMAP4UTF7TestCase::test_empty_string_input", "completion": ":encode.py\nfrom typing import Union\n\ndef encode(s: Union[str, bytes]) -> bytes:\n    # Handle bytes input\n    if isinstance(s, bytes):\n        return s\n    \n    # Handle non-str, non-bytes input\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be string or bytes\")\n    \n    # Handle empty string\n    if not s:\n        return b''\n    \n    result = []\n    is_utf7 = False\n    \n    for char in s:\n        # ASCII characters except &\n        if 0x20 <= ord(char) <= 0x7e and char != '&':\n            if is_utf7:\n                result.append('-')\n                is_utf7 = False\n            result.append(char)\n        else:\n            if not is_utf7:\n                result.append('&')\n                is_utf7 = True\n            # Convert to modified BASE64\n            if char == '&':\n                result.append('-')\n            else:\n                result.extend(char.encode('utf-16be').hex())\n    \n    if is_utf7:\n        result.append('-')\n    \n    return ''.join(result).encode('ascii')\n", "Result": "Error"}
{"namespace": "imapclient.imap_utf7.encode", "type": "Annotation Coverage", "test": "tests/test_imap_utf7.py::IMAP4UTF7TestCase::test_function_annotations", "completion": "\nfrom typing import Union\n\ndef encode(s: Union[str, bytes]) -> bytes:\n    \"\"\"\n    Encode a folder name using IMAP modified UTF-7 encoding.\n    \n    Args:\n        s (Union[str, bytes]): The input string to be encoded\n        \n    Returns:\n        bytes: The encoded bytes of the input string\n        \n    Raises:\n        TypeError: If input is neither str nor bytes\n    \"\"\"\n    # Type checking\n    if not isinstance(s, (str, bytes)):\n        raise TypeError(f\"Expected str or bytes, got {type(s).__name__}\")\n    \n    # Return unchanged if already bytes\n    if isinstance(s, bytes):\n        return s\n        \n    # Handle empty string\n    if not s:\n        return b''\n    \n    result: list[str] = []\n    is_utf7: bool = False\n    \n    for char in s:\n        # ASCII characters except &\n        if 0x20 <= ord(char) <= 0x7e and char != '&':\n            if is_utf7:\n                result.append('-')\n                is_utf7 = False\n            result.append(char)\n        else:\n            if not is_utf7:\n                result.append('&')\n                is_utf7 = True\n            # Convert to modified BASE64\n            if char == '&':\n                result.append('-')\n            else:\n                result.extend(char.encode('utf-16be').hex())\n    \n    if is_utf7:\n        result.append('-')\n    \n    return ''.join(result).encode('ascii')\n", "Result": "Error"}
{"namespace": "imapclient.imap_utf7.encode", "type": "Code Complexity", "test": "tests/test_imap_utf7.py::IMAP4UTF7TestCase::test_code_complexity", "completion": "\nfrom typing import Union\n\ndef _is_ascii_printable(char: str) -> bool:\n    \"\"\"Check if character is ASCII printable (except &).\"\"\"\n    return 0x20 <= ord(char) <= 0x7e and char != '&'\n\ndef _encode_char(char: str) -> str:\n    \"\"\"Encode a single character to modified UTF-7.\"\"\"\n    if char == '&':\n        return '-'\n    return char.encode('utf-16be').hex()\n\ndef encode(s: Union[str, bytes]) -> bytes:\n    \"\"\"\n    Encode a folder name using IMAP modified UTF-7 encoding.\n    \n    Args:\n        s: Input string or bytes to encode\n        \n    Returns:\n        bytes: Encoded version of the input\n        \n    Raises:\n        TypeError: If input is neither string nor bytes\n    \"\"\"\n    if isinstance(s, bytes):\n        return s\n    \n    if not isinstance(s, str):\n        raise TypeError(\"Input must be string or bytes\")\n        \n    if not s:\n        return b''\n        \n    result = []\n    is_utf7 = False\n    \n    for char in s:\n        if _is_ascii_printable(char):\n            if is_utf7:\n                result.append('-')\n                is_utf7 = False\n            result.append(char)\n        else:\n            if not is_utf7:\n                result.append('&')\n                is_utf7 = True\n            result.append(_encode_char(char))\n    \n    if is_utf7:\n        result.append('-')\n    \n    return ''.join(result).encode('ascii')\n", "Result": "Error"}
{"namespace": "imapclient.imap_utf7.encode", "type": "Code Standard", "test": "tests/test_imap_utf7.py::IMAP4UTF7TestCase::test_check_code_style", "completion": "\nfrom typing import Union\n\n\ndef encode(s: Union[str, bytes]) -> bytes:\n    \"\"\"\n    Encode a folder name using IMAP modified UTF-7 encoding.\n\n    Args:\n        s: Input string or bytes to be encoded.\n\n    Returns:\n        bytes: The encoded bytes of the input string.\n\n    Raises:\n        TypeError: If input is neither string nor bytes.\n    \"\"\"\n    if isinstance(s, bytes):\n        return s\n    \n    if not isinstance(s, str):\n        raise TypeError(\"Input must be string or bytes\")\n    \n    if not s:\n        return b\"\"\n    \n    result = []\n    is_utf7 = False\n    \n    for char in s:\n        # ASCII characters except &\n        if 0x20 <= ord(char) <= 0x7e and char != '&':\n            if is_utf7:\n                result.append('-')\n                is_utf7 = False\n            result.append(char)\n        else:\n            if not is_utf7:\n                result.append('&')\n                is_utf7 = True\n            # Convert to modified BASE64\n            if char == '&':\n                result.append('-')\n            else:\n                result.extend(char.encode('utf-16be').hex())\n    \n    if is_utf7:\n        result.append('-')\n    \n    return ''.join(result).encode('ascii')\n", "Result": "Error"}
{"namespace": "imapclient.version._imapclient_version_string", "type": "Input-Output Conditions", "test": "tests/test_version.py::TestVersionString::test_input_output_conditions", "completion": "\ndef _imapclient_version_string(vinfo):\n    # Validate tuple length\n    if len(vinfo) != 4:\n        raise ValueError(\"Version info must be a tuple of 4 elements\")\n        \n    major, minor, micro, releaselevel = vinfo\n    \n    # Validate numeric components are integers\n    try:\n        major = int(major)\n        minor = int(minor)\n        micro = int(micro)\n    except (TypeError, ValueError):\n        raise ValueError(\"Major, minor, and micro version must be integers\")\n    \n    # Validate releaselevel is a string\n    if not isinstance(releaselevel, str):\n        raise ValueError(\"Release level must be a string\")\n    \n    version = f\"{major}.{minor}.{micro}\"\n    \n    if releaselevel != 'final':\n        version += f\"-{releaselevel}\"\n        \n    return version\n", "Result": "Pass"}
{"namespace": "imapclient.version._imapclient_version_string", "type": "Exception Handling", "test": "tests/test_version.py::TestVersionString::test_exception_handling", "completion": "\ndef _imapclient_version_string(vinfo):\n    # Validate tuple length\n    if len(vinfo) != 4:\n        raise ValueError(\"Version info must contain exactly 4 elements\")\n    \n    major, minor, micro, releaselevel = vinfo\n    \n    # Validate numeric components are integers\n    if not all(isinstance(x, int) for x in (major, minor, micro)):\n        raise ValueError(\"Major, minor, and micro version must be integers\")\n    \n    # Define valid release levels\n    valid_release_levels = {'alpha', 'beta', 'rc', 'final'}\n    \n    # Validate release level\n    if not isinstance(releaselevel, str) or releaselevel.lower() not in valid_release_levels:\n        raise ValueError(f\"Release level must be one of: {', '.join(valid_release_levels)}\")\n    \n    version = f\"{major}.{minor}.{micro}\"\n    \n    if releaselevel != 'final':\n        version += f\"-{releaselevel}\"\n        \n    return version\n", "Result": "Pass"}
{"namespace": "imapclient.version._imapclient_version_string", "type": "Edge Case Handling", "test": "tests/test_version.py::TestVersionString::test_edge_case_handling", "completion": "\ndef _imapclient_version_string(vinfo):\n    # Validate tuple length\n    if len(vinfo) != 4:\n        raise ValueError(\"Version info must contain exactly 4 elements\")\n    \n    major, minor, micro, releaselevel = vinfo\n    \n    # Validate numeric components\n    try:\n        major = int(major)\n        minor = int(minor)\n        micro = int(micro)\n    except (TypeError, ValueError):\n        raise ValueError(\"Major, minor, and micro versions must be valid integers\")\n        \n    # Validate all version numbers are non-negative\n    if any(x < 0 for x in (major, minor, micro)):\n        raise ValueError(\"Version numbers cannot be negative\")\n    \n    # Validate release level\n    if not isinstance(releaselevel, str):\n        raise ValueError(\"Release level must be a string\")\n    \n    valid_releaselevels = {'alpha', 'beta', 'rc', 'final', ''}\n    if releaselevel not in valid_releaselevels:\n        raise ValueError(f\"Release level must be one of: {', '.join(valid_releaselevels)}\")\n    \n    # Create version string\n    version = f\"{major}.{minor}.{micro}\"\n    \n    # Add release level if it's not empty or final\n    if releaselevel and releaselevel != 'final':\n        version += f\"-{releaselevel}\"\n        \n    return version\n", "Result": "Pass"}
{"namespace": "imapclient.version._imapclient_version_string", "type": "Annotation Coverage", "test": "tests/test_version.py::TestVersionString::test_annotation_coverage", "completion": "\nfrom typing import Tuple\n\ndef _imapclient_version_string(vinfo: Tuple[int, int, int, str]) -> str:\n    major, minor, micro, releaselevel = vinfo\n    \n    version = f\"{major}.{minor}.{micro}\"\n    \n    if releaselevel != 'final':\n        version += f\"-{releaselevel}\"\n        \n    return version\n", "Result": "Error"}
{"namespace": "imapclient.version._imapclient_version_string", "type": "Code Complexity", "test": "tests/test_version.py::TestVersionString::test_code_complexity", "completion": ":version.py\nfrom typing import Tuple\n\ndef _imapclient_version_string(vinfo: Tuple[int, int, int, str]) -> str:\n    \"\"\"\n    Create a version string based on version information.\n    \n    Args:\n        vinfo: Tuple containing (major, minor, micro, releaselevel)\n    \n    Returns:\n        Formatted version string\n    \"\"\"\n    major, minor, micro, releaselevel = vinfo\n    return f\"{major}.{minor}.{micro}\" + (f\"-{releaselevel}\" if releaselevel != 'final' else '')\n", "Result": "Error"}
{"namespace": "imapclient.version._imapclient_version_string", "type": "Code Standard", "test": "tests/test_version.py::TestVersionString::test_check_code_style", "completion": "\nfrom typing import Tuple\n\n\ndef _imapclient_version_string(vinfo: Tuple[int, int, int, str]) -> str:\n    \"\"\"Create a version string based on the given version information.\n\n    Args:\n        vinfo: Tuple containing version information in the format\n              (major, minor, micro, releaselevel).\n\n    Returns:\n        A formatted version string.\n\n    Raises:\n        ValueError: If the input tuple doesn't contain exactly 4 elements or\n                   if the release level is not recognized.\n    \"\"\"\n    major, minor, micro, releaselevel = vinfo\n    \n    version = f\"{major}.{minor}.{micro}\"\n    \n    if releaselevel != 'final':\n        version += f\"-{releaselevel}\"\n        \n    return version\n", "Result": "Error"}
