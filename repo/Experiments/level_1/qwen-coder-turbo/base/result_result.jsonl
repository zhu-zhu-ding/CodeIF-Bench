{"namespace": "benedict.utils.type_util.is_json_serializable", "completion": "\nimport json\n\ndef is_json_serializable(val):\n    \"\"\"\n    Check if the input value is JSON serializable.\n\n    :param val: Any. The input value to be checked for JSON serializability.\n    :return: Bool. True if the input value is JSON serializable, False otherwise.\n    \"\"\"\n    try:\n        json.dumps(val)\n        return True\n    except (TypeError, OverflowError):\n        return False\n\n# Example usage:\nprint(is_json_serializable(\"Hello, World!\"))  # True\nprint(is_json_serializable(123))              # True\nprint(is_json_serializable([1, 2, 3]))        # True\nprint(is_json_serializable({\"a\": 1}))         # True\nprint(is_json_serializable(None))             # True\nprint(is_json_serializable(set()))            # False\n", "Result": "Pass"}
{"namespace": "feedparser.urls.convert_to_idn", "completion": "\nimport idna\n\ndef convert_to_idn(url):\n    \"\"\"\n    Convert a URL to IDN notation.\n\n    Parameters:\n    :param url: String. The URL to be converted to IDN notation.\n    :return: String. The URL in IDN notation.\n    \"\"\"\n    from urllib.parse import urlparse\n\n    # Parse the URL\n    parsed_url = urlparse(url)\n\n    # Check if the hostname can be encoded in ASCII\n    try:\n        ascii_hostname = parsed_url.hostname.encode('ascii')\n    except UnicodeEncodeError:\n        # If encoding fails, it means the hostname contains non-ASCII characters\n        # Convert to IDN form using idna library\n        idn_hostname = idna.encode(parsed_url.hostname).decode('utf-8')\n        return parsed_url._replace(netloc=idn_hostname).geturl()\n    else:\n        # If the hostname can be encoded in ASCII, no conversion is needed\n        return url\n\n# Example usage:\nif __name__ == \"__main__\":\n    url_with_non_ascii = \"https://www.example.\u4e2d\u6587\"\n    url_with_ascii = \"https://www.example.com\"\n\n    print(convert_to_idn(url_with_non_ascii))  # Output: https://www.example.xn--fiqs8s\n    print(convert_to_idn(url_with_ascii))      # Output: https://www.example.com\n", "Result": "Error"}
{"namespace": "googleapiclient._helpers.parse_unique_urlencoded", "completion": "\nfrom urllib.parse import parse_qs\n\ndef parse_unique_urlencoded(content):\n    \"\"\"\n    Parses unique key-value parameters from URL-encoded content.\n    \n    :param content: str. URL-encoded key-value pairs.\n    :return: dict. The key-value pairs from the input content.\n    :raises ValueError: if one of the keys is repeated.\n    \"\"\"\n    # Parse the URL-encoded content into a dictionary\n    parsed_dict = parse_qs(content)\n    \n    # Check for repeated keys\n    for key in parsed_dict:\n        if len(parsed_dict[key]) > 1:\n            raise ValueError(f\"Key '{key}' is repeated.\")\n    \n    # Convert lists to single values (if needed)\n    result = {key: value[0] if len(value) == 1 else value for key, value in parsed_dict.items()}\n    \n    return result\n\n# Example usage:\ntry:\n    urlencoded_content = \"name=John&age=30&city=NewYork\"\n    parsed_params = parse_unique_urlencoded(urlencoded_content)\n    print(parsed_params)\nexcept ValueError as e:\n    print(e)\n\nurlencoded_content_repeated = \"name=John&name=Doe&age=30\"\ntry:\n    parsed_params = parse_unique_urlencoded(urlencoded_content_repeated)\n    print(parsed_params)\nexcept ValueError as e:\n    print(e)\n", "Result": "Pass"}
{"namespace": "jinja2.async_utils.auto_aiter", "completion": "\nimport asyncio\nfrom typing import Iterable, AsyncIterable, Union\n\ndef auto_aiter(iterable: Union[AsyncIterable, Iterable]):\n    if hasattr(iterable, '__aiter__'):\n        # Use the async iterator if available\n        return _async_iter(iterable)\n    else:\n        # Use the sync iterator if no async iterator is available\n        return _sync_iter(iterable)\n\nasync def _async_iter(aiterable: AsyncIterable):\n    async for item in aiterable:\n        yield item\n\ndef _sync_iter(iterable: Iterable):\n    for item in iterable:\n        yield item\n\n# Example usage:\nasync def main():\n    async_generator = (i**2 for i in range(5))\n    sync_iterator = iter(range(5))\n\n    async_iter_gen = auto_aiter(async_generator)\n    sync_iter_gen = auto_aiter(sync_iterator)\n\n    print(\"Async Iterator:\")\n    async for num in async_iter_gen:\n        print(num)\n\n    print(\"\\nSync Iterator:\")\n    for num in sync_iter_gen:\n        print(num)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n", "Result": "Error"}
{"namespace": "csvs_to_sqlite.utils.table_exists", "completion": "\nimport psycopg2\n\ndef table_exists(conn, table):\n    \"\"\"\n    Check if the specified table exists in the database.\n\n    :param conn: Connection object. The connection to the database.\n    :param table: String. The name of the table to check.\n    :return: Bool. True if the table exists, False otherwise.\n    \"\"\"\n    try:\n        # Create a cursor from the connection\n        cursor = conn.cursor()\n        \n        # SQL query to check if the table exists\n        query = f\"\"\"\n        SELECT EXISTS (\n            SELECT 1 FROM information_schema.tables \n            WHERE table_name = '{table}'\n        );\n        \"\"\"\n        \n        # Execute the query\n        cursor.execute(query)\n        \n        # Fetch the result\n        result = cursor.fetchone()\n        \n        # Close the cursor\n        cursor.close()\n        \n        # Return the result (True or False)\n        return result[0]\n    \n    except (Exception, psycopg2.DatabaseError) as error:\n        print(f\"Database Error: {error}\")\n        return False\n\n# Example usage:\n# Assuming you have already established a connection to your database\n# conn = psycopg2.connect(database=\"your_database\", user=\"your_user\", password=\"your_password\", host=\"your_host\", port=\"your_port\")\n# table_name = \"your_table_name\"\n# exists = table_exists(conn, table_name)\n# print(f\"Table '{table_name}' exists: {exists}\")\n", "Result": "Error"}
{"namespace": "sqlitedict.SqliteDict.get_tablenames", "completion": "\nimport sqlite3\n\ndef get_tablenames(filename):\n    \"\"\"\n    Retrieves the names of the tables in an SQLite database.\n\n    Parameters:\n    filename (str): The name of the SQLite database file.\n\n    Returns:\n    list: A list of strings representing the names of the tables in the SQLite database.\n    \n    Raises:\n    IOError: If the file does not exist.\n    \"\"\"\n    # Check if the file exists\n    try:\n        with open(filename, 'r'):\n            pass\n    except FileNotFoundError:\n        raise IOError(f'file {filename} does not exist')\n    \n    # Connect to the SQLite database\n    conn = sqlite3.connect(filename)\n    cursor = conn.cursor()\n    \n    # Retrieve the table names\n    cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table';\")\n    table_names = [row[0] for row in cursor.fetchall()]\n    \n    # Close the connection\n    conn.close()\n    \n    return table_names\n\n# Example usage:\n# print(get_tablenames('example.db'))\n", "Result": "Error"}
{"namespace": "psd_tools.utils.pack", "completion": "\nimport struct\n\ndef pack(fmt, *args):\n    \"\"\"\n    Packs the input arguments into a binary string according to the given format like \">{format}\".\n    \n    Parameters:\n    :param fmt: String. The format string that specifies the format of the returned string.\n    :param *args: Tuple. The input arguments to be packed.\n    :return: Binary string. The packed binary string.\n    \"\"\"\n    return struct.pack(fmt, *args)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Example format string: \">I\" means an unsigned integer (4 bytes)\n    packed_data = pack(\">I\", 123456789)\n    print(packed_data)  # Output will depend on the system's byte order\n\n    # Example format string: \">f\" means a single-precision float (4 bytes)\n    packed_data = pack(\">f\", 123.456)\n    print(packed_data)  # Output will depend on the system's byte order\n", "Result": "Error"}
{"namespace": "psd_tools.utils.unpack", "completion": "\nimport struct\n\ndef unpack(fmt, data):\n    \"\"\"\n    Unpacks the given data according to the specified format.\n\n    Parameters:\n    - fmt (str): The format string to be used for unpacking the data.\n    - data (bytes): The binary data to be unpacked.\n\n    Returns:\n    - tuple: A tuple containing the unpacked values.\n    \"\"\"\n    # Ensure the data is bytes\n    if not isinstance(data, bytes):\n        raise TypeError(\"Data must be of type bytes\")\n    \n    # Use struct.unpack to unpack the data according to the format\n    result = struct.unpack(fmt, data)\n    \n    return result\n\n# Example usage:\nif __name__ == \"__main__\":\n    fmt = \">I\"  # Example format: unsigned int\n    data = b'\\x00\\x00\\x00\\x10'  # Example data: 16 in big-endian format\n    \n    unpacked_values = unpack(fmt, data)\n    print(unpacked_values)  # Output: (16,)\n", "Result": "Error"}
{"namespace": "exodus_bundler.bundling.bytes_to_int", "completion": "\nimport struct\n\ndef bytes_to_int(bytes_data, byteorder=\"big\"):\n    \"\"\"\n    Convert a byte string into an integer.\n\n    Parameters:\n    :param bytes_data: Byte string. The byte string to be converted into an integer.\n    :param byteorder: String. The byte order to be used. It defaults to \"big\" if not specified.\n    :return: Integer. The converted integer value.\n    \"\"\"\n    # Ensure the byte order is either 'big' or 'little'\n    if byteorder not in [\"big\", \"little\"]:\n        raise ValueError(\"byteorder must be 'big' or 'little'\")\n    \n    # Calculate the format string based on the length of the byte string\n    format_string = f\"{len(bytes_data)}B\"\n    \n    # Unpack the byte string into integers\n    unpacked_values = struct.unpack(format_string, bytes_data)\n    \n    # Combine the unpacked values into a single integer\n    result = 0\n    for i, value in enumerate(unpacked_values):\n        result |= value << (i * 8)\n    \n    return result\n\n# Example usage:\nif __name__ == \"__main__\":\n    byte_str = b'\\x12\\x34\\x56\\x78'\n    print(bytes_to_int(byte_str))  # Output: 305419896\n    print(bytes_to_int(byte_str, byteorder=\"little\"))  # Output: 287484112\n", "Result": "Error"}
{"namespace": "exodus_bundler.templating.render_template", "completion": "\ndef render_template(string, context):\n    \"\"\"\n    Replaces placeholders in the input string with the corresponding values from the context dictionary.\n\n    Parameters:\n    string (str): The input string containing placeholders.\n    context (dict): The key-value pairs to replace the placeholders in the input string.\n\n    Returns:\n    str: The modified string after replacing the placeholders.\n    \"\"\"\n    # Iterate over each key-value pair in the context dictionary\n    for key, value in context.items():\n        # Replace all occurrences of the placeholder `{key}` with its corresponding value\n        string = string.replace(f'{{{key}}}', str(value))\n    \n    return string\n\n# Example usage:\ninput_string = \"Hello, {name}! Today's date is {date}.\"\ncontext_dict = {\n    \"name\": \"Alice\",\n    \"date\": \"2023-10-05\"\n}\n\nresult = render_template(input_string, context_dict)\nprint(result)  # Output: Hello, Alice! Today's date is 2023-10-05.\n", "Result": "Error"}
{"namespace": "trailscraper.iam.all_known_iam_permissions", "completion": "\nimport os\n\ndef all_known_iam_permissions():\n    \"\"\"\n    Returns a set of all known IAM actions.\n    \n    Parameters:\n        None\n        \n    Returns:\n        set: A set of lines from the 'known-iam-actions.txt' file.\n    \"\"\"\n    # Get the current script's directory\n    script_dir = os.path.dirname(os.path.abspath(__file__))\n    \n    # Construct the full path to the 'known-iam-actions.txt' file\n    file_path = os.path.join(script_dir, 'known-iam-actions.txt')\n    \n    # Initialize an empty set to store the lines\n    known_iam_actions = set()\n    \n    try:\n        # Open the file and read its contents\n        with open(file_path, 'r') as file:\n            for line in file:\n                # Add each line (stripped of leading/trailing whitespace) to the set\n                known_iam_actions.add(line.strip())\n    except FileNotFoundError:\n        print(f\"File not found: {file_path}\")\n    except Exception as e:\n        print(f\"An error occurred while reading the file: {e}\")\n    \n    return known_iam_actions\n\n# Example usage:\nif __name__ == \"__main__\":\n    permissions = all_known_iam_permissions()\n    print(permissions)\n", "Result": "Pass"}
{"namespace": "trailscraper.cloudtrail.parse_records", "completion": "\nclass Record:\n    def __init__(self, **kwargs):\n        self.__dict__.update(kwargs)\n\ndef _parse_record(json_record):\n    # Example parsing logic:\n    # Convert JSON record to a dictionary and create a Record object\n    try:\n        return Record(**json_record)\n    except Exception as e:\n        print(f\"Error parsing record: {e}\")\n        return None\n\ndef parse_records(json_records):\n    \"\"\"\n    Parses a list of JSON records into Record objects.\n\n    :param json_records: List. A list of JSON records to be parsed.\n    :return: List. A list of Record objects parsed from the JSON records.\n    \"\"\"\n    if not isinstance(json_records, list):\n        raise ValueError(\"json_records must be a list\")\n    \n    parsed_records = [_parse_record(record) for record in json_records]\n    filtered_records = [record for record in parsed_records if record is not None]\n    \n    return filtered_records\n\n# Example usage:\nif __name__ == \"__main__\":\n    json_data = [\n        {\"id\": 1, \"name\": \"Alice\", \"age\": 25},\n        {\"id\": 2, \"name\": \"Bob\", \"age\": 30},\n        {\"invalid_key\": \"value\"}  # This will cause an error during parsing\n    ]\n\n    records = parse_records(json_data)\n    for record in records:\n        print(record.id, record.name, record.age)\n", "Result": "Error"}
{"namespace": "discord.utils.get_slots", "completion": "\ndef get_slots(cls):\n    \"\"\"\n    Returns an iterator that yields the names of the slots in the class and its base classes.\n\n    :param cls: Type. The class for which the slots are to be retrieved.\n    :return: Iterator. An iterator that yields the names of the slots in the class and its base classes.\n    \"\"\"\n    while cls:\n        yield from getattr(cls, '__slots__', ())\n        cls = cls.__base__\n\n# Example usage:\nclass BaseClass:\n    __slots__ = ('slot1', 'slot2')\n\nclass DerivedClass(BaseClass):\n    __slots__ = ('slot3',)\n\nslots_iterator = get_slots(DerivedClass)\nfor slot in slots_iterator:\n    print(slot)\n", "Result": "Pass"}
{"namespace": "discord.utils.is_inside_class", "completion": "\ndef is_inside_class(func):\n    \"\"\"\n    Determine whether a given callable (function or method) is defined within a class.\n\n    :param func: Callable. The function to be checked.\n    :return: Bool. True if the function is defined inside a class, False otherwise.\n    \"\"\"\n    # Get the qualname of the callable\n    qualname = getattr(func, '__qualname__', None)\n    \n    # Check if the qualname exists and contains a '.'\n    return qualname is not None and '.' in qualname\n\n# Example usage:\nclass MyClass:\n    def my_method(self):\n        pass\n\ndef my_function():\n    pass\n\nprint(is_inside_class(MyClass.my_method))  # Output: True\nprint(is_inside_class(my_function))       # Output: False\n", "Result": "Error"}
{"namespace": "wandb.util.to_forward_slash_path", "completion": "\nimport os\n\ndef to_forward_slash_path(path):\n    \"\"\"\n    Convert the backslash path to a forward slash path if the platform is Windows.\n\n    :param path: String. The path to be converted.\n    :return: String. The converted path.\n    \"\"\"\n    if os.name == 'nt':  # Check if the platform is Windows\n        return path.replace('\\\\', '/')\n    else:\n        return path\n\n# Example usage:\nwindows_path = \"C:\\\\Users\\\\Username\\\\Documents\\\\file.txt\"\nforward_slash_path = to_forward_slash_path(windows_path)\nprint(forward_slash_path)  # Output: C:/Users/Username/Documents/file.txt\n", "Result": "Pass"}
{"namespace": "wandb.util.make_artifact_name_safe", "completion": "\nimport re\n\ndef make_artifact_name_safe(name: str) -> str:\n    # Replace any characters that are not alphanumeric, dashes, underscores, or dots with underscores\n    cleaned_name = re.sub(r'[^a-zA-Z0-9-.]', '_', name)\n    \n    # Truncate the name if it's longer than 128 characters by inserting dots in the middle\n    if len(cleaned_name) > 128:\n        half_length = (128 // 2) - 3  # Reserve space for dots at both ends\n        cleaned_name = cleaned_name[:half_length] + '...' + cleaned_name[-half_length:]\n    \n    return cleaned_name\n\n# Example usage:\nartifact_name = \"This-is-a!@#$%^&*()_+Artifact-Name With Spaces\"\nsafe_artifact_name = make_artifact_name_safe(artifact_name)\nprint(safe_artifact_name)  # Output: \"This_is_a__________Artifact_Name_With_Spaces\"\n", "Result": "Pass"}
{"namespace": "jwt.utils.force_bytes", "completion": "\nfrom typing import Union\n\ndef force_bytes(value: Union[bytes, str]) -> bytes:\n    \"\"\"\n    Converts the input value to bytes.\n\n    Parameters:\n    - value (Union[bytes, str]): The input value that needs to be converted to bytes.\n\n    Returns:\n    - bytes: The input value converted to bytes.\n    \n    Raises:\n    - TypeError: If the input value is neither a bytes nor a string.\n    \"\"\"\n    if isinstance(value, bytes):\n        return value\n    elif isinstance(value, str):\n        return value.encode('utf-8')\n    else:\n        raise TypeError(\"Expected a bytes or str object\")\n\n# Example usage:\nprint(force_bytes(b'hello'))  # Output: b'hello'\nprint(force_bytes('world'))  # Output: b'world'\ntry:\n    print(force_bytes(123))      # This should raise an exception\nexcept TypeError as e:\n    print(e)  # Expected output: Expected a bytes or str object\n", "Result": "Pass"}
{"namespace": "pytube.cli.display_progress_bar", "completion": "\ndef display_progress_bar(bytes_received, filesize, ch=\"\u2588\", scale=0.55):\n    \"\"\"\n    Display a simple, pretty progress bar in the terminal.\n    \n    Parameters:\n    - bytes_received: The delta between the total file size (bytes) and bytes already written to disk.\n    - filesize: The total file size of the media stream in bytes.\n    - ch: Character to use for presenting progress segment. Defaults to \"\u2588\".\n    - scale: Scale multiplier to reduce progress bar size. Defaults to 0.55.\n    \n    Returns:\n    None\n    \"\"\"\n    if filesize <= 0:\n        raise ValueError(\"Filesize must be greater than 0\")\n    \n    # Calculate the number of characters that fit into the scaled width\n    scaled_width = round(filesize * scale)\n    \n    # Calculate the current progress in terms of the scaled width\n    progress = min(round((bytes_received / filesize) * scaled_width), scaled_width)\n    \n    # Create the progress bar string\n    progress_bar = f\"{ch * progress}{' ' * (scaled_width - progress)}\"\n    \n    # Print the progress bar with carriage return to overwrite the previous line\n    print(f\"\\r[{progress_bar}] {int((bytes_received / filesize) * 100):2d}%\", end=\"\")\n    \n    # If the transfer is complete, move to the next line\n    if bytes_received >= filesize:\n        print()\n\n# Example usage:\n# Assume we want to track the download of a 10MB file (10 * 1024 * 1024 bytes)\nfilesize = 10 * 1024 * 1024\n\n# Simulate receiving data in chunks\nfor i in range(0, filesize + 1, 1024):\n    display_progress_bar(i, filesize)\n", "Result": "TimeOut"}
{"namespace": "imapclient.imap_utf7.encode", "completion": "\nimport imaplib\n\ndef encode(s):\n    if isinstance(s, str):\n        return imaplib.IMAP4.encode(s)\n    elif isinstance(s, bytes):\n        return s\n    else:\n        raise TypeError(\"Input must be a string or bytes\")\n\n# Example usage:\nfolder_name = \"MyFolder\"\nencoded_folder_name = encode(folder_name)\nprint(encoded_folder_name)  # Output will be the encoded bytes\n\nbytes_input = b\"MyBytesFolder\"\nunchanged_output = encode(bytes_input)\nprint(unchanged_output)  # Output will be the same bytes input\n", "Result": "Error"}
{"namespace": "imapclient.version._imapclient_version_string", "completion": "\ndef _imapclient_version_string(vinfo):\n    \"\"\"\n    Creates a version string based on the given version information.\n\n    :param vinfo: Tuple. A tuple containing version information in the format (major, minor, micro, releaselevel).\n    :return: String. The version string created based on the version information.\n    \"\"\"\n    major, minor, micro, releaselevel = vinfo\n    \n    # Constructing the version string\n    version_string = f\"{major}.{minor}.{micro}\"\n    \n    if releaselevel != 'final':\n        version_string += f\"{releaselevel[0]}{releaselevel[1]}\"\n    \n    return version_string\n\n# Example usage:\nvinfo = (2, 3, 4, 'alpha')\nprint(_imapclient_version_string(vinfo))  # Output: \"2.3.4a\"\n", "Result": "Error"}