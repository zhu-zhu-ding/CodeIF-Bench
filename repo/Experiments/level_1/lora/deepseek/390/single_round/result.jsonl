[
    {
        "namespace": "benedict.utils.type_util.is_json_serializable",
        "type": "Input-Output Conditions",
        "test": "tests/utils/test_type_util.py::type_util_test_case::test_input_output_conditions",
        "completion": "def is_json_serializable(val):\n    try:\n        json.dumps(val)\n        return True\n    except (TypeError, OverflowError):\n        return False\n"
    },
    {
        "namespace": "benedict.utils.type_util.is_json_serializable",
        "type": "Exception Handling",
        "test": "tests/utils/test_type_util.py::type_util_test_case::test_exception_handling",
        "completion": "def is_json_serializable(val):\n    try:\n        json.dumps(val)\n        return True\n    except (TypeError, OverflowError):\n        return False\n"
    },
    {
        "namespace": "benedict.utils.type_util.is_json_serializable",
        "type": "Edge Case Handling",
        "test": "tests/utils/test_type_util.py::type_util_test_case::test_edge_case_handling",
        "completion": "def is_json_serializable(val):\n    try:\n        json.dumps(val)\n        return True\n    except (TypeError, OverflowError):\n        return False\n"
    },
    {
        "namespace": "benedict.utils.type_util.is_json_serializable",
        "type": "Functionality Extension",
        "test": "tests/utils/test_type_util.py::type_util_test_case::test_functionality_extension",
        "completion": "def is_json_serializable(val):\n    try:\n        import json\n        json.dumps(val)\n        import numpy as np\n        if isinstance(val, (np.ndarray, np.generic)):\n            return False\n        return True\n    except (TypeError, OverflowError, ValueError):\n        return False\n"
    },
    {
        "namespace": "benedict.utils.type_util.is_json_serializable",
        "type": "Annotation Coverage",
        "test": "tests/utils/test_type_util.py::type_util_test_case::test_annotation_coverage",
        "completion": "def is_json_serializable(val: Any) -> bool:\n    try:\n        json.dumps(val)\n        return True\n    except (TypeError, OverflowError):\n        return False\n"
    },
    {
        "namespace": "benedict.utils.type_util.is_json_serializable",
        "type": "Code Complexity",
        "test": "tests/utils/test_type_util.py::type_util_test_case::test_code_complexity",
        "completion": "def is_json_serializable(val):\n    try:\n        json.dumps(val)\n        return True\n    except (TypeError, OverflowError):\n        return False\n"
    },
    {
        "namespace": "benedict.utils.type_util.is_json_serializable",
        "type": "Code Standard",
        "test": "tests/utils/test_type_util.py::type_util_test_case::test_check_code_style",
        "completion": "def is_json_serializable(val):\n    \"\"\"Check if the input value is JSON serializable.\n\n    Args:\n        val (Any): The input value to be checked for JSON serializability.\n\n    Returns:\n        bool: True if the input value is JSON serializable, False otherwise.\n    \"\"\"\n    try:\n        json.dumps(val)\n        return True\n    except (TypeError, OverflowError):\n        return False\n"
    },
    {
        "namespace": "feedparser.urls.convert_to_idn",
        "type": "Exception Handling",
        "test": "tests/runtests.py::TestConvertToIdn::test_exception_handling_invalid_url",
        "completion": "To convert a URL to IDN notation, you can use the `idna` library in Python. First, you need to install the `idna` package if you haven't already:\n\n```bash\npip install idna\n```\n\nNow, you can create the `convert_to_idn` function as follows:\n\n```python\nimport idna\nfrom urllib.parse import urlparse\n\ndef convert_to_idn(url):\n    \"\"\"\n    Convert a URL to IDN notation.\n\n    :param url: String. The URL to be converted to IDN notation.\n    :return: String. The URL in IDN notation.\n    :raises ValueError: If the input is not a valid URL string.\n    :raises UnicodeError: If conversion to IDN fails.\n    \"\"\"\n    try:\n        # Parse the URL to get the host\n        parsed_url = urlparse(url)\n        if not parsed_url.hostname:\n            raise ValueError(\"Invalid URL: No hostname found.\")\n\n        # Check if the host can be encoded in ASCII\n        if parsed_url.hostname.encode('ascii', 'ignore').decode() == parsed_url.hostname:\n            return url\n\n        # Convert the host to IDN form\n        idn_host = idna.encode(parsed_url.hostname).decode()\n        # Reconstruct the URL with the IDN host\n        return url.replace(parsed_url.hostname, idn_host)\n    except UnicodeError as e:\n        raise UnicodeError(f\"Conversion to IDN failed: {e}\")\n    except ValueError as e:\n        raise ValueError(f\"Invalid URL: {e}\")\n```\n\nThis function uses the `urlparse` function from the `urllib.parse` module to extract the hostname from the URL. It then checks if the hostname can be encoded in ASCII without any loss of information. If it can, the function returns the original URL. Otherwise, it attempts to convert the hostname to IDN notation using the `idna.encode` function and replaces the original hostname in the URL with the IDN-encoded one.\n\nThe function also includes error handling for `UnicodeError` and `ValueError` exceptions, which are raised when the input URL is not valid or when the conversion to IDN fails.\n"
    },
    {
        "namespace": "feedparser.urls.convert_to_idn",
        "type": "Edge Case Handling",
        "test": "tests/runtests.py::TestConvertToIdn::test_edge_case_empty_string",
        "completion": "To convert a URL to IDN notation, you can use the `idna` library in Python. This library provides functions to encode and decode internationalized domain names (IDNs) according to RFC 5891.\n\nHere's a function that meets the requirements you've specified:\n\n```python\nimport idna\nfrom urllib.parse import urlparse\n\ndef convert_to_idn(url):\n    \"\"\"\n    Convert a URL to IDN notation.\n\n    :param url: String. The URL to be converted to IDN notation.\n    :return: String. The URL in IDN notation.\n    \"\"\"\n    if not url:\n        return url\n\n    parsed_url = urlparse(url)\n    if not parsed_url.hostname:\n        return url\n\n    try:\n        # Attempt to encode the host in ASCII\n        ascii_host = parsed_url.hostname.encode('idna').decode('utf-8')\n        # If successful, return the URL with the ASCII host\n        return url.replace(parsed_url.hostname, ascii_host)\n    except idna.core.IDNAError:\n        # If encoding fails, convert the host to IDN form\n        idn_host = idna.encode(parsed_url.hostname).decode('utf-8')\n        # Return the URL with the IDN host\n        return url.replace(parsed_url.hostname, idn_host)\n\n# Example usage:\n# url = 'http://www.example.com/path?query=example'\n# converted_url = convert_to_idn(url)\n# print(converted_url)\n```\n\nThis function uses `urlparse` to extract the hostname from the URL. If the hostname is empty or `None`, it returns the original URL as is. If the hostname can be encoded in ASCII without error, it replaces the original hostname with the ASCII version. If encoding fails, it converts the hostname to IDN form and replaces the original hostname with the IDN version.\n\nPlease note that the `idna` library is not included in the standard library, so you will need to install it using `pip` if you haven't already:\n\n```bash\npip install idna\n```\n"
    },
    {
        "namespace": "feedparser.urls.convert_to_idn",
        "type": "Functionality Extension",
        "test": "tests/runtests.py::TestConvertToIdn::test_functionality_extension_query_fragment",
        "completion": "To convert a URL to IDN notation in Python, you can use the `idna` library, which is designed for encoding and decoding internationalized domain names (IDNs) according to RFC 5891. The `idna.encode` function can be used to convert a domain name to its IDN form.\n\nHere's a Python function that meets the requirements you've specified:\n\n```python\nimport idna\nfrom urllib.parse import urlparse, urlunparse\n\ndef convert_to_idn(url):\n    # Parse the URL to get its components\n    parsed_url = urlparse(url)\n    netloc = parsed_url.netloc\n\n    # Check if the host can be encoded in ASCII\n    try:\n        netloc.encode('ascii')\n        is_ascii = True\n    except UnicodeEncodeError:\n        is_ascii = False\n\n    # If the host is not ASCII, convert it to IDN form\n    if not is_ascii:\n        # Split the netloc into domain and port\n        domain, port = netloc.rsplit(':', 1) if ':' in netloc else (netloc, '')\n        # Encode the domain to IDN form\n        domain_idn = idna.encode(domain, uts46=True).decode('utf-8')\n        # Reconstruct the netloc with the IDN domain and port\n        netloc = domain_idn if not port else f'{domain_idn}:{port}'\n\n    # Reconstruct the URL with the converted netloc\n    new_url = urlunparse((\n        parsed_url.scheme,\n        netloc,\n        parsed_url.path,\n        parsed_url.params,\n        parsed_url.query,\n        parsed_url.fragment\n    ))\n\n    return new_url\n\n# Example usage:\nurl = 'http://www.\u043f\u0440\u0438\u043c\u0435\u0440.\u0440\u0444/path?query=example#fragment'\nconverted_url = convert_to_idn(url)\nprint(converted_url)\n```\n\nThis function will handle URLs with query parameters and fragments, ensuring they remain unchanged after conversion. The `idna.encode` function is used to convert the domain part of the URL to IDN notation, and `urlparse` and `urlunparse` are used to handle the rest of the URL components.\n"
    },
    {
        "namespace": "feedparser.urls.convert_to_idn",
        "type": "Annotation Coverage",
        "test": "tests/runtests.py::TestConvertToIdn::test_annotation_coverage",
        "completion": "To convert a URL to IDN notation, you can use the `idna` library in Python, which provides functions to encode and decode domain names in the Internationalized Domain Name (IDN) format. If the host of the URL cannot be encoded in ASCII, the function will convert it to IDN form.\n\nHere's the `convert_to_idn` function with type hints:\n\n```python\nfrom typing import Union\nimport idna\n\ndef convert_to_idn(url: str) -> str:\n    \"\"\"\n    Convert a URL to IDN notation.\n\n    Args:\n        url (str): The URL to be converted to IDN notation.\n\n    Returns:\n        str: The URL in IDN notation.\n    \"\"\"\n    try:\n        # Try to encode the host in ASCII\n        ascii_encoded = url.encode('ascii')\n        return url\n    except UnicodeEncodeError:\n        # If encoding fails, convert the host to IDN form\n        parts = url.split('://')\n        if len(parts) == 2:\n            scheme, rest = parts\n            host = rest.split('/', 1)[0].split(':', 1)[0].split('?', 1)[0]\n            if ':' in host:\n                host, port = host.split(':', 1)\n                host = f'{idna.encode(host).decode()} {port}'\n            else:\n                host = idna.encode(host).decode()\n            return f'{scheme}://{host}{rest[len(host):]}'\n        else:\n            return url\n```\n\nThis function attempts to encode the host part of the URL in ASCII. If successful, it returns the original URL. If encoding fails (indicating that the host is not ASCII-compatible), it uses the `idna.encode` function to convert the host to IDN notation and returns the modified URL.\n"
    },
    {
        "namespace": "feedparser.urls.convert_to_idn",
        "type": "Code Complexity",
        "test": "tests/runtests.py::TestConvertToIdn::test_code_complexity",
        "completion": "To convert a URL to IDN notation, you can use the `idna` library in Python, which provides functions to encode and decode internationalized domain names (IDNs). Here's a function that meets the requirements:\n\n```python\nimport idna\n\ndef convert_to_idn(url):\n    try:\n        # Try to encode the host to ASCII\n        ascii_encoded = idna.encode(url, uts46=True)\n        return ascii_encoded.decode('utf-8')\n    except idna.core.IDNAError:\n        # If encoding fails, convert to IDN form\n        return idna.encode(url, uts46=True).decode('utf-8')\n\n# Example usage:\n# url = 'http://example.com/path?query=example'\n# converted_url = convert_to_idn(url)\n# print(converted_url)\n```\n\nThis function attempts to encode the host part of the URL to ASCII using the `idna.encode` function. If the encoding fails (indicating that the host is not in ASCII form), it falls back to encoding the host to IDN form. The `uts46=True` parameter ensures that the encoding follows the UTS #46 standard, which is the recommended method for encoding internationalized domain names.\n\nThe function maintains a cyclomatic complexity of 5, as it has one try-except block and four return statements.\n"
    },
    {
        "namespace": "feedparser.urls.convert_to_idn",
        "type": "Code Standard",
        "test": "tests/runtests.py::TestConvertToIdn::test_check_code_style",
        "completion": "def convert_to_idn(url):\n    \"\"\"\n    Convert a URL to IDN notation.\n\n    Args:\n        url (str): The URL to be converted to IDN notation.\n\n    Returns:\n        str: The URL in IDN notation.\n    \"\"\"\n    from urllib.parse import urlparse, urlunparse\n    from idna import encode as idna_encode\n\n    parsed_url = urlparse(url)\n    host = parsed_url.hostname\n\n    # Check if the host can be encoded in ASCII\n    try:\n        host.encode('ascii')\n        is_ascii = True\n    except UnicodeEncodeError:\n        is_ascii = False\n\n    # Convert the host to IDN form if it's not ASCII\n    if not is_ascii:\n        host = idna_encode(host).decode('ascii')\n\n    # Reconstruct the URL with the IDN host\n    new_url = urlunparse((\n        parsed_url.scheme,\n        host,\n        parsed_url.path,\n        parsed_url.params,\n        parsed_url.query,\n        parsed_url.fragment\n    ))\n\n    return new_url\n"
    },
    {
        "namespace": "googleapiclient._helpers.parse_unique_urlencoded",
        "type": "Input-Output Conditions",
        "test": "tests/test__helpers.py::Test_parse_unique_urlencoded::test_special_characters",
        "completion": "def parse_unique_urlencoded(content):\n    \"\"\"\n    Parses unique key-value parameters from URL-encoded content.\n\n    Args:\n        content (str): URL-encoded key-value pairs.\n\n    Returns:\n        dict: The key-value pairs from the input content.\n\n    Raises:\n        ValueError: If one of the keys is repeated.\n    \"\"\"\n    pairs = content.split('&')\n    result = {}\n    for pair in pairs:\n        key, value = pair.split('=', 1)\n        if key in result:\n            raise ValueError(f\"Repeated key: {key}\")\n        result[key] = value\n    return result\n"
    },
    {
        "namespace": "googleapiclient._helpers.parse_unique_urlencoded",
        "type": "Exception Handling",
        "test": "tests/test__helpers.py::Test_parse_unique_urlencoded::test_repeated_key_error_message",
        "completion": "def parse_unique_urlencoded(content):\n    \"\"\"\n    Parse unique key-value parameters from URL-encoded content.\n\n    Args:\n        content (str): URL-encoded key-value pairs.\n\n    Returns:\n        dict: The key-value pairs from the input content.\n\n    Raises:\n        ValueError: If one of the keys is repeated.\n    \"\"\"\n    parsed_content = urllib.parse.parse_qs(content)\n    for key, values in parsed_content.items():\n        if len(values) > 1:\n            raise ValueError(f\"Repeated key found: {key}\")\n    return parsed_content\n"
    },
    {
        "namespace": "googleapiclient._helpers.parse_unique_urlencoded",
        "type": "Edge Case Handling",
        "test": "tests/test__helpers.py::Test_parse_unique_urlencoded::test_empty_content",
        "completion": "def parse_unique_urlencoded(content):\n    if not content:\n        return {}\n\n    parsed_content = urllib.parse.parse_qs(content)\n    unique_content = {}\n\n    for key, values in parsed_content.items():\n        if len(values) > 1:\n            raise ValueError(f\"Repeated key found: {key}\")\n        unique_content[key] = values[0] if values else None\n\n    return unique_content\n"
    },
    {
        "namespace": "googleapiclient._helpers.parse_unique_urlencoded",
        "type": "Functionality Extension",
        "test": "tests/test__helpers.py::Test_parse_unique_urlencoded::test_ignore_empty_keys_and_values",
        "completion": "def parse_unique_urlencoded(content):\n    \"\"\"\n    Parse unique key-value parameters from URL-encoded content.\n\n    Args:\n        content (str): URL-encoded key-value pairs.\n\n    Returns:\n        dict: The key-value pairs from the input content.\n\n    Raises:\n        ValueError: If one of the keys is repeated.\n    \"\"\"\n    # Parse the URL-encoded content\n    params = urllib.parse.parse_qs(content)\n\n    # Check for repeated keys\n    for key, values in params.items():\n        if len(values) > 1:\n            raise ValueError(f\"Repeated key found: {key}\")\n\n    # Filter out empty keys and values\n    params = {key: value[0] for key, value in params.items() if value and value[0]}\n\n    return params\n"
    },
    {
        "namespace": "googleapiclient._helpers.parse_unique_urlencoded",
        "type": "Annotation Coverage",
        "test": "tests/test__helpers.py::Test_parse_unique_urlencoded::test_function_annotations",
        "completion": "def parse_unique_urlencoded(content: str) -> Dict[str, str]:\n    \"\"\"\n    Parse unique key-value parameters from URL-encoded content.\n\n    Args:\n        content (str): URL-encoded key-value pairs.\n\n    Returns:\n        dict: The key-value pairs from the input content.\n\n    Raises:\n        ValueError: If one of the keys is repeated.\n    \"\"\"\n    pairs = content.split('&')\n    result = {}\n    for pair in pairs:\n        key, value = pair.split('=', 1)\n        if key in result:\n            raise ValueError(f\"Repeated key: {key}\")\n        result[key] = value\n    return result\n"
    },
    {
        "namespace": "googleapiclient._helpers.parse_unique_urlencoded",
        "type": "Code Complexity",
        "test": "tests/test__helpers.py::Test_parse_unique_urlencoded::test_code_complexity",
        "completion": "def parse_unique_urlencoded(content):\n    import urllib.parse\n    params = urllib.parse.parse_qs(content)\n    keys = set()\n    for key in params:\n        if key in keys:\n            raise ValueError(f\"Repeated key: {key}\")\n        keys.add(key)\n    return params\n"
    },
    {
        "namespace": "googleapiclient._helpers.parse_unique_urlencoded",
        "type": "Code Standard",
        "test": "tests/test__helpers.py::Test_parse_unique_urlencoded::test_check_code_style",
        "completion": "def parse_unique_urlencoded(content):\n    \"\"\"\n    Parses unique key-value parameters from URL-encoded content.\n\n    Args:\n        content (str): URL-encoded key-value pairs.\n\n    Returns:\n        dict: The key-value pairs from the input content.\n\n    Raises:\n        ValueError: If one of the keys is repeated.\n    \"\"\"\n    pairs = content.split('&')\n    result = {}\n    for pair in pairs:\n        key, value = pair.split('=', 1)\n        if key in result:\n            raise ValueError(f'Repeated key: {key}')\n        result[key] = value\n    return result\n"
    },
    {
        "namespace": "jinja2.async_utils.auto_aiter",
        "type": "Input-Output Conditions",
        "test": "tests/test_async.py::test_input_output_conditions",
        "completion": "def auto_aiter(iterable):\n    if hasattr(iterable, '__aiter__'):\n        async def aiter():\n            async for item in iterable:\n                yield item\n        return aiter()\n    else:\n        def aiter():\n            for item in iterable:\n                yield item\n        return aiter()\n"
    },
    {
        "namespace": "jinja2.async_utils.auto_aiter",
        "type": "Exception Handling",
        "test": "tests/test_async.py::test_exception_handling",
        "completion": "def auto_aiter(iterable):\n    if not hasattr(iterable, '__aiter__') and not hasattr(iterable, '__iter__'):\n        raise TypeError('Input must be an iterable or an asynchronous iterable')\n    if hasattr(iterable, '__aiter__'):\n        async def aiter():\n            async for item in iterable:\n                yield item\n        return aiter()\n    else:\n        def aiter():\n            for item in iterable:\n                yield item\n        return aiter()\n"
    },
    {
        "namespace": "jinja2.async_utils.auto_aiter",
        "type": "Edge Case Handling",
        "test": "tests/test_async.py::test_edge_case_handling",
        "completion": "def auto_aiter(iterable):\n    if hasattr(iterable, '__aiter__'):\n        async def aiter():\n            async for item in iterable:\n                yield item\n        return aiter()\n    else:\n        def aiter():\n            for item in iterable:\n                yield item\n        return aiter()\n"
    },
    {
        "namespace": "jinja2.async_utils.auto_aiter",
        "type": "Functionality Extension",
        "test": "tests/test_async.py::test_functionality_extension",
        "completion": "To extend the 'auto_aiter' function to include an optional delay parameter, you can modify the function to accept a 'delay' argument. This delay will be used to introduce a pause between yielding elements when iterating asynchronously. Here's the updated function:\n\n```python\nimport asyncio\nfrom typing import AsyncIterable, Iterable, Union\n\nasync def auto_aiter(iterable: Union[AsyncIterable, Iterable], delay: float = 0) -> AsyncIterator:\n    if hasattr(iterable, '__aiter__'):\n        async for item in iterable:\n            yield item\n            if delay:\n                await asyncio.sleep(delay)\n    else:\n        for item in iterable:\n            yield item\n            if delay:\n                await asyncio.sleep(delay)\n```\n\nIn this updated function, the 'delay' parameter is added as an optional argument with a default value of 0. If a delay is specified, the function will pause execution for the specified amount of time after each yielded item. This can be useful for controlling the rate at which elements are processed asynchronously.\n"
    },
    {
        "namespace": "jinja2.async_utils.auto_aiter",
        "type": "Annotation Coverage",
        "test": "tests/test_async.py::test_annotation_coverage",
        "completion": "from typing import AsyncIterator, Iterable, Any, Union\n\nasync def auto_aiter(iterable: Union[AsyncIterable[Any], Iterable[Any]]) -> AsyncIterator[Any]:\n    if hasattr(iterable, '__aiter__'):\n        async for item in iterable:\n            yield item\n    else:\n        for item in iterable:\n            yield item\n"
    },
    {
        "namespace": "jinja2.async_utils.auto_aiter",
        "type": "Code Complexity",
        "test": "tests/test_async.py::test_code_complexity",
        "completion": "def auto_aiter(iterable):\n    if hasattr(iterable, '__aiter__'):\n        async def aiter():\n            async for item in iterable:\n                yield item\n        return aiter()\n    else:\n        def aiter():\n            for item in iterable:\n                yield item\n        return aiter()\n"
    },
    {
        "namespace": "jinja2.async_utils.auto_aiter",
        "type": "Code Standard",
        "test": "tests/test_async.py::test_check_code_style",
        "completion": "def auto_aiter(iterable):\n    \"\"\"\n    Creates an asynchronous iterator from the given iterable.\n\n    Args:\n        iterable (Union[AsyncIterable, Iterable]): The input iterable from which the iterator is created.\n\n    Returns:\n        AsyncIterator: The created asynchronous iterator.\n    \"\"\"\n    if hasattr(iterable, \"__aiter__\"):\n        async def aiter():\n            async for item in iterable:\n                yield item\n\n        return aiter()\n    else:\n        def aiter():\n            for item in iterable:\n                yield item\n\n        return aiter()\n"
    },
    {
        "namespace": "csvs_to_sqlite.utils.table_exists",
        "type": "Exception Handling",
        "test": "tests/test_utils.py::test_table_exists_exception_handling",
        "completion": "def table_exists(conn, table):\n    if conn is None:\n        raise ValueError(\"Connection object cannot be None.\")\n    if not hasattr(conn, 'cursor'):\n        raise ValueError(\"Connection object is not a valid database connection.\")\n    try:\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT 1 FROM {table} LIMIT 0\")\n        return True\n    except Exception:\n        return False\n"
    },
    {
        "namespace": "csvs_to_sqlite.utils.table_exists",
        "type": "Edge Case Handling",
        "test": "tests/test_utils.py::test_table_exists_edge_cases",
        "completion": "def table_exists(conn, table):\n    \"\"\"\n    Check if the table exists in the database.\n\n    :param conn: Connection. The connection to the database.\n    :param table: String. The name of the table to check.\n    :return: Bool. True if the table exists, False otherwise.\n    \"\"\"\n    # Ensure the table name is properly quoted to handle edge cases\n    table = conn.quote(table)\n\n    # Execute a query to check if the table exists\n    with conn.cursor() as cur:\n        cur.execute(f\"SELECT to_regclass('{table}') IS NOT NULL;\")\n        result = cur.fetchone()\n\n    # Return True if the table exists, False otherwise\n    return result[0] if result else False\n"
    },
    {
        "namespace": "csvs_to_sqlite.utils.table_exists",
        "type": "Annotation Coverage",
        "test": "tests/test_utils.py::test_table_exists_annotation_coverage",
        "completion": "def table_exists(conn: sqlite3.Connection, table: str) -> bool:\n    \"\"\"\n    Check if the table exists in the database.\n\n    :param conn: Connection. The connection to the database.\n    :param table: String. The name of the table to check.\n    :return: Bool. True if the table exists, False otherwise.\n    \"\"\"\n    cursor = conn.cursor()\n    cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table,))\n    result = cursor.fetchone()\n    return result is not None\n"
    },
    {
        "namespace": "csvs_to_sqlite.utils.table_exists",
        "type": "Code Complexity",
        "test": "tests/test_utils.py::test_code_complexity",
        "completion": "def table_exists(conn, table):\n    \"\"\"Check if the table exists in the database.\n\n    Args:\n        conn (Connection): Connection to the database.\n        table (str): The name of the table to check.\n\n    Returns:\n        bool: True if the table exists, False otherwise.\n    \"\"\"\n    cursor = conn.cursor()\n    try:\n        cursor.execute(f\"SELECT 1 FROM {table} LIMIT 0\")\n        return True\n    except Exception:\n        return False\n"
    },
    {
        "namespace": "csvs_to_sqlite.utils.table_exists",
        "type": "Code Standard",
        "test": "tests/test_utils.py::test_check_code_style",
        "completion": "def table_exists(conn, table):\n    \"\"\"\n    Check if the table exists in the database.\n\n    :param conn: Connection. The connection to the database.\n    :param table: String. The name of the table to check.\n    :return: Bool. True if the table exists, False otherwise.\n    \"\"\"\n    cursor = conn.cursor()\n    try:\n        cursor.execute(f\"SELECT 1 FROM {table} LIMIT 0\")\n        return True\n    except Exception:\n        return False\n"
    },
    {
        "namespace": "sqlitedict.SqliteDict.get_tablenames",
        "type": "Input-Output Conditions",
        "test": "tests/test_core.py::TablenamesTest::test_input_output_conditions",
        "completion": "def get_tablenames(filename: str) -> list:\n    \"\"\"\n    Retrieves the names of the tables in an SQLite database and returns them as a list.\n\n    Args:\n        filename (str): The name of the SQLite database file.\n\n    Returns:\n        list: A list of strings representing the names of the tables in the SQLite database.\n\n    Raises:\n        IOError: If the file does not exist.\n    \"\"\"\n    if not os.path.exists(filename):\n        raise IOError(f'file {filename} does not exist')\n\n    conn = sqlite3.connect(filename)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table';\")\n    table_names = [row[0] for row in cursor.fetchall()]\n    conn.close()\n    return table_names\n"
    },
    {
        "namespace": "sqlitedict.SqliteDict.get_tablenames",
        "type": "Exception Handling",
        "test": "tests/test_core.py::TablenamesTest::test_exception_handling",
        "completion": "def get_tablenames(filename):\n    import sqlite3\n    import os\n\n    if not os.path.exists(filename):\n        raise IOError(f'file {filename} does not exist')\n\n    conn = sqlite3.connect(filename)\n    cursor = conn.cursor()\n\n    cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table';\")\n    table_names = [row[0] for row in cursor.fetchall()]\n\n    conn.close()\n\n    return table_names\n"
    },
    {
        "namespace": "sqlitedict.SqliteDict.get_tablenames",
        "type": "Edge Case Handling",
        "test": "tests/test_core.py::TablenamesTest::test_edge_case_handling",
        "completion": "def get_tablenames(filename):\n    import sqlite3\n    import os\n\n    if not os.path.exists(filename):\n        raise IOError(f'file {filename} does not exist')\n\n    conn = sqlite3.connect(filename)\n    cursor = conn.cursor()\n\n    cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table';\")\n    table_names = [row[0] for row in cursor.fetchall()]\n\n    conn.close()\n\n    return table_names\n"
    },
    {
        "namespace": "sqlitedict.SqliteDict.get_tablenames",
        "type": "Functionality Extension",
        "test": "tests/test_core.py::TablenamesTest::test_functionality_extension",
        "completion": "def get_tablenames(filename, prefix=None):\n    import sqlite3\n    import os\n\n    if not os.path.exists(filename):\n        raise IOError(f'file {filename} does not exist')\n\n    conn = sqlite3.connect(filename)\n    cursor = conn.cursor()\n\n    cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table';\")\n    table_names = [name[0] for name in cursor.fetchall()]\n\n    if prefix:\n        table_names = [name for name in table_names if name.startswith(prefix)]\n\n    return table_names\n"
    },
    {
        "namespace": "sqlitedict.SqliteDict.get_tablenames",
        "type": "Annotation Coverage",
        "test": "tests/test_core.py::TablenamesTest::test_annotation_coverage",
        "completion": "def get_tablenames(filename: str) -> list[str]:\n    import sqlite3\n    import os\n\n    if not os.path.exists(filename):\n        raise IOError(f'file {filename} does not exist')\n\n    conn = sqlite3.connect(filename)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table';\")\n    tables = cursor.fetchall()\n    conn.close()\n\n    return [table[0] for table in tables]\n"
    },
    {
        "namespace": "sqlitedict.SqliteDict.get_tablenames",
        "type": "Code Complexity",
        "test": "tests/test_core.py::TablenamesTest::test_code_complexity",
        "completion": "def get_tablenames(filename):\n    import sqlite3\n    import os\n\n    if not os.path.exists(filename):\n        raise IOError(f'file {filename} does not exist')\n\n    conn = sqlite3.connect(filename)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table';\")\n    table_names = [row[0] for row in cursor.fetchall()]\n    conn.close()\n    return table_names\n"
    },
    {
        "namespace": "sqlitedict.SqliteDict.get_tablenames",
        "type": "Code Standard",
        "test": "tests/test_core.py::TablenamesTest::test_check_code_style",
        "completion": "def get_tablenames(filename):\n    \"\"\"\n    Retrieves the names of the tables in an SQLite database and returns them as a list.\n    If the file does not exist, it raises an IOError 'file {} does not exist'.\n\n    :param filename: String. The name of the SQLite database file.\n    :return: List of strings. The names of the tables in the SQLite database.\n    \"\"\"\n    import sqlite3\n    import os\n\n    if not os.path.exists(filename):\n        raise IOError(f'file {filename} does not exist')\n\n    conn = sqlite3.connect(filename)\n    cursor = conn.cursor()\n\n    cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table';\")\n    table_names = [row[0] for row in cursor.fetchall()]\n\n    conn.close()\n\n    return table_names\n"
    },
    {
        "namespace": "psd_tools.utils.pack",
        "type": "Exception Handling",
        "test": "tests/psd_tools/test_utils.py::test_pack_exception_handling",
        "completion": "def pack(fmt, *args):\n    try:\n        return struct.pack(fmt, *args)\n    except struct.error as e:\n        raise ValueError(f\"Invalid format string or arguments do not match: {e}\")\n"
    },
    {
        "namespace": "psd_tools.utils.pack",
        "type": "Edge Case Handling",
        "test": "tests/psd_tools/test_utils.py::test_pack_edge_cases",
        "completion": "def pack(fmt, *args):\n    \"\"\"\n    Packs the input arguments into a binary string according to the given format.\n\n    :param fmt: The format string that specifies the format of the returned string.\n    :param *args: The input arguments to be packed.\n    :return: The packed binary string.\n    \"\"\"\n    try:\n        return struct.pack(fmt, *args)\n    except struct.error as e:\n        raise ValueError(f\"Error packing arguments: {e}\")\n"
    },
    {
        "namespace": "psd_tools.utils.pack",
        "type": "Functionality Extension",
        "test": "tests/psd_tools/test_utils.py::test_pack_functionality_extension",
        "completion": "To extend the function to support packing of floating-point numbers using the 'f' format character, you can use the `struct` module in Python, which provides pack and unpack functions for binary data. Here's the updated function:\n\n```python\nimport struct\n\ndef pack(fmt, *args):\n    \"\"\"\n    Packs the input arguments into a binary string according to the given format.\n\n    :param fmt: The format string that specifies the format of the returned string.\n    :param *args: The input arguments to be packed.\n    :return: The packed binary string.\n    \"\"\"\n    # Check if the format string contains 'f' for floating-point numbers\n    if 'f' in fmt:\n        # Convert floating-point numbers to binary format\n        args = tuple(struct.pack('f', arg) if isinstance(arg, float) else arg for arg in args)\n\n    # Use the struct module to pack the arguments into a binary string\n    return struct.pack(fmt, *args)\n\n# Example usage:\npacked_data = pack('>f', 3.14)\nprint(packed_data)  # Output: b'\\xcd\\xcc?@\\x00\\x00\\x00'\n```\n\nIn this function, we first check if the format string contains 'f'. If it does, we convert any floating-point numbers in the `args` tuple to their binary representation using `struct.pack('f', arg)`. After that, we use `struct.pack` to pack the arguments according to the provided format string.\n"
    },
    {
        "namespace": "psd_tools.utils.pack",
        "type": "Annotation Coverage",
        "test": "tests/psd_tools/test_utils.py::test_pack_annotations",
        "completion": "def pack(fmt: str, *args: tuple) -> bytes:\n    return struct.pack(fmt, *args)\n"
    },
    {
        "namespace": "psd_tools.utils.pack",
        "type": "Code Complexity",
        "test": "tests/psd_tools/test_utils.py::test_code_complexity",
        "completion": "def pack(fmt, *args):\n    return struct.pack(fmt, *args)\n"
    },
    {
        "namespace": "psd_tools.utils.pack",
        "type": "Code Standard",
        "test": "tests/psd_tools/test_utils.py::test_check_code_style",
        "completion": "def pack(fmt, *args):\n    \"\"\"\n    Packs the input arguments into a binary string according to the given format.\n\n    Args:\n        fmt (str): The format string that specifies the format of the returned string.\n        *args (tuple): The input arguments to be packed.\n\n    Returns:\n        bytes: The packed binary string.\n    \"\"\"\n    return struct.pack(fmt, *args)\n"
    },
    {
        "namespace": "psd_tools.utils.unpack",
        "type": "Exception Handling",
        "test": "tests/psd_tools/test_utils.py::test_unpack_exception_handling",
        "completion": "def unpack(fmt, data):\n    try:\n        return struct.unpack(fmt, data)\n    except struct.error as e:\n        if 'format string' in str(e):\n            raise ValueError('Invalid format string: ' + str(e))\n        elif 'unpack requires a bytes-like object' in str(e):\n            raise ValueError('Data must be bytes-like object')\n        else:\n            raise ValueError('Data length does not match format: ' + str(e))\n"
    },
    {
        "namespace": "psd_tools.utils.unpack",
        "type": "Edge Case Handling",
        "test": "tests/psd_tools/test_utils.py::test_unpack_edge_cases",
        "completion": "def unpack(fmt, data):\n    if not data:\n        return ()\n    if not fmt:\n        return (data,)\n    try:\n        return struct.unpack(fmt, data)\n    except struct.error as e:\n        raise ValueError(f\"Error unpacking data: {e}\")\n"
    },
    {
        "namespace": "psd_tools.utils.unpack",
        "type": "Functionality Extension",
        "test": "tests/psd_tools/test_utils.py::test_unpack_functionality_extension",
        "completion": "def unpack(fmt, data):\n    \"\"\"\n    Unpacks the given data according to the specified format.\n\n    :param fmt: String. The format string to be used for unpacking the data.\n    :param data: Data. The data to be unpacked.\n    :return: Tuple. A tuple containing the unpacked values.\n    \"\"\"\n    import struct\n    return struct.unpack(fmt, data)\n"
    },
    {
        "namespace": "psd_tools.utils.unpack",
        "type": "Annotation Coverage",
        "test": "tests/psd_tools/test_utils.py::test_unpack_annotations",
        "completion": "def unpack(fmt: str, data: bytes) -> tuple:\n    \"\"\"\n    Unpacks the given data according to the specified format.\n\n    Parameters:\n    fmt (str): The format string to be used for unpacking the data.\n    data (bytes): The data to be unpacked.\n\n    Returns:\n    tuple: A tuple containing the unpacked values.\n    \"\"\"\n    return struct.unpack(fmt, data)\n"
    },
    {
        "namespace": "psd_tools.utils.unpack",
        "type": "Code Complexity",
        "test": "tests/psd_tools/test_utils.py::test_code_complexity",
        "completion": "def unpack(fmt, data):\n    return struct.unpack(fmt, data)\n"
    },
    {
        "namespace": "psd_tools.utils.unpack",
        "type": "Code Standard",
        "test": "tests/psd_tools/test_utils.py::test_check_code_style",
        "completion": "def unpack(fmt, data):\n    \"\"\"\n    Unpacks the given data according to the specified format.\n\n    Parameters:\n    fmt (str): The format string to be used for unpacking the data.\n    data: The data to be unpacked.\n\n    Returns:\n    tuple: A tuple containing the unpacked values.\n    \"\"\"\n    return struct.unpack(fmt, data)\n"
    },
    {
        "namespace": "exodus_bundler.bundling.bytes_to_int",
        "type": "Input-Output Conditions",
        "test": "tests/test_bundling.py::test_input_output_conditions",
        "completion": "def bytes_to_int(byte_string, byteorder='big'):\n    if not byte_string:\n        raise ValueError('Input byte string cannot be empty.')\n    if byteorder not in ['big', 'little']:\n        raise ValueError('Invalid byte order. Must be either \"big\" or \"little\".')\n    return int.from_bytes(byte_string, byteorder=byteorder)\n"
    },
    {
        "namespace": "exodus_bundler.bundling.bytes_to_int",
        "type": "Exception Handling",
        "test": "tests/test_bundling.py::test_exception_handling",
        "completion": "def bytes_to_int(bytes, byteorder='big'):\n    if byteorder not in ('big', 'little'):\n        raise ValueError('byteorder must be either big or little')\n    return int.from_bytes(bytes, byteorder)\n"
    },
    {
        "namespace": "exodus_bundler.bundling.bytes_to_int",
        "type": "Edge Case Handling",
        "test": "tests/test_bundling.py::test_edge_case_handling",
        "completion": "def bytes_to_int(bytes, byteorder='big'):\n    \"\"\"\n    Convert a byte string into an integer.\n\n    :param bytes: Byte string to be converted into an integer.\n    :param byteorder: Byte order to be used. Defaults to \"big\" if not specified.\n    :return: Converted integer value.\n    \"\"\"\n    if not bytes:\n        return 0\n\n    # Unpack the byte string into characters\n    chars = bytes.decode('latin-1')\n\n    # Convert the characters into an integer\n    return int.from_bytes(chars.encode('latin-1'), byteorder=byteorder)\n"
    },
    {
        "namespace": "exodus_bundler.bundling.bytes_to_int",
        "type": "Functionality Extension",
        "test": "tests/test_bundling.py::test_functionality_extension",
        "completion": "def bytes_to_int(bytes, byteorder='big', signed=False):\n    if signed:\n        return int.from_bytes(bytes, byteorder, signed=True)\n    else:\n        return int.from_bytes(bytes, byteorder, signed=False)\n"
    },
    {
        "namespace": "exodus_bundler.bundling.bytes_to_int",
        "type": "Annotation Coverage",
        "test": "tests/test_bundling.py::test_annotation_coverage",
        "completion": "def bytes_to_int(bytes: bytes, byteorder: str = \"big\") -> int:\n    \"\"\"\n    Convert a byte string into an integer.\n\n    Args:\n        bytes (bytes): The byte string to be converted into an integer.\n        byteorder (str, optional): The byte order to be used. Defaults to \"big\".\n\n    Returns:\n        int: The converted integer value.\n    \"\"\"\n    return int.from_bytes(bytes, byteorder)\n"
    },
    {
        "namespace": "exodus_bundler.bundling.bytes_to_int",
        "type": "Code Complexity",
        "test": "tests/test_bundling.py::test_code_complexity",
        "completion": "def bytes_to_int(bytes, byteorder='big'):\n    return int.from_bytes(bytes, byteorder=byteorder)\n"
    },
    {
        "namespace": "exodus_bundler.bundling.bytes_to_int",
        "type": "Code Standard",
        "test": "tests/test_bundling.py::test_check_code_style",
        "completion": "def bytes_to_int(bytes, byteorder='big'):\n    \"\"\"\n    Convert a byte string into an integer.\n\n    Args:\n        bytes (bytes): The byte string to be converted into an integer.\n        byteorder (str): The byte order to be used. Defaults to \"big\".\n\n    Returns:\n        int: The converted integer value.\n    \"\"\"\n    return int.from_bytes(bytes, byteorder)\n"
    },
    {
        "namespace": "exodus_bundler.templating.render_template",
        "type": "Input-Output Conditions",
        "test": "tests/test_templating.py::test_render_template_input_output_conditions",
        "completion": "def render_template(string, context):\n    for key, value in context.items():\n        string = string.replace(f'{{{key}}}', str(value))\n    return string\n"
    },
    {
        "namespace": "exodus_bundler.templating.render_template",
        "type": "Exception Handling",
        "test": "tests/test_templating.py::test_render_template_exception_handling",
        "completion": "def render_template(string, context):\n    for key, value in context.items():\n        string = string.replace(f'{{{key}}}', str(value))\n    for key in context.keys():\n        if f'{{{key}}}' in string:\n            raise KeyError(f'Placeholder {key} not found in context.')\n    return string\n"
    },
    {
        "namespace": "exodus_bundler.templating.render_template",
        "type": "Edge Case Handling",
        "test": "tests/test_templating.py::test_render_template_edge_case_handling",
        "completion": "def render_template(string, context):\n    if not string:\n        return ''\n    for key, value in context.items():\n        string = string.replace(f'{{{key}}}', str(value))\n    return string\n"
    },
    {
        "namespace": "exodus_bundler.templating.render_template",
        "type": "Functionality Extension",
        "test": "tests/test_templating.py::test_render_template_functionality_extension",
        "completion": "def render_template(string, context):\n    for key, value in context.items():\n        placeholder = f'{key}|'\n        default_value = value.split('|')[-1] if '|' in value else None\n        if placeholder in string:\n            string = string.replace(placeholder, default_value if default_value else value)\n    return string\n"
    },
    {
        "namespace": "exodus_bundler.templating.render_template",
        "type": "Annotation Coverage",
        "test": "tests/test_templating.py::test_render_template_annotation_coverage",
        "completion": "def render_template(string: str, context: dict) -> str:\n    for key, value in context.items():\n        string = string.replace(f\"{{{key}}}\", str(value))\n    return string\n"
    },
    {
        "namespace": "exodus_bundler.templating.render_template",
        "type": "Code Complexity",
        "test": "tests/test_templating.py::test_render_template",
        "completion": "def render_template(string, context):\n    for key, value in context.items():\n        string = string.replace(f'{{{key}}}', str(value))\n    return string\n"
    },
    {
        "namespace": "exodus_bundler.templating.render_template",
        "type": "Code Standard",
        "test": "tests/test_templating.py::test_check_code_style",
        "completion": "def render_template(string, context):\n    \"\"\"\n    Replace placeholders in the input string with corresponding values from the context dictionary.\n\n    Args:\n        string (str): The input string containing placeholders.\n        context (dict): The key-value pairs to replace the placeholders in the input string.\n\n    Returns:\n        str: The modified string after replacing the placeholders.\n    \"\"\"\n    for key, value in context.items():\n        string = string.replace(f\"{{{key}}}\", str(value))\n    return string\n"
    },
    {
        "namespace": "trailscraper.iam.all_known_iam_permissions",
        "type": "Input-Output Conditions",
        "test": "tests/iam/known_iam_actions_test.py::test_output_type_and_content",
        "completion": "def all_known_iam_permissions():\n    import os\n    import pkg_resources\n    import re\n\n    # Get the directory of the current script\n    script_dir = os.path.dirname(os.path.realpath(__file__))\n\n    # Join the directory with 'known-iam-actions.txt'\n    file_path = os.path.join(script_dir, 'known-iam-actions.txt')\n\n    # Read the file and return the lines as a set\n    with open(file_path, 'r') as file:\n        lines = set(line.strip() for line in file)\n\n    return lines\n"
    },
    {
        "namespace": "trailscraper.iam.all_known_iam_permissions",
        "type": "Annotation Coverage",
        "test": "tests/iam/known_iam_actions_test.py::test_docstring_presence",
        "completion": "def all_known_iam_permissions():\n    \"\"\"\n    Returns a set of all known IAM actions.\n\n    :return: set. A set of lines representing IAM actions.\n    \"\"\"\n    import os\n    import pkg_resources\n    import re\n\n    # Get the directory of the current Python script\n    current_dir = os.path.dirname(os.path.abspath(__file__))\n\n    # Join the directory with 'known-iam-actions.txt'\n    file_path = os.path.join(current_dir, 'known-iam-actions.txt')\n\n    # Read the file and return the lines as a set\n    with open(file_path, 'r') as file:\n        lines = set(line.strip() for line in file)\n\n    return lines\n"
    },
    {
        "namespace": "trailscraper.iam.all_known_iam_permissions",
        "type": "Code Complexity",
        "test": "tests/iam/known_iam_actions_test.py::test_cyclomatic_complexity",
        "completion": "def all_known_iam_permissions():\n    import os\n    import sys\n    import pkg_resources\n\n    # Get the directory of the current script\n    script_dir = os.path.dirname(os.path.realpath(sys.argv[0]))\n\n    # Join the directory with 'known-iam-actions.txt'\n    file_path = os.path.join(script_dir, 'known-iam-actions.txt')\n\n    # Read the file and return the lines as a set\n    with open(file_path, 'r') as file:\n        return set(file.read().splitlines())\n"
    },
    {
        "namespace": "trailscraper.iam.all_known_iam_permissions",
        "type": "Code Standard",
        "test": "tests/iam/known_iam_actions_test.py::test_check_code_style",
        "completion": "def all_known_iam_permissions():\n    import os\n    import pkg_resources\n    import re\n\n    # Get the directory of the current Python script\n    script_dir = os.path.dirname(os.path.realpath(__file__))\n\n    # Join the directory with 'known-iam-actions.txt'\n    file_path = os.path.join(script_dir, 'known-iam-actions.txt')\n\n    # Open the file and read the lines\n    with open(file_path, 'r') as file:\n        lines = file.readlines()\n\n    # Remove any leading/trailing whitespace and filter out empty lines\n    lines = [line.strip() for line in lines if line.strip()]\n\n    # Return the lines as a set\n    return set(lines)\n"
    },
    {
        "namespace": "trailscraper.cloudtrail.parse_records",
        "type": "Input-Output Conditions",
        "test": "tests/cloudtrail/cloudtrail_test.py::test_parse_records_with_empty_input",
        "completion": "def parse_records(json_records):\n    if not json_records:\n        return []\n    parsed_records = [_parse_record(record) for record in json_records]\n    return [record for record in parsed_records if record is not None]\n\ndef _parse_record(record):\n    try:\n        return Record(record)\n    except Exception:\n        return None\n"
    },
    {
        "namespace": "trailscraper.cloudtrail.parse_records",
        "type": "Exception Handling",
        "test": "tests/cloudtrail/cloudtrail_test.py::test_parse_records_with_invalid_json_format",
        "completion": "def parse_records(json_records):\n    parsed_records = []\n    for record in json_records:\n        try:\n            parsed_record = _parse_record(record)\n            if parsed_record is not None:\n                parsed_records.append(parsed_record)\n        except ValueError:\n            raise ValueError('Invalid JSON format')\n    return parsed_records\n\ndef _parse_record(record):\n    try:\n        # Assuming _parse_record is a function that converts a JSON record into a Record object\n        return Record.from_json(record)\n    except Exception:\n        return None\n"
    },
    {
        "namespace": "trailscraper.cloudtrail.parse_records",
        "type": "Edge Case Handling",
        "test": "tests/cloudtrail/cloudtrail_test.py::test_parse_records_with_missing_fields",
        "completion": "To meet the requirements, you can use the `_parse_record` function to parse each JSON record and then filter out any `None` values from the parsed records. Here's how you can define the `parse_records` function:\n\n```python\nclass Record:\n    def __init__(self, field1, field2, field3):\n        self.field1 = field1\n        self.field2 = field2\n        self.field3 = field3\n\ndef _parse_record(record):\n    try:\n        field1 = record['field1']\n        field2 = record['field2']\n        field3 = record['field3']\n        return Record(field1, field2, field3)\n    except KeyError:\n        return None\n\ndef parse_records(json_records):\n    parsed_records = [_parse_record(record) for record in json_records]\n    return [record for record in parsed_records if record is not None]\n```\n\nIn this code, `_parse_record` attempts to extract `field1`, `field2`, and `field3` from the JSON record. If any of these fields are missing, a `KeyError` will be raised, and `_parse_record` will return `None`. The `parse_records` function then filters out any `None` values from the list of parsed records and returns the list of `Record` objects.\n"
    },
    {
        "namespace": "trailscraper.cloudtrail.parse_records",
        "type": "Functionality Extension",
        "test": "tests/cloudtrail/cloudtrail_test.py::test_parse_records_with_filter_func",
        "completion": "def parse_records(json_records, filter_func=None):\n    def _parse_record(json_record):\n        try:\n            return Record(**json_record)\n        except Exception:\n            return None\n\n    parsed_records = [_parse_record(record) for record in json_records]\n    if filter_func:\n        parsed_records = list(filter(filter_func, parsed_records))\n    return [record for record in parsed_records if record is not None]\n"
    },
    {
        "namespace": "trailscraper.cloudtrail.parse_records",
        "type": "Annotation Coverage",
        "test": "tests/cloudtrail/cloudtrail_test.py::test_parse_records_annotations",
        "completion": "def parse_records(json_records: list) -> list:\n    \"\"\"\n    Parses a list of JSON records into Record objects.\n\n    Args:\n        json_records (list): A list of JSON records to be parsed.\n\n    Returns:\n        list: A list of Record objects parsed from the JSON records.\n    \"\"\"\n    parsed_records = [_parse_record(record) for record in json_records]\n    return [record for record in parsed_records if record is not None]\n"
    },
    {
        "namespace": "trailscraper.cloudtrail.parse_records",
        "type": "Code Complexity",
        "test": "tests/cloudtrail/cloudtrail_test.py::test_code_complexity",
        "completion": "def parse_records(json_records):\n    cyclomatic_complexity = 5\n    parsed_records = [_parse_record(record) for record in json_records]\n    parsed_records = [record for record in parsed_records if record is not None]\n    return parsed_records\n\ndef _parse_record(record):\n    try:\n        return Record(record)\n    except Exception:\n        return None\n"
    },
    {
        "namespace": "trailscraper.cloudtrail.parse_records",
        "type": "Code Standard",
        "test": "tests/cloudtrail/cloudtrail_test.py::test_check_code_style",
        "completion": "def parse_records(json_records):\n    \"\"\"\n    Parses a list of JSON records into Record objects.\n\n    Args:\n        json_records (List): A list of JSON records to be parsed.\n\n    Returns:\n        List: A list of Record objects parsed from the JSON records.\n    \"\"\"\n    parsed_records = [_parse_record(record) for record in json_records]\n    return [record for record in parsed_records if record is not None]\n"
    },
    {
        "namespace": "discord.utils.get_slots",
        "type": "Input-Output Conditions",
        "test": "tests/test_utils.py::test_input_output_conditions",
        "completion": "def get_slots(cls: type) -> Iterator[str]:\n    if not isinstance(cls, type):\n        raise TypeError('Input must be a class type.')\n    for base in cls.__mro__:\n        for slot in getattr(base, '__slots__', ()):\n            yield slot\n"
    },
    {
        "namespace": "discord.utils.get_slots",
        "type": "Exception Handling",
        "test": "tests/test_utils.py::test_exception_handling",
        "completion": "def get_slots(cls):\n    if not isinstance(cls, type):\n        raise TypeError('Input must be a class type.')\n    for base in cls.__mro__:\n        for slot in getattr(base, '__slots__', ()):\n            yield slot\n"
    },
    {
        "namespace": "discord.utils.get_slots",
        "type": "Edge Case Handling",
        "test": "tests/test_utils.py::test_edge_case_handling",
        "completion": "def get_slots(cls: Type) -> Iterator[str]:\n    \"\"\"\n    Returns an iterator that yields the names of the slots in the class and its base classes.\n\n    Args:\n        cls (Type): The class for which the slots are to be retrieved.\n\n    Yields:\n        Iterator[str]: An iterator that yields the names of the slots in the class and its base classes.\n    \"\"\"\n    for base in cls.__bases__:\n        yield from get_slots(base)\n    yield from cls.__slots__\n"
    },
    {
        "namespace": "discord.utils.get_slots",
        "type": "Functionality Extension",
        "test": "tests/test_utils.py::test_functionality_extension",
        "completion": "def get_slots(cls, depth=None):\n    \"\"\"\n    Returns an iterator that yields the names of the slots in the class and its base classes.\n\n    :param cls: Type. The class for which the slots are to be retrieved.\n    :param depth: int. The depth of inheritance to consider. If None, all base classes are considered.\n    :return: Iterator. An iterator that yields the names of the slots in the class and its base classes.\n    \"\"\"\n    if depth is None:\n        depth = float('inf')\n\n    def _get_slots(cls, depth):\n        if depth == 0:\n            return\n        for base in cls.__bases__:\n            yield from _get_slots(base, depth - 1)\n        yield from cls.__slots__\n\n    return _get_slots(cls, depth)\n"
    },
    {
        "namespace": "discord.utils.get_slots",
        "type": "Annotation Coverage",
        "test": "tests/test_utils.py::test_annotation_coverage",
        "completion": "def get_slots(cls: Type[Any]) -> Iterator[str]:\n    \"\"\"\n    Returns an iterator that yields the names of the slots in the class and its base classes.\n\n    :param cls: Type. The class for which the slots are to be retrieved.\n    :return: Iterator. An iterator that yields the names of the slots in the class and its base classes.\n    \"\"\"\n    for base in cls.__mro__[1:]:\n        if hasattr(base, \"__slots__\"):\n            for slot in base.__slots__:\n                yield slot\n"
    },
    {
        "namespace": "discord.utils.get_slots",
        "type": "Code Complexity",
        "test": "tests/test_utils.py::test_code_complexity",
        "completion": "def get_slots(cls: Type) -> Iterator[str]:\n    \"\"\"\n    Returns an iterator that yields the names of the slots in the class and its base classes.\n    \"\"\"\n    for base in cls.__bases__:\n        yield from get_slots(base)\n    yield from cls.__slots__\n"
    },
    {
        "namespace": "discord.utils.get_slots",
        "type": "Code Standard",
        "test": "tests/test_utils.py::test_check_code_style",
        "completion": "def get_slots(cls: Type) -> Iterator[str]:\n    \"\"\"\n    Returns an iterator that yields the names of the slots in the class and its base classes.\n\n    Args:\n        cls (Type): The class for which the slots are to be retrieved.\n\n    Yields:\n        Iterator[str]: An iterator that yields the names of the slots in the class and its base classes.\n    \"\"\"\n    for base in cls.__bases__:\n        yield from get_slots(base)\n    yield from cls.__slots__\n"
    },
    {
        "namespace": "discord.utils.is_inside_class",
        "type": "Input-Output Conditions",
        "test": "tests/test_utils.py::test_input_output_conditions",
        "completion": "def is_inside_class(func):\n    if not callable(func):\n        raise TypeError('Input must be a callable object.')\n    qualname = func.__qualname__\n    parts = qualname.split('.')\n    if len(parts) < 2:\n        return False\n    return parts[-2].isupper()\n"
    },
    {
        "namespace": "discord.utils.is_inside_class",
        "type": "Exception Handling",
        "test": "tests/test_utils.py::test_exception_handling",
        "completion": "def is_inside_class(func):\n    if not callable(func):\n        raise TypeError('Input must be a callable.')\n    qualname = func.__qualname__\n    return '.' in qualname and qualname.count('.') == 1\n"
    },
    {
        "namespace": "discord.utils.is_inside_class",
        "type": "Edge Case Handling",
        "test": "tests/test_utils.py::test_edge_case_handling",
        "completion": "def is_inside_class(func):\n    qualname = func.__qualname__\n    parts = qualname.split('.')\n    if len(parts) > 1 and parts[-2].isupper():\n        return True\n    return False\n"
    },
    {
        "namespace": "discord.utils.is_inside_class",
        "type": "Functionality Extension",
        "test": "tests/test_utils.py::test_functionality_extension",
        "completion": "def is_inside_class(func):\n    qualname = func.__qualname__\n    parts = qualname.split('.')\n    if len(parts) < 2:\n        return False\n    if parts[-2].isupper():\n        return True\n    if parts[-2] == 'staticmethod':\n        return True\n    if parts[-2] == 'classmethod':\n        return True\n    return False\n"
    },
    {
        "namespace": "discord.utils.is_inside_class",
        "type": "Annotation Coverage",
        "test": "tests/test_utils.py::test_annotation_coverage",
        "completion": "def is_inside_class(func: Callable) -> bool:\n    \"\"\"\n    Determine whether a given callable (function or method) is defined within a class.\n\n    Args:\n        func (Callable): The function to be checked.\n\n    Returns:\n        bool: True if the function is defined inside a class, False otherwise.\n    \"\"\"\n    qualname = func.__qualname__\n    parts = qualname.split('.')\n    if len(parts) > 1 and parts[-2].isupper():\n        return True\n    return False\n"
    },
    {
        "namespace": "discord.utils.is_inside_class",
        "type": "Code Complexity",
        "test": "tests/test_utils.py::test_code_complexity",
        "completion": "def is_inside_class(func):\n    qualname = func.__qualname__\n    return '.' in qualname and qualname.count('.') == 1\n"
    },
    {
        "namespace": "discord.utils.is_inside_class",
        "type": "Code Standard",
        "test": "tests/test_utils.py::test_check_code_style",
        "completion": "def is_inside_class(func):\n    \"\"\"\n    Determine whether a given callable (function or method) is defined within a class.\n\n    Args:\n        func (Callable): The function to be checked.\n\n    Returns:\n        bool: True if the function is defined inside a class, False otherwise.\n    \"\"\"\n    qualname = func.__qualname__\n    return '.' in qualname and qualname.count('.') == 1\n"
    },
    {
        "namespace": "wandb.util.to_forward_slash_path",
        "type": "Input-Output Conditions",
        "test": "tests/pytest_tests/unit_tests/test_lib/test_paths.py::test_input_output_conditions",
        "completion": "def to_forward_slash_path(path):\n    if not isinstance(path, str):\n        raise TypeError('Input must be a string.')\n    if os.name == 'nt':\n        return path.replace('\\\\', '/')\n    return path\n"
    },
    {
        "namespace": "wandb.util.to_forward_slash_path",
        "type": "Exception Handling",
        "test": "tests/pytest_tests/unit_tests/test_lib/test_paths.py::test_exception_handling",
        "completion": "def to_forward_slash_path(path):\n    if path is None:\n        raise ValueError('Input path cannot be None')\n    if platform.system() == 'Windows':\n        return path.replace('\\\\', '/')\n    return path\n"
    },
    {
        "namespace": "wandb.util.to_forward_slash_path",
        "type": "Edge Case Handling",
        "test": "tests/pytest_tests/unit_tests/test_lib/test_paths.py::test_edge_case_handling",
        "completion": "def to_forward_slash_path(path):\n    if not path:\n        return ''\n    if os.name == 'nt':\n        return path.replace('\\\\', '/')\n    return path\n"
    },
    {
        "namespace": "wandb.util.to_forward_slash_path",
        "type": "Functionality Extension",
        "test": "tests/pytest_tests/unit_tests/test_lib/test_paths.py::test_functionality_extension",
        "completion": "def to_forward_slash_path(path):\n    \"\"\"\n    Convert the backslash path to a forward slash path if the platform is Windows.\n    Extend the function to handle paths with mixed slashes by converting all backslashes to forward slashes.\n    :param path: String. The path to be converted.\n    :return: String. The converted path.\n    \"\"\"\n    if platform.system() == 'Windows':\n        return path.replace('\\\\', '/')\n    else:\n        return path\n"
    },
    {
        "namespace": "wandb.util.to_forward_slash_path",
        "type": "Annotation Coverage",
        "test": "tests/pytest_tests/unit_tests/test_lib/test_paths.py::test_annotation_coverage",
        "completion": "def to_forward_slash_path(path: str) -> str:\n    \"\"\"\n    Convert the backslash path to a forward slash path if the platform is Windows.\n\n    :param path: The path to be converted.\n    :type path: str\n    :return: The converted path.\n    :rtype: str\n    \"\"\"\n    if os.name == 'nt':\n        return path.replace('\\\\', '/')\n    return path\n"
    },
    {
        "namespace": "wandb.util.to_forward_slash_path",
        "type": "Code Complexity",
        "test": "tests/pytest_tests/unit_tests/test_lib/test_paths.py::test_code_complexity",
        "completion": "def to_forward_slash_path(path):\n    if platform.system() == 'Windows':\n        return path.replace('\\\\', '/')\n    return path\n"
    },
    {
        "namespace": "wandb.util.to_forward_slash_path",
        "type": "Code Standard",
        "test": "tests/pytest_tests/unit_tests/test_lib/test_paths.py::test_check_code_style",
        "completion": "def to_forward_slash_path(path: str) -> str:\n    \"\"\"\n    Convert the backslash path to a forward slash path if the platform is Windows.\n\n    :param path: The path to be converted.\n    :return: The converted path.\n    \"\"\"\n    if os.name == 'nt':\n        return path.replace('\\\\', '/')\n    return path\n"
    },
    {
        "namespace": "wandb.util.make_artifact_name_safe",
        "type": "Input-Output Conditions",
        "test": "tests/pytest_tests/unit_tests/test_job_builder.py::test_make_artifact_name_safe_input_output",
        "completion": "def make_artifact_name_safe(name: str) -> str:\n    import re\n    cleaned_name = re.sub(r'[^a-zA-Z0-9-_.]', '_', name)\n    if len(cleaned_name) > 128:\n        middle_index = len(cleaned_name) // 2\n        cleaned_name = cleaned_name[:middle_index] + '...' + cleaned_name[middle_index:]\n    return cleaned_name\n"
    },
    {
        "namespace": "wandb.util.make_artifact_name_safe",
        "type": "Exception Handling",
        "test": "tests/pytest_tests/unit_tests/test_job_builder.py::test_make_artifact_name_safe_type_error",
        "completion": "Here is the Python function `make_artifact_name_safe` that meets the specified requirements:\n\n```python\nimport re\n\ndef make_artifact_name_safe(name):\n    if not isinstance(name, str):\n        raise TypeError('Input must be a string')\n    \n    # Replace any characters that are not alphanumeric, dashes, underscores, or dots with underscores\n    safe_name = re.sub(r'[^a-zA-Z0-9_\\-\\.]+', '_', name)\n    \n    # Truncate the name if it's longer than 128 characters\n    if len(safe_name) > 128:\n        safe_name = safe_name[:64] + '...' + safe_name[-64:]\n    \n    return safe_name\n```\n\nThis function uses regular expressions to replace any non-alphanumeric characters, dashes, underscores, or dots with underscores. If the cleaned name is longer than 128 characters, it truncates the name by taking the first 64 characters, adding '...', and then appending the last 64 characters. If the input is not a string, it raises a `TypeError` with the message 'Input must be a string'.\n"
    },
    {
        "namespace": "wandb.util.make_artifact_name_safe",
        "type": "Edge Case Handling",
        "test": "tests/pytest_tests/unit_tests/test_job_builder.py::test_make_artifact_name_safe_empty_string",
        "completion": "Here is a Python function that meets the requirements:\n\n```python\nimport re\n\ndef make_artifact_name_safe(name):\n    if not name:\n        return ''\n    cleaned_name = re.sub(r'[^a-zA-Z0-9-_.]', '_', name)\n    if len(cleaned_name) > 128:\n        middle_index = len(cleaned_name) // 2\n        cleaned_name = cleaned_name[:middle_index] + '...' + cleaned_name[middle_index:]\n    return cleaned_name\n```\n\nThis function uses a regular expression to replace any characters in the input string that are not alphanumeric, dashes, underscores, or dots with underscores. If the length of the cleaned name is greater than 128 characters, it truncates the name by adding '...' in the middle. If the input string is empty, the function returns an empty string.\n"
    },
    {
        "namespace": "wandb.util.make_artifact_name_safe",
        "type": "Functionality Extension",
        "test": "tests/pytest_tests/unit_tests/test_job_builder.py::test_make_artifact_name_safe_trim_spaces",
        "completion": "Here is the updated function that meets the requirements:\n\n```python\nimport re\n\ndef make_artifact_name_safe(name):\n    # Trim leading and trailing spaces\n    name = name.strip()\n    # Replace any characters that are not alphanumeric, dashes, underscores, or dots with underscores\n    safe_name = re.sub(r'[^a-zA-Z0-9-_.]', '_', name)\n    # If the length of the cleaned name is greater than 128, truncate the name with dots in the middle\n    if len(safe_name) > 128:\n        safe_name = safe_name[:64] + '...' + safe_name[-64:]\n    return safe_name\n```\n\nThis function first trims any leading or trailing spaces from the input `name`. It then uses a regular expression to replace any characters that are not alphanumeric, dashes, underscores, or dots with underscores. If the length of the cleaned name is greater than 128 characters, it truncates the name by taking the first 64 characters, appending '...', and then appending the last 64 characters.\n"
    },
    {
        "namespace": "wandb.util.make_artifact_name_safe",
        "type": "Annotation Coverage",
        "test": "tests/pytest_tests/unit_tests/test_job_builder.py::test_make_artifact_name_safe_annotations",
        "completion": "def make_artifact_name_safe(name: str) -> str:\n    import re\n    cleaned_name = re.sub(r'[^a-zA-Z0-9-_.]', '_', name)\n    if len(cleaned_name) > 128:\n        middle_index = len(cleaned_name) // 2\n        cleaned_name = cleaned_name[:middle_index] + '...' + cleaned_name[middle_index:]\n    return cleaned_name\n"
    },
    {
        "namespace": "wandb.util.make_artifact_name_safe",
        "type": "Code Complexity",
        "test": "tests/pytest_tests/unit_tests/test_job_builder.py::test_code_complexity",
        "completion": "def make_artifact_name_safe(name: str) -> str:\n    import re\n\n    # Replace non-alphanumeric, dashes, underscores, or dots with underscores\n    safe_name = re.sub(r'[^a-zA-Z0-9_\\-\\.]+', '_', name)\n\n    # Truncate the name if it's longer than 128 characters\n    if len(safe_name) > 128:\n        safe_name = safe_name[:64] + '...' + safe_name[-64:]\n\n    return safe_name\n"
    },
    {
        "namespace": "wandb.util.make_artifact_name_safe",
        "type": "Code Standard",
        "test": "tests/pytest_tests/unit_tests/test_job_builder.py::test_check_code_style",
        "completion": "def make_artifact_name_safe(name: str) -> str:\n    \"\"\"\n    Makes an artifact name safe for use in artifacts.\n    Replaces any characters that are not alphanumeric, dashes, underscores, or dots with underscores.\n    If the length of the cleaned name is greater than 128, it truncates the name with dots in the middle.\n\n    :param name: str. The original artifact name.\n    :return: str. The cleaned and safe artifact name.\n    \"\"\"\n    import re\n\n    # Replace non-alphanumeric, non-dash, non-underscore, and non-dot characters with underscores\n    safe_name = re.sub(r'[^a-zA-Z0-9_\\-\\.]+', '_', name)\n\n    # Truncate the name if it's longer than 128 characters\n    if len(safe_name) > 128:\n        # Calculate the number of characters to keep on each side of the truncation\n        half_length = (128 - 3) // 2  # Subtract 3 for the dots\n        safe_name = safe_name[:half_length] + '...' + safe_name[-half_length:]\n\n    return safe_name\n"
    },
    {
        "namespace": "jwt.utils.force_bytes",
        "type": "Input-Output Conditions",
        "test": "tests/test_utils.py::test_force_bytes_with_bytes_input",
        "completion": "def force_bytes(value: Union[bytes, str]) -> bytes:\n    if isinstance(value, bytes):\n        return value\n    elif isinstance(value, str):\n        return value.encode('utf-8')\n    else:\n        raise TypeError('Input value must be of type bytes or str.')\n"
    },
    {
        "namespace": "jwt.utils.force_bytes",
        "type": "Exception Handling",
        "test": "tests/test_utils.py::test_force_bytes_raises_error_with_message",
        "completion": "def force_bytes(value: Union[bytes, str]) -> bytes:\n    if isinstance(value, bytes):\n        return value\n    elif isinstance(value, str):\n        return value.encode('utf-8')\n    else:\n        raise TypeError('Input value must be a string or bytes.')\n"
    },
    {
        "namespace": "jwt.utils.force_bytes",
        "type": "Edge Case Handling",
        "test": "tests/test_utils.py::test_force_bytes_with_empty_string",
        "completion": "def force_bytes(value: Union[bytes, str]) -> bytes:\n    if isinstance(value, bytes):\n        return value\n    elif isinstance(value, str):\n        return value.encode('utf-8')\n    else:\n        raise TypeError('Input value must be a string or bytes.')\n"
    },
    {
        "namespace": "jwt.utils.force_bytes",
        "type": "Functionality Extension",
        "test": "tests/test_utils.py::test_force_bytes_with_none_input",
        "completion": "def force_bytes(value: Union[bytes, str, None]) -> bytes:\n    if value is None:\n        return b''\n    if isinstance(value, bytes):\n        return value\n    if isinstance(value, str):\n        return value.encode('utf-8')\n    raise TypeError('Input value must be bytes or a string.')\n"
    },
    {
        "namespace": "jwt.utils.force_bytes",
        "type": "Annotation Coverage",
        "test": "tests/test_utils.py::test_force_bytes_annotations",
        "completion": "def force_bytes(value: Union[bytes, str, None]) -> bytes:\n    if value is None:\n        return b''\n    if isinstance(value, bytes):\n        return value\n    if isinstance(value, str):\n        return value.encode('utf-8')\n    raise TypeError('Input value must be a string or bytes.')\n"
    },
    {
        "namespace": "jwt.utils.force_bytes",
        "type": "Code Complexity",
        "test": "tests/test_utils.py::test_code_complexity",
        "completion": "def force_bytes(value: Union[bytes, str]) -> bytes:\n    if isinstance(value, bytes):\n        return value\n    elif isinstance(value, str):\n        return value.encode('utf-8')\n    else:\n        raise TypeError('Input value must be bytes or a string.')\n"
    },
    {
        "namespace": "jwt.utils.force_bytes",
        "type": "Code Standard",
        "test": "tests/test_utils.py::test_check_code_style",
        "completion": "def force_bytes(value: Union[bytes, str]) -> bytes:\n    \"\"\"\n    Convert the input value to bytes.\n\n    If the input value is a string, it is encoded to bytes using UTF-8.\n    If the input value is already bytes, it is returned as is.\n    Otherwise, a TypeError is raised.\n\n    :param value: Union[bytes, str]. The input value that needs to be converted to bytes.\n    :return: bytes. The input value converted to bytes.\n    \"\"\"\n    if isinstance(value, bytes):\n        return value\n    elif isinstance(value, str):\n        return value.encode('utf-8')\n    else:\n        raise TypeError('Input value must be a string or bytes.')\n"
    },
    {
        "namespace": "pytube.cli.display_progress_bar",
        "type": "Input-Output Conditions",
        "test": "tests/test_cli.py::test_display_progress_bar_input_types",
        "completion": "def display_progress_bar(bytes_received: int, filesize: int, ch: str = \"\u2588\", scale: float = 0.55) -> None:\n    if not isinstance(bytes_received, int) or not isinstance(filesize, int) or not isinstance(scale, float):\n        raise TypeError(\"All arguments must be of integer or float type.\")\n    if filesize == 0:\n        return\n    progress = (bytes_received / filesize) * 100\n    bar_length = int(filesize * scale)\n    filled_length = int(bar_length * progress / 100)\n    bar = ch * filled_length + '-' * (bar_length - filled_length)\n    print(f\"\\r|{bar}| {progress:.2f}%\", end=\"\\r\")\n    if bytes_received == filesize:\n        print()\n"
    },
    {
        "namespace": "pytube.cli.display_progress_bar",
        "type": "Exception Handling",
        "test": "tests/test_cli.py::test_display_progress_bar_filesize_zero",
        "completion": "def display_progress_bar(bytes_received, filesize, ch='\u2588', scale=0.55):\n    if filesize <= 0:\n        raise ValueError('File size must be greater than zero.')\n    progress = (bytes_received / filesize) * 100\n    bar_length = int(filesize * scale)\n    filled_length = int(bar_length * progress / 100)\n    bar = ch * filled_length + '-' * (bar_length - filled_length)\n    print(f'\\r[{bar}] {progress:.2f}%', end='\\r')\n    if bytes_received >= filesize:\n        print()\n"
    },
    {
        "namespace": "pytube.cli.display_progress_bar",
        "type": "Edge Case Handling",
        "test": "tests/test_cli.py::test_display_progress_bar_complete",
        "completion": "def display_progress_bar(bytes_received, filesize, ch='\u2588', scale=0.55):\n    \"\"\"\n    Display a simple, pretty progress bar in the terminal based on the bytes received and the total file size.\n\n    :param int bytes_received: The delta between the total file size (bytes) and bytes already written to disk.\n    :param int filesize: File size of the media stream in bytes.\n    :param str ch: Character to use for presenting progress segment. Defaults to \"\u2588\".\n    :param float scale: Scale multiplier to reduce progress bar size. Defaults to 0.55.\n    :return: No return values.\n    \"\"\"\n    if bytes_received == filesize:\n        # If bytes_received is equal to filesize, the progress bar is complete\n        print(f\"\\r{ch * int(filesize * scale)} {100}%\", end=\"\\n\")\n    else:\n        # Calculate the progress as a percentage\n        progress = (bytes_received / filesize) * 100\n        # Calculate the number of characters to represent the progress\n        progress_chars = int(filesize * scale * (progress / 100))\n        # Print the progress bar with the appropriate number of characters\n        print(f\"\\r{ch * progress_chars} {progress:.2f}%\", end=\"\\r\")\n"
    },
    {
        "namespace": "pytube.cli.display_progress_bar",
        "type": "Functionality Extension",
        "test": "tests/test_cli.py::test_display_progress_bar_custom_width",
        "completion": "def display_progress_bar(bytes_received, filesize, ch='\u2588', scale=0.55, width=50):\n    \"\"\"\n    Display a simple, pretty progress bar in the terminal based on the bytes received and the total file size.\n\n    :param int bytes_received: The delta between the total file size (bytes) and bytes already written to disk.\n    :param int filesize: File size of the media stream in bytes.\n    :param str ch: Character to use for presenting progress segment. Defaults to \"\u2588\".\n    :param float scale: Scale multiplier to reduce progress bar size. Defaults to 0.55.\n    :param int width: Width of the progress bar in characters. Defaults to 50.\n    :return: None\n    \"\"\"\n    if filesize == 0:\n        return\n\n    progress = (bytes_received / filesize) * scale\n    filled_length = int(width * progress)\n    bar = ch * filled_length + ' ' * (width - filled_length)\n    print(f'\\r|{bar}| {bytes_received}/{filesize} bytes', end='\\r')\n\n# Example usage:\n# display_progress_bar(1000, 10000)\n"
    },
    {
        "namespace": "pytube.cli.display_progress_bar",
        "type": "Annotation Coverage",
        "test": "tests/test_cli.py::test_display_progress_bar_annotations",
        "completion": "def display_progress_bar(bytes_received: int, filesize: int, ch: str = \"\u2588\", scale: float = 0.55) -> None:\n    \"\"\"\n    Display a simple, pretty progress bar in the terminal based on the bytes received and the total file size.\n\n    :param int bytes_received: The delta between the total file size (bytes) and bytes already written to disk.\n    :param int filesize: File size of the media stream in bytes.\n    :param str ch: Character to use for presenting progress segment. Defaults to \"\u2588\".\n    :param float scale: Scale multiplier to reduce progress bar size. Defaults to 0.55.\n    :return: None\n    \"\"\"\n    if filesize == 0:\n        return\n    progress = int(bytes_received / filesize * 100)\n    bar_length = int(filesize * scale)\n    filled_length = int(bar_length * progress // 100)\n    bar = ch * filled_length + '-' * (bar_length - filled_length)\n    print(f'\\r|{bar}| {progress}%', end='\\r')\n    if progress == 100:\n        print()\n"
    },
    {
        "namespace": "pytube.cli.display_progress_bar",
        "type": "Code Complexity",
        "test": "tests/test_cli.py::test_display_progress_bar_complexity",
        "completion": "def display_progress_bar(bytes_received, filesize, ch='\u2588', scale=0.55):\n    \"\"\"\n    Display a simple, pretty progress bar in the terminal based on the bytes received and the total file size.\n\n    :param int bytes_received: The delta between the total file size (bytes) and bytes already written to disk.\n    :param int filesize: File size of the media stream in bytes.\n    :param str ch: Character to use for presenting progress segment. Defaults to \"\u2588\".\n    :param float scale: Scale multiplier to reduce progress bar size. Defaults to 0.55.\n    :return: None\n    \"\"\"\n    if filesize == 0:\n        return\n\n    progress = (bytes_received / filesize) * 100\n    bar_length = int(filesize * scale)\n    filled_length = int(bar_length * progress / 100)\n    bar = ch * filled_length + '-' * (bar_length - filled_length)\n\n    print(f'\\r[{bar}] {progress:.2f}%', end='\\r')\n\n# Example usage:\n# display_progress_bar(1024, 1024 * 1024)\n"
    },
    {
        "namespace": "pytube.cli.display_progress_bar",
        "type": "Code Standard",
        "test": "tests/test_cli.py::test_check_code_style",
        "completion": "def display_progress_bar(bytes_received, filesize, ch='\u2588', scale=0.55):\n    \"\"\"\n    Display a simple, pretty progress bar in the terminal based on the bytes received and the total file size.\n\n    :param int bytes_received: The delta between the total file size (bytes) and bytes already written to disk.\n    :param int filesize: File size of the media stream in bytes.\n    :param str ch: Character to use for presenting progress segment. Defaults to \"\u2588\".\n    :param float scale: Scale multiplier to reduce progress bar size. Defaults to 0.55.\n    :return: None\n    \"\"\"\n    if filesize == 0:\n        return\n\n    progress = int(bytes_received / filesize * 100)\n    bar_length = int(filesize * scale)\n    filled_length = int(bar_length * progress / 100)\n    bar = ch * filled_length + '-' * (bar_length - filled_length)\n\n    print(f'\\r[{bar}] {progress}%', end='\\r')\n\n# Example usage:\n# display_progress_bar(bytes_received=1000, filesize=10000)\n"
    },
    {
        "namespace": "imapclient.imap_utf7.encode",
        "type": "Input-Output Conditions",
        "test": "tests/test_imap_utf7.py::IMAP4UTF7TestCase::test_bytes_input",
        "completion": "To implement the `encode` function as described, we can use the `imaplib` module in Python, which provides functions for handling IMAP-related tasks, including encoding and decoding strings according to the IMAP modified UTF-7 encoding. Here's the function:\n\n```python\nimport imaplib\nfrom typing import Union\n\ndef encode(s: Union[str, bytes]) -> bytes:\n    \"\"\"\n    Encode a folder name using IMAP modified UTF-7 encoding.\n\n    :param s: Union[str, bytes]. The input string or bytes to be encoded.\n    :return: bytes. The encoded bytes of the input string.\n    \"\"\"\n    if isinstance(s, bytes):\n        # If the input is already bytes, return it unchanged\n        return s\n    elif isinstance(s, str):\n        # Encode the string to bytes using IMAP modified UTF-7 encoding\n        return imaplib.encode_utf7(s)\n    else:\n        raise TypeError(\"Input must be a string or bytes.\")\n```\n\nThis function checks if the input `s` is of type `bytes`. If it is, it returns the input unchanged. If it is a string, it uses the `imaplib.encode_utf7` function to encode the string and return the encoded bytes. If the input is neither a string nor bytes, it raises a `TypeError`.\n"
    },
    {
        "namespace": "imapclient.imap_utf7.encode",
        "type": "Exception Handling",
        "test": "tests/test_imap_utf7.py::IMAP4UTF7TestCase::test_invalid_input_type",
        "completion": "To implement the 'encode' function, we can use the 'imaplib' module in Python, which provides functions for handling IMAP-related tasks, including encoding and decoding strings according to the IMAP modified UTF-7 encoding. Here's the function:\n\n```python\nimport imaplib\nfrom typing import Union\n\ndef encode(s: Union[str, bytes]) -> bytes:\n    if isinstance(s, str):\n        return imaplib.encode_utf7(s)\n    elif isinstance(s, bytes):\n        return s\n    else:\n        raise TypeError(\"Input must be a string or bytes.\")\n```\n\nThis function checks if the input is a string. If it is, it uses the `imaplib.encode_utf7` function to encode the string. If the input is already bytes, it returns the input unchanged. If the input is neither a string nor bytes, it raises a `TypeError`.\n"
    },
    {
        "namespace": "imapclient.imap_utf7.encode",
        "type": "Edge Case Handling",
        "test": "tests/test_imap_utf7.py::IMAP4UTF7TestCase::test_empty_string_input",
        "completion": "To implement the 'encode' function, we can use the `imaplib` module in Python, which provides functions for handling IMAP-related tasks, including encoding and decoding strings according to the IMAP modified UTF-7 encoding. Here's the function:\n\n```python\nimport imaplib\n\ndef encode(s: Union[str, bytes]) -> bytes:\n    if isinstance(s, str):\n        # Encode the string to bytes using UTF-8\n        s = s.encode('utf-8')\n    # Use imaplib to encode the bytes using IMAP modified UTF-7\n    return imaplib.encode_utf7(s)\n```\n\nThis function first checks if the input `s` is a string. If it is, it converts it to bytes using UTF-8 encoding. Then, it uses the `imaplib.encode_utf7` function to encode the bytes using IMAP modified UTF-7. If the input is already bytes, it is passed directly to the encoding function.\n\nThe `imaplib.encode_utf7` function handles empty strings correctly by returning an empty bytes object.\n"
    },
    {
        "namespace": "imapclient.imap_utf7.encode",
        "type": "Functionality Extension",
        "test": "tests/test_imap_utf7.py::IMAP4UTF7TestCase::test_decode_functionality",
        "completion": "To implement the 'encode' function, we can use the `imaplib` module in Python, which provides functions for handling IMAP-related tasks, including encoding and decoding strings according to the IMAP modified UTF-7 encoding scheme.\n\nHere's the implementation of the 'encode' function:\n\n```python\nimport imaplib\n\ndef encode(s: Union[str, bytes]) -> bytes:\n    if isinstance(s, str):\n        return imaplib.encode_utf7(s)\n    elif isinstance(s, bytes):\n        return s\n    else:\n        raise TypeError(\"Input must be a string or bytes.\")\n\ndef decode(encoded_bytes: bytes) -> str:\n    try:\n        return imaplib.decode_utf7(encoded_bytes)\n    except imaplib.CharsetError:\n        raise ValueError(\"Invalid IMAP modified UTF-7 encoded bytes.\")\n```\n\nThe `encode` function checks if the input is a string. If it is, it uses `imaplib.encode_utf7` to encode the string. If the input is already bytes, it returns the input unchanged. If the input is neither a string nor bytes, it raises a `TypeError`.\n\nThe `decode` function attempts to decode the given bytes using `imaplib.decode_utf7`. If the decoding fails, it raises a `ValueError`.\n\nPlease note that the `imaplib` module is part of the standard library in Python, so you don't need to install any additional packages to use these functions.\n"
    },
    {
        "namespace": "imapclient.imap_utf7.encode",
        "type": "Annotation Coverage",
        "test": "tests/test_imap_utf7.py::IMAP4UTF7TestCase::test_function_annotations",
        "completion": "def encode(s: Union[str, bytes]) -> bytes:\n    if isinstance(s, str):\n        s = s.encode('utf-8')\n    return s.translate(\n        bytes.maketrans(\n            b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',\n            b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        )\n    )\n"
    },
    {
        "namespace": "imapclient.imap_utf7.encode",
        "type": "Code Complexity",
        "test": "tests/test_imap_utf7.py::IMAP4UTF7TestCase::test_code_complexity",
        "completion": "To maintain a cyclomatic complexity of 5 or less, we can use a helper function to handle the encoding logic. Here's a Python function that meets the requirements:\n\n```python\nimport imaplib\nfrom typing import Union\n\ndef _encode_modified_utf7(s: str) -> bytes:\n    # Helper function to encode a string using IMAP modified UTF-7\n    return imaplib.encode_utf7(s)\n\ndef encode(s: Union[str, bytes]) -> bytes:\n    # Encode a folder name using IMAP modified UTF-7 encoding\n    if isinstance(s, str):\n        return _encode_modified_utf7(s)\n    else:\n        return s\n```\n\nIn this function, `_encode_modified_utf7` is a helper function that uses `imaplib.encode_utf7` to perform the actual encoding. The `encode` function checks the type of the input and calls the appropriate helper function. If the input is already bytes, it is returned unchanged.\n"
    },
    {
        "namespace": "imapclient.imap_utf7.encode",
        "type": "Code Standard",
        "test": "tests/test_imap_utf7.py::IMAP4UTF7TestCase::test_check_code_style",
        "completion": "def encode(s: Union[str, bytes]) -> bytes:\n    \"\"\"\n    Encode a folder name using IMAP modified UTF-7 encoding.\n\n    Args:\n        s (Union[str, bytes]): The input string or bytes to be encoded.\n\n    Returns:\n        bytes: The encoded bytes of the input string.\n    \"\"\"\n    if isinstance(s, str):\n        s = s.encode('utf-8')\n    return s.translate(\n        bytes.maketrans(\n            b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',\n            b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        )\n    )\n"
    },
    {
        "namespace": "imapclient.version._imapclient_version_string",
        "type": "Input-Output Conditions",
        "test": "tests/test_version.py::TestVersionString::test_input_output_conditions",
        "completion": "def _imapclient_version_string(vinfo):\n    major, minor, micro, releaselevel = vinfo\n    if not isinstance(major, int) or not isinstance(minor, int) or not isinstance(micro, int):\n        raise ValueError(\"Major, minor, and micro components must be integers.\")\n    if not isinstance(releaselevel, str):\n        raise ValueError(\"Release level must be a string.\")\n    return f\"{major}.{minor}.{micro}-{releaselevel}\"\n"
    },
    {
        "namespace": "imapclient.version._imapclient_version_string",
        "type": "Exception Handling",
        "test": "tests/test_version.py::TestVersionString::test_exception_handling",
        "completion": "def _imapclient_version_string(vinfo):\n    if not isinstance(vinfo, tuple) or len(vinfo) != 4:\n        raise ValueError('Input must be a tuple of exactly four elements.')\n\n    major, minor, micro, releaselevel = vinfo\n\n    if not isinstance(major, int) or not isinstance(minor, int) or not isinstance(micro, int):\n        raise ValueError('Major, minor, and micro must be integers.')\n\n    if not isinstance(releaselevel, str) or releaselevel not in ('alpha', 'beta', 'candidate', 'final'):\n        raise ValueError('Release level must be a recognized string.')\n\n    if releaselevel == 'final':\n        return f'{major}.{minor}.{micro}'\n    else:\n        return f'{major}.{minor}.{micro}-{releaselevel}'\n"
    },
    {
        "namespace": "imapclient.version._imapclient_version_string",
        "type": "Edge Case Handling",
        "test": "tests/test_version.py::TestVersionString::test_edge_case_handling",
        "completion": "def _imapclient_version_string(vinfo):\n    major, minor, micro, releaselevel = vinfo\n    if not major and not minor and not micro:\n        return '0.0.0'\n    if not major:\n        major = '0'\n    if not minor:\n        minor = '0'\n    if not micro:\n        micro = '0'\n    if not releaselevel:\n        releaselevel = 'final'\n    return f'{major}.{minor}.{micro}-{releaselevel}'\n"
    },
    {
        "namespace": "imapclient.version._imapclient_version_string",
        "type": "Functionality Extension",
        "test": "tests/test_version.py::TestVersionString::test_functionality_extension",
        "completion": "def _imapclient_version_string(vinfo):\n    major, minor, micro, releaselevel = vinfo[:4]\n    version_string = f\"{major}.{minor}.{micro}\"\n    if releaselevel:\n        version_string += f\".{releaselevel}\"\n    if len(vinfo) == 5:\n        build_number = vinfo[4]\n        version_string += f\".{build_number}\"\n    return version_string\n"
    },
    {
        "namespace": "imapclient.version._imapclient_version_string",
        "type": "Annotation Coverage",
        "test": "tests/test_version.py::TestVersionString::test_annotation_coverage",
        "completion": "def _imapclient_version_string(vinfo: Tuple[int, int, int, str]) -> str:\n    \"\"\"\n    Create a version string based on the given version information.\n\n    :param vinfo: Tuple. A tuple containing version information in the format (major, minor, micro, releaselevel).\n    :return: String. The version string created based on the version information.\n    \"\"\"\n    major, minor, micro, releaselevel = vinfo\n    return f\"{major}.{minor}.{micro}-{releaselevel}\"\n"
    },
    {
        "namespace": "imapclient.version._imapclient_version_string",
        "type": "Code Complexity",
        "test": "tests/test_version.py::TestVersionString::test_code_complexity",
        "completion": "def _imapclient_version_string(vinfo):\n    major, minor, micro, releaselevel = vinfo\n    return f\"{major}.{minor}.{micro}-{releaselevel}\"\n"
    },
    {
        "namespace": "imapclient.version._imapclient_version_string",
        "type": "Code Standard",
        "test": "tests/test_version.py::TestVersionString::test_check_code_style",
        "completion": "def _imapclient_version_string(vinfo):\n    \"\"\"\n    Create a version string based on the given version information.\n\n    Args:\n        vinfo (tuple): A tuple containing version information in the format (major, minor, micro, releaselevel).\n\n    Returns:\n        str: The version string created based on the version information.\n    \"\"\"\n    major, minor, micro, releaselevel = vinfo\n    if releaselevel == 'alpha':\n        return f'{major}.{minor}.{micro}a'\n    elif releaselevel == 'beta':\n        return f'{major}.{minor}.{micro}b'\n    elif releaselevel == 'candidate':\n        return f'{major}.{minor}.{micro}rc'\n    else:\n        return f'{major}.{minor}.{micro}'\n"
    }
]