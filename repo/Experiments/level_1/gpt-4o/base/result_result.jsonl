{"namespace": "benedict.utils.type_util.is_json_serializable", "completion": "\nimport json\n\ndef is_json_serializable(val):\n    \"\"\"\n    Check if the input value is JSON serializable.\n\n    :param val: Any. The input value to be checked for JSON serializability.\n    :return: Bool. True if the input value is JSON serializable, False otherwise.\n    \"\"\"\n    try:\n        json.dumps(val)\n        return True\n    except (TypeError, OverflowError):\n        return False\n\n# Example usage:\nprint(is_json_serializable({\"key\": \"value\"}))  # True\nprint(is_json_serializable(set([1, 2, 3])))    # False\n", "Result": "Pass"}
{"namespace": "feedparser.urls.convert_to_idn", "completion": "\nimport urllib.parse\n\ndef convert_to_idn(url):\n    \"\"\"\n    Convert a URL to IDN notation. It checks if the host can be encoded in ASCII.\n    If not, it converts the host to IDN form.\n\n    :param url: String. The URL to be converted to IDN notation.\n    :return: String. The URL in IDN notation.\n    \"\"\"\n    try:\n        # Parse the URL into components\n        parsed_url = urllib.parse.urlparse(url)\n        \n        # Extract the hostname\n        hostname = parsed_url.hostname\n        \n        # Convert the hostname to IDN if necessary\n        if hostname:\n            try:\n                # Attempt to encode the hostname in ASCII\n                hostname_ascii = hostname.encode('ascii')\n            except UnicodeEncodeError:\n                # If it fails, convert to IDN\n                hostname_idn = hostname.encode('idna').decode('ascii')\n            else:\n                # If successful, use the ASCII hostname\n                hostname_idn = hostname_ascii.decode('ascii')\n            \n            # Reconstruct the URL with the IDN hostname\n            netloc = parsed_url.netloc.replace(hostname, hostname_idn)\n            idn_url = urllib.parse.urlunparse(parsed_url._replace(netloc=netloc))\n            return idn_url\n        else:\n            # If no hostname is found, return the original URL\n            return url\n    except Exception as e:\n        # Handle any unexpected errors\n        print(f\"Error converting URL to IDN: {e}\")\n        return url\n\n# Example usage:\nurl = \"http://www.\u4f8b\u5b50.com\"\nidn_url = convert_to_idn(url)\nprint(idn_url)\n", "Result": "Pass"}
{"namespace": "googleapiclient._helpers.parse_unique_urlencoded", "completion": "\nfrom urllib.parse import parse_qs\n\ndef parse_unique_urlencoded(content):\n    \"\"\"\n    Parses unique key-value parameters from URL-encoded content.\n    \n    :param content: string. URL-encoded key-value pairs.\n    :return: dict. The key-value pairs from the input content.\n    :raises ValueError: if one of the keys is repeated.\n    \"\"\"\n    # Parse the URL-encoded content\n    parsed_content = parse_qs(content, keep_blank_values=True)\n    \n    # Check for repeated keys\n    for key, values in parsed_content.items():\n        if len(values) > 1:\n            raise ValueError(f\"Repeated key found: {key}\")\n    \n    # Convert the parsed content to a dictionary with single values\n    result = {key: values[0] for key, values in parsed_content.items()}\n    \n    return result\n\n# Example usage:\n# content = \"key1=value1&key2=value2\"\n# result = parse_unique_urlencoded(content)\n# print(result)  # Output: {'key1': 'value1', 'key2': 'value2'}\n", "Result": "Pass"}
{"namespace": "jinja2.async_utils.auto_aiter", "completion": "\nimport collections.abc\nfrom typing import AsyncIterator, Union, Iterable, AsyncIterable\n\nasync def auto_aiter(iterable: Union[AsyncIterable, Iterable]) -> AsyncIterator:\n    if isinstance(iterable, collections.abc.AsyncIterable):\n        # If the iterable is already an async iterable, use it directly\n        async for item in iterable:\n            yield item\n    else:\n        # If the iterable is a regular iterable, convert it to an async iterable\n        for item in iterable:\n            yield item\n\n# Example usage:\n# async def main():\n#     async for item in auto_aiter([1, 2, 3]):\n#         print(item)\n#\n#     async for item in auto_aiter(async_gen()):\n#         print(item)\n#\n# async def async_gen():\n#     for i in range(3):\n#         yield i\n", "Result": "Pass"}
{"namespace": "csvs_to_sqlite.utils.table_exists", "completion": "\nimport sqlite3\n\ndef table_exists(conn, table):\n    \"\"\"\n    Check if the table exists in the database.\n\n    :param conn: Connection. The connection to the database.\n    :param table: String. The name of the table to check.\n    :return: Bool. True if the table exists, False otherwise.\n    \"\"\"\n    cursor = conn.cursor()\n    # Query to check if the table exists\n    cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?;\", (table,))\n    result = cursor.fetchone()\n    # If result is not None, the table exists\n    return result is not None\n\n# Example usage:\n# conn = sqlite3.connect('example.db')\n# print(table_exists(conn, 'my_table'))\n", "Result": "Pass"}
{"namespace": "sqlitedict.SqliteDict.get_tablenames", "completion": "\nimport sqlite3\nimport os\n\ndef get_tablenames(filename):\n    \"\"\"\n    Retrieves the names of the tables in an SQLite database.\n\n    :param filename: String. The name of the SQLite database file.\n    :return: List of strings. The names of the tables in the SQLite database.\n    :raises IOError: If the file does not exist.\n    \"\"\"\n    # Check if the file exists\n    if not os.path.exists(filename):\n        raise IOError(f'file {filename} does not exist')\n\n    # Connect to the SQLite database\n    connection = sqlite3.connect(filename)\n    cursor = connection.cursor()\n\n    # Query to get the table names\n    cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table';\")\n    tables = cursor.fetchall()\n\n    # Close the connection\n    connection.close()\n\n    # Extract table names from the query result\n    table_names = [table[0] for table in tables]\n\n    return table_names\n", "Result": "Error"}
{"namespace": "psd_tools.utils.pack", "completion": "\nimport struct\n\ndef pack(fmt, *args):\n    \"\"\"\n    Packs the input arguments into a binary string according to the given format.\n\n    :param fmt: String. The format string that specifies the format of the returned string.\n    :param *args: Tuple. The input arguments to be packed.\n    :return: Binary string. The packed binary string.\n    \"\"\"\n    # Prepend '>' to the format string to ensure big-endian byte order\n    format_string = f'>{fmt}'\n    \n    # Use struct.pack to pack the arguments into a binary string\n    packed_data = struct.pack(format_string, *args)\n    \n    return packed_data\n\n# Example usage:\n# packed = pack('iif', 1, 2, 3.0)\n# print(packed)\n", "Result": "Pass"}
{"namespace": "psd_tools.utils.unpack", "completion": "\nimport struct\n\ndef unpack(fmt, data):\n    \"\"\"\n    Unpacks the given data according to the specified format.\n\n    :param fmt: String. The format string to be used for unpacking the data.\n    :param data: Data. The data to be unpacked.\n    :return: Tuple. A tuple containing the unpacked values.\n    \"\"\"\n    # Ensure the format string starts with '>'\n    if not fmt.startswith('>'):\n        fmt = '>' + fmt\n    \n    # Use struct.unpack to unpack the data\n    unpacked_data = struct.unpack(fmt, data)\n    \n    return unpacked_data\n\n# Example usage:\n# fmt = '>I2s'\n# data = b'\\x00\\x00\\x00\\x01AB'\n# result = unpack(fmt, data)\n# print(result)  # Output: (1, b'AB')\n", "Result": "Pass"}
{"namespace": "exodus_bundler.bundling.bytes_to_int", "completion": "\ndef bytes_to_int(bytes_string, byteorder='big'):\n    \"\"\"\n    Convert a byte string into an integer.\n\n    :param bytes_string: Byte string. The byte string to be converted into an integer.\n    :param byteorder: String. The byte order to be used. It defaults to \"big\" if not specified.\n    :return: Integer. The converted integer value.\n    \"\"\"\n    return int.from_bytes(bytes_string, byteorder)\n\n# Example usage:\nbyte_string = b'\\x00\\x10'\nresult = bytes_to_int(byte_string, 'big')\nprint(result)  # Output: 16\n", "Result": "Pass"}
{"namespace": "exodus_bundler.templating.render_template", "completion": "\ndef render_template(string, context):\n    \"\"\"\n    Replaces the placeholders in the input string with the corresponding values from the context dictionary.\n\n    :param string: String. The input string containing placeholders.\n    :param context: Dictionary. The key-value pairs to replace the placeholders in the input string.\n    :return: String. The modified string after replacing the placeholders.\n    \"\"\"\n    for key, value in context.items():\n        placeholder = f'{{{key}}}'\n        string = string.replace(placeholder, str(value))\n    return string\n\n# Example usage:\ntemplate = \"Hello, {name}! Welcome to {place}.\"\ncontext = {\"name\": \"Alice\", \"place\": \"Wonderland\"}\nresult = render_template(template, context)\nprint(result)  # Output: Hello, Alice! Welcome to Wonderland.\n", "Result": "Error"}
{"namespace": "trailscraper.iam.all_known_iam_permissions", "completion": "\nimport os\n\ndef all_known_iam_permissions():\n    \"\"\"\n    This function reads a file named 'known-iam-actions.txt' located in the same directory\n    as the script and returns a set of all known IAM actions listed in the file.\n\n    :return: set. A set of lines from the file.\n    \"\"\"\n    # Get the directory name of the current script\n    current_dir = os.path.dirname(os.path.abspath(__file__))\n    \n    # Construct the full path to the 'known-iam-actions.txt' file\n    file_path = os.path.join(current_dir, 'known-iam-actions.txt')\n    \n    # Initialize an empty set to store the IAM actions\n    iam_actions = set()\n    \n    # Open the file and read its contents\n    try:\n        with open(file_path, 'r') as file:\n            for line in file:\n                # Strip any leading/trailing whitespace and add the line to the set\n                iam_actions.add(line.strip())\n    except FileNotFoundError:\n        print(f\"Error: The file '{file_path}' was not found.\")\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n    \n    return iam_actions\n", "Result": "Pass"}
{"namespace": "trailscraper.cloudtrail.parse_records", "completion": "\nfrom typing import List, Optional\nimport json\nfrom dataclasses import dataclass\n\n# Define the Record class\n@dataclass\nclass Record:\n    id: int\n    name: str\n    value: float\n\n# Define the _parse_record function\ndef _parse_record(json_record: dict) -> Optional[Record]:\n    try:\n        # Assuming the JSON record has 'id', 'name', and 'value' fields\n        record_id = json_record['id']\n        name = json_record['name']\n        value = json_record['value']\n        return Record(id=record_id, name=name, value=value)\n    except (KeyError, TypeError, ValueError):\n        # Return None if the record is invalid or missing required fields\n        return None\n\n# Define the parse_records function\ndef parse_records(json_records: List[dict]) -> List[Record]:\n    parsed_records = [_parse_record(record) for record in json_records]\n    # Filter out None values\n    return [record for record in parsed_records if record is not None]\n\n# Example usage\nif __name__ == \"__main__\":\n    json_data = [\n        {\"id\": 1, \"name\": \"Record1\", \"value\": 10.5},\n        {\"id\": 2, \"name\": \"Record2\", \"value\": 20.0},\n        {\"id\": 3, \"name\": \"Record3\"},  # Invalid record, missing 'value'\n        {\"id\": 4, \"name\": \"Record4\", \"value\": 30.5}\n    ]\n\n    records = parse_records(json_data)\n    for record in records:\n        print(record)\n", "Result": "Error"}
{"namespace": "discord.utils.get_slots", "completion": "\ndef get_slots(cls):\n    \"\"\"\n    Returns an iterator that yields the names of the slots in the class and its base classes.\n\n    :param cls: Type. The class for which the slots are to be retrieved.\n    :return: Iterator. An iterator that yields the names of the slots in the class and its base classes.\n    \"\"\"\n    seen = set()\n    \n    for base in cls.__mro__:\n        slots = getattr(base, '__slots__', None)\n        if slots is not None:\n            if isinstance(slots, str):\n                slots = (slots,)\n            for slot in slots:\n                if slot not in seen:\n                    seen.add(slot)\n                    yield slot\n\n# Example usage:\nclass Base:\n    __slots__ = ('a', 'b')\n\nclass Derived(Base):\n    __slots__ = ('c',)\n\n# This will print: a, b, c\nfor slot in get_slots(Derived):\n    print(slot)\n", "Result": "Pass"}
{"namespace": "discord.utils.is_inside_class", "completion": "\ndef is_inside_class(func):\n    \"\"\"\n    Determine whether a given callable is defined within a class.\n\n    :param func: Callable. The function to be checked.\n    :return: Bool. True if the function is defined inside a class, False otherwise.\n    \"\"\"\n    # Check if the callable has a __qualname__ attribute\n    if not hasattr(func, '__qualname__'):\n        return False\n    \n    # Split the qualified name by dots\n    qualname_parts = func.__qualname__.split('.')\n    \n    # If there's more than one part, it might be inside a class or a nested function\n    # We need to check if the second last part is a class\n    if len(qualname_parts) > 1:\n        # The second last part should be a class name if it's defined inside a class\n        # We assume that class names start with an uppercase letter by convention\n        # This is a heuristic and might not be foolproof\n        return qualname_parts[-2][0].isupper()\n    \n    return False\n\n# Example usage:\nclass MyClass:\n    def method(self):\n        pass\n\ndef standalone_function():\n    pass\n\nprint(is_inside_class(MyClass.method))  # True\nprint(is_inside_class(standalone_function))  # False\n", "Result": "Pass"}
{"namespace": "wandb.util.to_forward_slash_path", "completion": "\nimport os\n\ndef to_forward_slash_path(path):\n    \"\"\"\n    Convert the backslash path to a forward slash path if the platform is Windows.\n\n    :param path: String. The path to be converted.\n    :return: String. The converted path.\n    \"\"\"\n    if os.name == 'nt':  # 'nt' indicates Windows\n        return path.replace('\\\\', '/')\n    return path\n\n# Example usage:\n# print(to_forward_slash_path(\"C:\\\\Users\\\\Username\\\\Documents\"))\n", "Result": "Pass"}
{"namespace": "wandb.util.make_artifact_name_safe", "completion": "\nimport re\n\ndef make_artifact_name_safe(name: str) -> str:\n    # Replace any character that is not alphanumeric, dash, underscore, or dot with an underscore\n    safe_name = re.sub(r'[^a-zA-Z0-9._-]', '_', name)\n    \n    # If the length of the cleaned name is greater than 128, truncate it with dots in the middle\n    if len(safe_name) > 128:\n        # Calculate the number of characters to keep on each side\n        keep_length = 64\n        safe_name = safe_name[:keep_length] + '...' + safe_name[-keep_length:]\n    \n    return safe_name\n\n# Example usage:\n# original_name = \"This is a very long artifact name with special characters!@#$%^&*() that needs to be cleaned and truncated if necessary.\"\n# safe_name = make_artifact_name_safe(original_name)\n# print(safe_name)\n", "Result": "Pass"}
{"namespace": "jwt.utils.force_bytes", "completion": "\nfrom typing import Union\n\ndef force_bytes(value: Union[bytes, str]) -> bytes:\n    \"\"\"\n    Convert the input value to bytes. If the input value is a string, it is encoded to bytes using UTF-8.\n    If the input value is already bytes, it is returned as is. Otherwise, a TypeError will be raised.\n\n    :param value: Union[bytes, str]. The input value that needs to be converted to bytes.\n    :return: bytes. The input value converted to bytes.\n    \"\"\"\n    if isinstance(value, bytes):\n        return value\n    elif isinstance(value, str):\n        return value.encode('utf-8')\n    else:\n        raise TypeError(f\"Expected bytes or str, but got {type(value).__name__}.\")\n\n# Example usage:\n# print(force_bytes(\"hello\"))  # Output: b'hello'\n# print(force_bytes(b\"hello\")) # Output: b'hello'\n# print(force_bytes(123))      # Raises TypeError\n", "Result": "Pass"}
{"namespace": "pytube.cli.display_progress_bar", "completion": "\ndef display_progress_bar(bytes_received, filesize, ch='\u2588', scale=0.55):\n    \"\"\"\n    Display a simple, pretty progress bar in the terminal.\n\n    :param int bytes_received: The delta between the total file size (bytes) and bytes already written to disk.\n    :param int filesize: File size of the media stream in bytes.\n    :param str ch: Character to use for presenting progress segment. Defaults to \"\u2588\".\n    :param float scale: Scale multiplier to reduce progress bar size. Defaults to 0.55.\n    :return: No return values.\n    \"\"\"\n    # Calculate the percentage of the file that has been received\n    percent = bytes_received / filesize\n    # Calculate the length of the progress bar\n    bar_length = int(50 * scale)\n    # Calculate the number of characters to display in the progress bar\n    filled_length = int(bar_length * percent)\n    \n    # Create the progress bar string\n    bar = ch * filled_length + '-' * (bar_length - filled_length)\n    \n    # Print the progress bar with percentage\n    print(f'\\r|{bar}| {percent:.1%} Complete', end='\\r')\n    \n    # Print a new line when the download is complete\n    if bytes_received >= filesize:\n        print()\n\n# Example usage:\n# display_progress_bar(500, 1000)\n", "Result": "Pass"}
{"namespace": "imapclient.imap_utf7.encode", "completion": "\nimport imaplib\nfrom typing import Union\n\ndef encode(s: Union[str, bytes]) -> bytes:\n    if isinstance(s, bytes):\n        # If the input is already bytes, return it unchanged\n        return s\n    elif isinstance(s, str):\n        # Use the imaplib's encode method for modified UTF-7\n        return imaplib.IMAP4._encode_utf7(s)\n    else:\n        # If the input is neither str nor bytes, raise a TypeError\n        raise TypeError(\"Input must be of type str or bytes\")\n\n# Example usage:\nfolder_name = \"Test & Folder\"\nencoded_folder_name = encode(folder_name)\nprint(encoded_folder_name)\n", "Result": "Error"}
{"namespace": "imapclient.version._imapclient_version_string", "completion": "\ndef _imapclient_version_string(vinfo):\n    \"\"\"\n    Create a version string based on the given version information.\n\n    :param vinfo: Tuple. A tuple containing version information in the format (major, minor, micro, releaselevel).\n    :return: String. The version string created based on the version information.\n    \"\"\"\n    major, minor, micro, releaselevel = vinfo\n    \n    # Start with the major, minor, and micro version numbers\n    version = f\"{major}.{minor}.{micro}\"\n    \n    # Append the release level if it's not 'final'\n    if releaselevel and releaselevel != 'final':\n        version += f\"-{releaselevel}\"\n    \n    return version\n\n# Example usage:\nvinfo = (1, 2, 3, 'beta')\nprint(_imapclient_version_string(vinfo))  # Output: \"1.2.3-beta\"\n", "Result": "Pass"}
