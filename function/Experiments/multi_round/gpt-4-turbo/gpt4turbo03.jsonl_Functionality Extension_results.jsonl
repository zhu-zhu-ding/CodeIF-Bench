{"task_id": 11, "requirement": "Functionality Extension", "completion": "def remove_occ(s, char, all=False):\n    if all:\n        # Remove all occurrences of the character\n        return s.replace(char, \"\")\n    else:\n        # Find the index of the first occurrence of the character\n        first_occurrence = s.find(char)\n        if first_occurrence == -1:\n            # If the character is not found, return the original string\n            return s\n        \n        # Remove the first occurrence of the character\n        s = s[:first_occurrence] + s[first_occurrence + 1:]\n        \n        # Find the index of the last occurrence of the character\n        last_occurrence = s.rfind(char)\n        if last_occurrence == -1:\n            # If the character is not found after removing the first occurrence, return the modified string\n            return s\n        \n        # Remove the last occurrence of the character\n        s = s[:last_occurrence] + s[last_occurrence + 1:]\n        \n        return s\n\n# Example usage:\nresult1 = remove_occ(\"hello world\", \"l\")\nprint(result1)  # Output: \"heo world\"\n\nresult2 = remove_occ(\"hello world\", \"l\", all=True)\nprint(result2)  # Output: \"heo word\"\n", "result": "passed", "passed": true}
{"task_id": 12, "requirement": "Functionality Extension", "completion": "def sort_matrix(matrix):\n    # Find the maximum row length\n    max_length = max(len(row) for row in matrix)\n    \n    # Pad rows with zeros to make them all the same length\n    padded_matrix = [row + [0] * (max_length - len(row)) for row in matrix]\n    \n    # Calculate the sum of each row and store it along with the row index in a list of tuples\n    row_sums_with_index = [(sum(row), index) for index, row in enumerate(padded_matrix)]\n    \n    # Sort the list of tuples by the sum (first element of the tuple)\n    row_sums_with_index.sort()\n    \n    # Create a new matrix sorted by the row sums\n    sorted_matrix = [matrix[index] for _, index in row_sums_with_index]\n    \n    return sorted_matrix\n\n# Example usage:\nmatrix = [\n    [3, 2, 1],\n    [1, 2],\n    [6, 5, 4, 3]\n]\n\nsorted_matrix = sort_matrix(matrix)\nfor row in sorted_matrix:\n    print(row)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmppr77gr9h.py\", line 22, in <module>\n    assert sort_matrix([[1, 2, 3], [4, 5], [6]]) == [[6], [4, 5], [1, 2, 3]]\nAssertionError", "passed": false}
{"task_id": 13, "requirement": "Functionality Extension", "completion": "def count_common(word_dict, top_n=None):\n    # Sort the dictionary items by count in descending order\n    sorted_words = sorted(word_dict.items(), key=lambda item: item[1], reverse=True)\n    \n    # If top_n is specified, return only the top_n most common words\n    if top_n is not None:\n        return sorted_words[:top_n]\n    else:\n        # Find the maximum count in the sorted list\n        max_count = sorted_words[0][1]\n        \n        # Create a list to store the most common words\n        common_words = []\n        \n        # Iterate through the sorted list to find words with the maximum count\n        for word, count in sorted_words:\n            if count == max_count:\n                common_words.append((word, count))\n            else:\n                break\n        \n        return common_words\n\n# Example usage:\nword_counts = {'hello': 3, 'world': 5, 'python': 5, 'programming': 2, 'code': 5}\nmost_common_words = count_common(word_counts)\nprint(most_common_words)  # Output: [('world', 5), ('python', 5), ('code', 5)]\n\ntop_3_words = count_common(word_counts, top_n=3)\nprint(top_3_words)  # Output: [('world', 5), ('python', 5), ('code', 5)]\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmph3yh3fez.py\", line 25, in <module>\n    assert count_common(['apple', 'banana', 'apple', 'orange', 'banana', 'banana'], 2) == [('banana', 3), ('apple', 2)]\n  File \"/tmp/tmph3yh3fez.py\", line 3, in count_common\n    sorted_words = sorted(word_dict.items(), key=lambda item: item[1], reverse=True)\nAttributeError: 'list' object has no attribute 'items'", "passed": false}
{"task_id": 14, "requirement": "Functionality Extension", "completion": "def find_volume(dimensions):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n\n    Parameters:\n    dimensions (list or tuple): A list or tuple containing three elements:\n                                base_area (float) - The area of the triangular base of the prism.\n                                height (float) - The height of the prism.\n                                length (float) - The length of the prism.\n\n    Returns:\n    float: The volume of the triangular prism.\n    \"\"\"\n    if not isinstance(dimensions, (list, tuple)) or len(dimensions) != 3:\n        raise ValueError(\"Input must be a list or tuple with exactly three elements.\")\n    \n    base_area, height, length = dimensions\n    \n    # Volume of a triangular prism is given by the formula: V = base_area * height * length\n    volume = base_area * height * length\n    return volume\n\n# Example usage:\ndimensions = (10.5, 20.0, 15.0)  # Example dimensions as a tuple (base_area, height, length)\nvolume = find_volume(dimensions)\nprint(\"The volume of the triangular prism is:\", volume)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpbpu6sq4v.py\", line 12, in <module>\n    assert find_volume([10, 8, 6]) == 240\nAssertionError", "passed": false}
{"task_id": 15, "requirement": "Functionality Extension", "completion": "import re\n\ndef split_lowerstring(input_string, include_lower=False):\n    # Use regular expression to split the string at lowercase letters\n    if include_lower:\n        # Include lowercase letters in the output\n        result = re.split(r'(?=[A-Z])', input_string)\n    else:\n        # Split and keep lowercase letters separate\n        result = re.split(r'([a-z])', input_string)\n    \n    # Filter out empty strings from the result\n    result = [s for s in result if s]\n    \n    return result\n\n# Example usage\ninput_string = \"HelloWorld\"\nprint(split_lowerstring(input_string, include_lower=True))  # Output: ['Hello', 'World']\nprint(split_lowerstring(input_string, include_lower=False))  # Output: ['H', 'e', 'llo', 'W', 'o', 'rld']\n", "result": "passed", "passed": true}
{"task_id": 16, "requirement": "Functionality Extension", "completion": "import re\n\ndef text_lowercase_underscore(text):\n    pattern = r'\\b[a-z]+(?:_[a-z]+)+\\b'\n    matches = re.findall(pattern, text)\n    if matches:\n        return 'Found a match!'\n    else:\n        return 'No match found.'\n\n# Example usage:\ntext1 = \"This is an example_text with multiple_words and some single_words.\"\ntext2 = \"This text has no_matches of the specified pattern.\"\nprint(text_lowercase_underscore(text1))  # Output: 'Found a match!'\nprint(text_lowercase_underscore(text2))  # Output: 'No match found.'\n", "result": "passed", "passed": true}
{"task_id": 17, "requirement": "Functionality Extension", "completion": "def square_perimeter(side_length):\n    rounded_side_length = round(side_length)\n    return 4 * rounded_side_length", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp7p_4vj6j.py\", line 4, in <module>\n    assert square_perimeter(4.5) == 20\nAssertionError", "passed": false}
{"task_id": 18, "requirement": "Functionality Extension", "completion": "def remove_dirty_chars(s1, s2):\n    # Convert both strings to lowercase to ensure case-insensitivity\n    s1_lower = s1.lower()\n    s2_lower = s2.lower()\n    \n    # Create a set of characters from the second string\n    dirty_chars = set(s2_lower)\n    \n    # Use a list comprehension to filter out characters from the first string that are in the dirty_chars set\n    filtered_chars = [char for char in s1_lower if char not in dirty_chars]\n    \n    # Join the filtered characters to form the cleaned string\n    cleaned_string = ''.join(filtered_chars)\n    \n    return cleaned_string\n\n# Example usage:\ns1 = \"Hello World\"\ns2 = \"aeiou\"\nresult = remove_dirty_chars(s1, s2)\nprint(result)  # Output: \"hll wrld\"\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp0mq867dk.py\", line 17, in <module>\n    assert remove_dirty_chars('HelloWorld', 'hELLO') == 'World', 'Function should handle case-insensitive character removal.'\nAssertionError: Function should handle case-insensitive character removal.", "passed": false}
{"task_id": 19, "requirement": "Functionality Extension", "completion": "def test_duplicate(arr):\n    # Create an empty set to store unique elements\n    seen = set()\n    # Create an empty list to store duplicate elements\n    duplicates = []\n    \n    # Iterate through each element in the array\n    for num in arr:\n        # Check if the element is already in the set\n        if num in seen:\n            # If it is and not already in duplicates, add to duplicates list\n            if num not in duplicates:\n                duplicates.append(num)\n        else:\n            # Add the element to the set\n            seen.add(num)\n    \n    # Return the list of duplicates\n    return duplicates\n\n# Example usage:\narr = [1, 2, 3, 4, 5, 1, 2, 2]\nprint(test_duplicate(arr))  # Output: [1, 2]\n\narr = [1, 2, 3, 4, 5]\nprint(test_duplicate(arr))  # Output: []\n", "result": "passed", "passed": true}
{"task_id": 20, "requirement": "Functionality Extension", "completion": "def is_woodall(num):\n    if not isinstance(num, int) or num < 1:\n        return False\n    \n    woodall_numbers = []\n    n = 1\n    while True:\n        woodall_number = n * (2 ** n) - 1\n        if woodall_number > num:\n            break\n        woodall_numbers.append(woodall_number)\n        n += 1\n    \n    return woodall_numbers if woodall_numbers else False\n\n# Example usage:\nprint(is_woodall(7))  # [1, 7]\nprint(is_woodall(15)) # [1, 7]\nprint(is_woodall(31)) # [1, 7, 31]\nprint(is_woodall(100)) # [1, 7, 31, 63]\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp2zvr7lg3.py\", line 19, in <module>\n    assert is_woodall(15) == [1, 7, 15]\nAssertionError", "passed": false}
{"task_id": 21, "requirement": "Functionality Extension", "completion": "def multiples_of_num(n, m):\n    # Create an empty list to store the multiples\n    multiples = []\n    \n    # Loop to find and append the first m multiples of n\n    for i in range(1, m+1):\n        multiples.append(float(n) * i)\n    \n    return multiples\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpxo_ky5se.py\", line 8, in <module>\n    assert multiples_of_num(3, 2.5) == [2.5, 5.0, 7.5]\n  File \"/tmp/tmpxo_ky5se.py\", line 5, in multiples_of_num\n    for i in range(1, m+1):\nTypeError: 'float' object cannot be interpreted as an integer", "passed": false}
{"task_id": 22, "requirement": "Functionality Extension", "completion": "def find_first_duplicate(arr):\n    seen = set()\n    duplicates = []\n    for num in arr:\n        if num in seen and num not in duplicates:\n            duplicates.append(num)\n        seen.add(num)\n    return duplicates\n", "result": "passed", "passed": true}
{"task_id": 23, "requirement": "Functionality Extension", "completion": "def maximum_sum(list_of_lists):\n    # Initialize a variable to store the maximum sum\n    max_sum = float('-inf')\n    \n    # Iterate through each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # Update max_sum if the current sum is greater than the previous max_sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n    \n    return max_sum\n\n# Example usage:\nlist_of_lists = [[1, 2, 3], [4, 5, 6], [10, 11, -2]]\nprint(maximum_sum(list_of_lists))  # Output: 19\n\n# Additional test cases with negative integers\ntest_case_1 = [[-1, -2, -3], [-4, -5, -6], [-10, -11, 2]]\nprint(maximum_sum(test_case_1))  # Output: -8 (sum of [-10, -11, 2])\n\ntest_case_2 = [[-1, -2, -3], [0, 0, 0], [1, 2, 3]]\nprint(maximum_sum(test_case_2))  # Output: 6 (sum of [1, 2, 3])\n\ntest_case_3 = [[-100, -200], [-300, -400], [-500, -600, 1000]]\nprint(maximum_sum(test_case_3))  # Output: -100 (sum of [-500, -600, 1000])\n", "result": "passed", "passed": true}
{"task_id": 24, "requirement": "Functionality Extension", "completion": "def binary_to_decimal(binary):\n    # Initialize the decimal value to 0\n    decimal = 0\n    \n    # Reverse the binary string to process from least significant bit to most significant bit\n    binary = binary[::-1]\n    \n    # Iterate through each bit in the binary string\n    for i, bit in enumerate(binary):\n        # Convert the bit to an integer and multiply by 2 raised to the power of its position\n        decimal += int(bit) * (2 ** i)\n    \n    return decimal\n", "result": "passed", "passed": true}
{"task_id": 25, "requirement": "Functionality Extension", "completion": "def find_product(arr):\n    # Create a dictionary to store the frequency of each element\n    frequency = {}\n    for num in arr:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    \n    # Calculate the product of non-repeated elements\n    product = 1\n    has_non_repeated = False  # Flag to check if there's at least one non-repeated element\n    for num, count in frequency.items():\n        if count == 1:\n            product *= num\n            has_non_repeated = True\n    \n    # Return 1 if there are no non-repeated elements, otherwise return the product\n    return product if has_non_repeated else 1\n\n# Example usage with negative numbers\narr = [1, -2, 3, -2, 4, -5, -5]\nresult = find_product(arr)\nprint(result)  # Output: -12 (1 * 3 * 4)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpwq48vkkl.py\", line 22, in <module>\n    assert find_product([-1, -2, 3, 3], 4) == 2\nTypeError: find_product() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 26, "requirement": "Functionality Extension", "completion": "def check_k_elements(tuple_list, k):\n    count = 0\n    # Iterate through each tuple in the list\n    for tup in tuple_list:\n        # Check if the length of the tuple is equal to k\n        if len(tup) == k:\n            count += 1\n    \n    # Return whether all tuples have k elements and the count of such tuples\n    return len(tuple_list) == count, count\n\n# Example usage:\nsample_tuples = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\nk = 3\nall_have_k_elements, count = check_k_elements(sample_tuples, k)\nprint(\"All tuples have\", k, \"elements:\", all_have_k_elements, \"Count:\", count)  # Output: All tuples have 3 elements: True Count: 3\n\nsample_tuples2 = [(1, 2), (3, 4, 5), (6,)]\nk2 = 2\nall_have_k_elements2, count2 = check_k_elements(sample_tuples2, k2)\nprint(\"All tuples have\", k2, \"elements:\", all_have_k_elements2, \"Count:\", count2)  # Output: All tuples have 2 elements: False Count: 1\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp5rnwrqmu.py\", line 19, in <module>\n    assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == 1\nAssertionError", "passed": false}
{"task_id": 27, "requirement": "Functionality Extension", "completion": "def remove(list_of_strings, additional_chars=''):\n    # Create an empty list to store the modified strings\n    modified_strings = []\n    \n    # Create a set of characters to be removed (digits and additional characters)\n    chars_to_remove = set(additional_chars) | set('0123456789')\n    \n    # Iterate through each string in the list\n    for string in list_of_strings:\n        # Use a list comprehension to filter out unwanted characters from the string\n        filtered_string = ''.join([char for char in string if char not in chars_to_remove])\n        # Append the filtered string to the modified_strings list\n        modified_strings.append(filtered_string)\n    \n    # Return the list of modified strings\n    return modified_strings\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpqq8hwrn4.py\", line 14, in <module>\n    assert remove_extended(['abcd123', '456defg'], 'abcdef') == ['d', 'g']\nNameError: name 'remove_extended' is not defined", "passed": false}
{"task_id": 28, "requirement": "Functionality Extension", "completion": "def binomial_coeff(n, k):\n    # Base cases\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    # Initialize a list for storing intermediate results\n    C = [0] * (k + 1)\n    C[0] = 1  # C(n, 0) is 1 for any n\n    \n    # Calculate value of binomial coefficient in bottom-up manner\n    for i in range(1, n + 1):\n        # Compute next row of pascal triangle using the previous row\n        j = min(i, k)\n        while j > 0:\n            C[j] = C[j] + C[j - 1]\n            j -= 1\n    \n    return C[k]\n\n# Example usage:\nn = 50\nk = 25\nprint(f\"Binomial Coefficient C({n}, {k}) is {binomial_coeff(n, k)}\")\n", "result": "passed", "passed": true}
{"task_id": 29, "requirement": "Functionality Extension", "completion": "from typing import List\n\ndef get_odd_occurrence(arr: List[int], arr_size: int) -> List[int]:\n    # Dictionary to store counts of each element\n    count_dict = {}\n    \n    # Count occurrences of each element\n    for element in arr:\n        if element in count_dict:\n            count_dict[element] += 1\n        else:\n            count_dict[element] = 1\n    \n    # List to store elements with odd occurrences\n    odd_occurrences = []\n    \n    # Check for elements with odd occurrences\n    for key, value in count_dict.items():\n        if value % 2 != 0:\n            odd_occurrences.append(key)\n    \n    return odd_occurrences\n\n# Example usage\narr = [1, 2, 3, 2, 3, 1, 3, 4, 4, 4]\narr_size = len(arr)\nprint(get_odd_occurrence(arr, arr_size))  # Output: [3, 4]\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp5vltfgld.py\", line 22, in <module>\n    assert get_odd_occurrence([1, 2, 3, 1, 2, 3, 1, 3]) == [1, 3]\nTypeError: get_odd_occurrence() missing 1 required positional argument: 'arr_size'", "passed": false}
{"task_id": 30, "requirement": "Functionality Extension", "completion": "def count_substring_with_equal_ends(s):\n    \"\"\"\n    Count all substrings of the input string that start and end with the same alphabetic character.\n\n    :param s: str - The input string\n    :return: int - The count of substrings with equal start and end alphabetic characters\n    \"\"\"\n    count = 0\n    n = len(s)\n    \n    # Iterate over each character in the string\n    for i in range(n):\n        # Only consider alphabetic characters as starting points\n        if s[i].isalpha():\n            # Check substrings starting from the current character\n            for j in range(i, n):\n                # Only consider alphabetic characters as ending points\n                if s[j].isalpha() and s[i] == s[j]:\n                    count += 1\n    \n    return count\n\n# Example usage:\ninput_string = \"a1b c!abc a\"\nresult = count_substring_with_equal_ends(input_string)\nprint(f\"Number of substrings starting and ending with the same alphabetic character: {result}\")\n", "result": "passed", "passed": true}
{"task_id": 31, "requirement": "Functionality Extension", "completion": "import heapq\nfrom collections import defaultdict\n\ndef func(lists, k):\n    # If k is zero, return an empty list immediately\n    if k == 0:\n        return []\n    \n    # Create a dictionary to count the frequency of each integer\n    frequency = defaultdict(int)\n    \n    # Count the frequency of each integer in all lists\n    for lst in lists:\n        for num in lst:\n            frequency[num] += 1\n    \n    # Use a heap to find the top k integers with the highest frequency\n    # We use a min-heap, so we store negative frequencies to simulate a max-heap\n    heap = []\n    for num, freq in frequency.items():\n        heapq.heappush(heap, (-freq, num))\n        if len(heap) > k:\n            heapq.heappop(heap)\n    \n    # Extract the top k integers from the heap\n    top_k = []\n    while heap:\n        freq, num = heapq.heappop(heap)\n        top_k.append(num)\n    \n    # Since we want the result in descending order of frequency, reverse the list\n    return top_k[::-1]\n\n# Example usage:\nlists = [[1, 3, 5], [1, 2, 4], [1, 2, 3]]\nk = 2\nprint(func(lists, k))  # Output: [1, 2]\n\nk = 0\nprint(func(lists, k))  # Output: []\n", "result": "passed", "passed": true}
{"task_id": 32, "requirement": "Functionality Extension", "completion": "def max_prime_factors(n, return_all=False):\n    # Initialize the list to store prime factors\n    prime_factors = []\n    \n    # Check for number of 2s that divide n\n    while n % 2 == 0:\n        prime_factors.append(2)\n        n >>= 1  # equivalent to n //= 2\n    \n    # n must be odd at this point, thus skip even numbers and iterate only for odd integers\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            prime_factors.append(i)\n            n = n // i\n    \n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        prime_factors.append(n)\n    \n    if return_all:\n        return prime_factors\n    else:\n        return max(prime_factors) if prime_factors else None\n\n# Example usage\nnumber = 315\nprint(f\"All prime factors of {number} are {max_prime_factors(number, return_all=True)}\")\nprint(f\"The largest prime factor of {number} is {max_prime_factors(number)}\")\n", "result": "passed", "passed": true}
{"task_id": 33, "requirement": "Functionality Extension", "completion": "def decimal_to_binary(decimals):\n    def convert_to_binary(decimal):\n        if decimal == 0:\n            return \"0\"\n        binary = \"\"\n        while decimal > 0:\n            binary = str(decimal % 2) + binary\n            decimal = decimal // 2\n        return binary\n    \n    if isinstance(decimals, list):\n        return [convert_to_binary(decimal) for decimal in decimals]\n    else:\n        return convert_to_binary(decimals)\n", "result": "passed", "passed": true}
{"task_id": 34, "requirement": "Functionality Extension", "completion": "def find_missing(arr):\n    missing_numbers = []\n    expected_number = arr[0]\n    \n    for number in arr:\n        while number != expected_number:\n            missing_numbers.append(expected_number)\n            expected_number += 1\n        expected_number += 1\n    \n    return missing_numbers\n\n# Example usage:\narr = [1, 2, 4, 7, 8, 10]\nmissing_numbers = find_missing(arr)\nprint(\"The missing numbers are:\", missing_numbers)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpb8y_olzn.py\", line 14, in <module>\n    assert find_missing([1,3,6], 3) == [2, 4, 5]\nTypeError: find_missing() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 35, "requirement": "Functionality Extension", "completion": "def find_rect_num(numbers):\n    if not all(isinstance(n, int) and n >= 0 for n in numbers):\n        return \"Invalid input: all elements must be non-negative integers\"\n    \n    return [n * (n + 1) for n in numbers]\n\n# Example usage:\nnumbers = [0, 1, 2, 5, 10]\nresults = find_rect_num(numbers)\nprint(f\"Rectangular numbers for {numbers} are: {results}\")\n", "result": "passed", "passed": true}
{"task_id": 36, "requirement": "Functionality Extension", "completion": "def find_nth_digit(numerator, denominator, n):\n    # Check if the denominator is zero\n    if denominator == 0:\n        raise ValueError(\"Denominator cannot be zero\")\n    \n    # Use absolute values to handle negative numerators and denominators\n    numerator = abs(numerator)\n    denominator = abs(denominator)\n    \n    # Initialize the remainder\n    remainder = numerator % denominator\n    \n    # Loop to find the nth digit\n    for i in range(n):\n        # Multiply the remainder by 10\n        remainder *= 10\n        # Get the digit\n        digit = remainder // denominator\n        # Update the remainder\n        remainder = remainder % denominator\n    \n    return digit\n\n# Example usage:\nnumerator = -1\ndenominator = 7\nn = 5\nprint(f\"The {n}th digit in the decimal representation of the absolute value of {numerator}/{denominator} is {find_nth_digit(numerator, denominator, n)}\")\n", "result": "passed", "passed": true}
{"task_id": 37, "requirement": "Functionality Extension", "completion": "def sort_mixed_list(mixed_list, reverse_strings=False):\n    # Separate integers and strings into two different lists\n    int_list = [item for item in mixed_list if isinstance(item, int)]\n    str_list = [item for item in mixed_list if isinstance(item, str)]\n    \n    # Sort the integer list and string list\n    int_list.sort()\n    str_list.sort(reverse=reverse_strings)\n    \n    # Combine the sorted lists\n    sorted_list = int_list + str_list\n    \n    return sorted_list\n\n# Example usage:\nmixed_list = [3, \"apple\", 1, \"banana\", 2, \"cherry\"]\nsorted_list = sort_mixed_list(mixed_list)\nprint(sorted_list)  # Output: [1, 2, 3, 'apple', 'banana', 'cherry']\n\n# Example usage with reverse_strings=True\nsorted_list_reverse = sort_mixed_list(mixed_list, reverse_strings=True)\nprint(sorted_list_reverse)  # Output: [1, 2, 3, 'cherry', 'banana', 'apple']\n", "result": "passed", "passed": true}
{"task_id": 38, "requirement": "Functionality Extension", "completion": "def div_even_odd(numbers):\n    even = None\n    odd = None\n    \n    # Loop through the list to find the first even and odd numbers\n    for num in numbers:\n        if num % 2 == 0 and even is None:\n            even = num\n        if num % 2 != 0 and odd is None:\n            odd = num\n        \n        # If both even and odd numbers are found, break the loop\n        if even is not None and odd is not None:\n            break\n    \n    # Check if both even and odd numbers were found\n    if even is None or odd is None:\n        return \"List must contain at least one even and one odd number.\"\n    \n    # Perform the division\n    return even / odd\n\n# Example usage with negative numbers:\nnumbers = [-4, -3, 2, 5, 7]\nresult = div_even_odd(numbers)\nprint(result)  # Output: -4 / -3 = 1.3333333333333333\n", "result": "passed", "passed": true}
{"task_id": 39, "requirement": "Functionality Extension", "completion": "from collections import Counter\n\ndef rearrange_string(s):\n    def backtrack(current_string, char_count):\n        # If the current string length matches the input string length, add to results\n        if len(current_string) == len(s):\n            results.append(\"\".join(current_string))\n            return\n        \n        for char in list(char_count.keys()):\n            if char_count[char] > 0 and (not current_string or current_string[-1] != char):\n                # Choose the character if it's not the same as the last one in the current string\n                current_string.append(char)\n                char_count[char] -= 1\n                \n                # Recurse\n                backtrack(current_string, char_count)\n                \n                # Undo the choice\n                current_string.pop()\n                char_count[char] += 1\n    \n    char_count = Counter(s)\n    results = []\n    backtrack([], char_count)\n    \n    if not results:\n        return \"Not possible to rearrange\"\n    return results\n\n# Example usage:\nprint(rearrange_string(\"aab\"))\nprint(rearrange_string(\"aaab\"))\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpx4_1i4fg.py\", line 27, in <module>\n    assert set(rearange_string('aabb')) == {'abab', 'baba'}\nNameError: name 'rearange_string' is not defined", "passed": false}
{"task_id": 40, "requirement": "Functionality Extension", "completion": "from collections import Counter\n\ndef flatten_list(nested_list):\n    # Helper function to flatten the list\n    flat_list = []\n    for item in nested_list:\n        if isinstance(item, list):\n            # Recursively flatten the list\n            flat_list.extend(flatten_list(item))\n        else:\n            flat_list.append(item)\n    return flat_list\n\ndef freq_element(list_of_lists):\n    # Flatten the nested list of arbitrary depth\n    flat_list = flatten_list(list_of_lists)\n    \n    # Use Counter to count the frequency of each element\n    frequency = Counter(flat_list)\n    \n    return frequency\n\n# Example usage:\nnested_list = [[1, 2, [3]], [2, [3, 4]], [3, [4, [5]]]]\nresult = freq_element(nested_list)\nprint(result)  # Output: Counter({3: 3, 2: 2, 4: 2, 1: 1, 5: 1})\n", "result": "passed", "passed": true}
{"task_id": 41, "requirement": "Functionality Extension", "completion": "def filter_evennumbers(numbers):\n    # Filter out non-integer types\n    integer_numbers = list(filter(lambda x: isinstance(x, int), numbers))\n    # Filter even numbers from the list of integers\n    even_numbers = list(filter(lambda x: x % 2 == 0, integer_numbers))\n    return even_numbers\n\n# Example usage:\nmixed_list = [1, 2, 3.5, '4', 5, 6, 7, 8, 9.0, 10, 'hello']\nresult = filter_evennumbers(mixed_list)\nprint(result)  # Output: [2, 6, 8, 10]\n", "result": "passed", "passed": true}
{"task_id": 42, "requirement": "Functionality Extension", "completion": "def find_sum(arr):\n    # Create a dictionary to store the frequency of each element\n    frequency = {}\n    for num in arr:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    \n    # Calculate the sum of elements that appear more than once\n    sum_repeated = 0\n    for num, count in frequency.items():\n        if count > 1:\n            sum_repeated += num * count\n    \n    return sum_repeated\n\n# Example usage:\narr = [1, 2, 3, 2, 3, 4, 5, 3, -1, -1, -2, -2, -2]\nresult = find_sum(arr)\nprint(\"Sum of repeated elements:\", result)  # Output: 13 (2*2 + 3*3) + (-1*-1) + (-2*-2*-2) = 13 + 2 + (-6) = 9\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpwjy979d8.py\", line 19, in <module>\n    assert find_sum([-1, -2, -3, -1, -1], 5) == -2\nTypeError: find_sum() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 43, "requirement": "Functionality Extension", "completion": "import re\n\ndef text_match(text):\n    pattern = r'\\b[a-z]+(?:_+[a-z]+)+\\b'\n    matches = re.findall(pattern, text)\n    return matches\n\n# Example usage:\ntext = \"Here are some examples: first_example, second__example, another___one\"\nresult = text_match(text)\nprint(result)  # Output: ['first_example', 'second__example', 'another___one']\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpag5msx6a.py\", line 10, in <module>\n    assert text_match('abc_def_ghi') == 'Found a match!'\nAssertionError", "passed": false}
{"task_id": 45, "requirement": "Functionality Extension", "completion": "from functools import reduce\nimport math\n\ndef get_gcd(arr):\n    def gcd(x, y):\n        while y != 0:\n            (x, y) = (y, x % y)\n        return x\n    \n    # Filter out zero values\n    filtered_arr = [num for num in arr if num != 0]\n    \n    # If all elements were zero, return 0 as GCD\n    if not filtered_arr:\n        return 0\n    \n    return reduce(gcd, filtered_arr)\n\n# Example usage:\narr = [0, 24, 36, 48, 0]\nresult = get_gcd(arr)\nprint(f\"The GCD of the non-zero elements in the array {arr} is {result}\")\n", "result": "passed", "passed": true}
{"task_id": 46, "requirement": "Functionality Extension", "completion": "def test_distinct(numbers):\n    \"\"\"\n    Check if all numbers in the list, including floating-point numbers, are distinct.\n\n    Args:\n    numbers (list): A list of numbers (integers or floats).\n\n    Returns:\n    bool: True if all numbers are distinct, False otherwise.\n    \"\"\"\n    return len(numbers) == len(set(numbers))\n\n# Example usage:\nnumbers_int = [1, 2, 3, 4, 5]\nprint(test_distinct(numbers_int))  # Output: True\n\nnumbers_float = [1.1, 2.2, 3.3, 4.4, 5.5]\nprint(test_distinct(numbers_float))  # Output: True\n\nmixed_numbers = [1, 2.2, 3, 4.4, 5]\nprint(test_distinct(mixed_numbers))  # Output: True\n\nnumbers_with_duplicates = [1.1, 2.2, 3.3, 3.3, 4.4]\nprint(test_distinct(numbers_with_duplicates))  # Output: False\n", "result": "passed", "passed": true}
{"task_id": 47, "requirement": "Functionality Extension", "completion": "def compute_last_digit(a, b):\n    if a > b:\n        return 0  # factorial(b) can never divide factorial(a) if a > b\n    if a == 0 or b == 0:\n        return 1  # factorial(0) is 1, and any number divided by 1 is itself, last digit of 1 is 1\n    \n    # Calculate factorial(b) // factorial(a)\n    result = 1\n    for i in range(a + 1, b + 1):\n        result *= i\n    \n    # Get the last digit\n    last_digit = result % 10\n    return last_digit\n\n# Example usage:\nprint(compute_last_digit(0, 5))  # Output: 1\nprint(compute_last_digit(3, 0))  # Output: 1\nprint(compute_last_digit(3, 5))  # Output: 2 (since 5! // 3! = 20 and last digit of 20 is 0)\nprint(compute_last_digit(4, 10)) # Output: 8 (since 10! // 4! = 151200 and last digit of 151200 is 0)\n", "result": "passed", "passed": true}
{"task_id": 48, "requirement": "Functionality Extension", "completion": "def odd_bit_set_number(num):\n    # Take the absolute value of the input number\n    abs_num = abs(num)\n    \n    # Initialize a mask with all odd bits set to 1\n    mask = 0xAAAAAAAA\n    \n    # Set all odd bits of the absolute value using bitwise OR operation\n    result = abs_num | mask\n    \n    return result\n\n# Example usage\nnumber = -10  # Binary representation of 10: 1010\nresult = odd_bit_set_number(number)\nprint(f\"Original number: {number}, Absolute Binary: {bin(abs(number))}\")\nprint(f\"Number with odd bits set: {result}, Binary: {bin(result)}\")\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmps7i0hh33.py\", line 14, in <module>\n    assert odd_bit_set_number(-10) == 15\nAssertionError", "passed": false}
{"task_id": 49, "requirement": "Functionality Extension", "completion": "def specified_element(matrix, index=0):\n    \"\"\"\n    Extracts the specified element from each sub-list in a two-dimensional list, supporting negative indices.\n    \n    :param matrix: A two-dimensional list (list of lists)\n    :param index: The index of the element to extract from each sub-list (default is 0). Supports negative indices.\n    :return: A list containing the extracted elements\n    \"\"\"\n    # Check if the matrix is empty\n    if not matrix:\n        return []\n    \n    # Initialize an empty list to store the extracted elements\n    extracted_elements = []\n    \n    # Iterate through each sub-list in the matrix\n    for sublist in matrix:\n        # Check if the sublist is long enough to have the specified index\n        if len(sublist) > abs(index) if index < 0 else index:\n            # Append the element at the specified index to the extracted_elements list\n            extracted_elements.append(sublist[index])\n        else:\n            # If the sublist is too short, append None or handle it as needed\n            extracted_elements.append(None)\n    \n    return extracted_elements\n\n# Example usage:\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]\nprint(specified_element(matrix))  # Output: [1, 4, 7, 10]\nprint(specified_element(matrix, 1))  # Output: [2, 5, 8, None]\nprint(specified_element(matrix, -1))  # Output: [3, 6, 9, 10]\nprint(specified_element(matrix, -2))  # Output: [2, 5, 8, None]\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmprl713tzo.py\", line 20, in <module>\n    print(specified_element(matrix, 1))  # Output: [2, 5, 8, None]\n  File \"/tmp/tmprl713tzo.py\", line 12, in specified_element\n    extracted_elements.append(sublist[index])\nIndexError: list index out of range", "passed": false}
{"task_id": 51, "requirement": "Functionality Extension", "completion": "def check_triangle_type(side1, side2, side3):\n    if side1 == side2 == side3:\n        print(\"The triangle is equilateral.\")\n    elif side1 == side2 or side2 == side3 or side1 == side3:\n        print(\"The triangle is isosceles.\")\n    else:\n        print(\"The triangle is scalene.\")\n\n# Example usage:\ncheck_triangle_type(5, 5, 5)  # Output: The triangle is equilateral.\ncheck_triangle_type(5, 5, 3)  # Output: The triangle is isosceles.\ncheck_triangle_type(3, 4, 5)  # Output: The triangle is scalene.\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpi5n193ti.py\", line 12, in <module>\n    assert check_equilateral(5, 5, 3) == 'isosceles'\nNameError: name 'check_equilateral' is not defined", "passed": false}
{"task_id": 52, "requirement": "Functionality Extension", "completion": "def parallelogram_area(pairs):\n    \"\"\"\n    Calculate the areas of multiple parallelograms.\n\n    Parameters:\n    pairs (list of tuples): A list where each tuple contains the base and height of a parallelogram.\n\n    Returns:\n    list: A list of areas of the parallelograms.\n    \"\"\"\n    areas = []\n    for base, height in pairs:\n        area = base * height\n        areas.append(area)\n    return areas\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpmo7p7328.py\", line 7, in <module>\n    assert parallelogram_area_list([(10, 20), (15, 20), (8, 9)]) == [200, 300, 72]\nNameError: name 'parallelogram_area_list' is not defined", "passed": false}
{"task_id": 53, "requirement": "Functionality Extension", "completion": "def check_equality(s):\n    if len(s) < 1:\n        return False\n    return s[0].lower() == s[-1].lower()\n\n# Example usage:\nresult = check_equality(\"Hello\")\nprint(result)  # Output: True\n\nresult = check_equality(\"radar\")\nprint(result)  # Output: True\n\nresult = check_equality(\"Python\")\nprint(result)  # Output: False\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpdk5dm6oa.py\", line 12, in <module>\n    assert check_equality('Abca') == 'Equal'\nAssertionError", "passed": false}
{"task_id": 54, "requirement": "Functionality Extension", "completion": "def counting_sort(arr):\n    # Find the maximum and minimum elements in the array\n    max_val = max(arr)\n    min_val = min(arr)\n    \n    # Adjust the range of the count array to include negative values\n    range_of_elements = max_val - min_val + 1\n    count = [0] * range_of_elements\n    \n    # Store the count of each element in the count array\n    for num in arr:\n        count[num - min_val] += 1\n    \n    # Modify the count array by adding the previous counts\n    for i in range(1, len(count)):\n        count[i] += count[i - 1]\n    \n    # Create an output array to store the sorted elements\n    output = [0] * len(arr)\n    \n    # Build the output array using the count array\n    for num in reversed(arr):\n        output[count[num - min_val] - 1] = num\n        count[num - min_val] -= 1\n    \n    # Copy the sorted elements back to the original array\n    for i in range(len(arr)):\n        arr[i] = output[i]\n\n    return arr\n\n# Example usage:\narr = [-5, -10, 0, -3, 8, 5, -1, 10]\nsorted_arr = counting_sort(arr)\nprint(sorted_arr)\n", "result": "passed", "passed": true}
{"task_id": 55, "requirement": "Functionality Extension", "completion": "def tn_gp(a, r, t):\n    \"\"\"\n    Calculate the t-nth term of a geometric series.\n    \n    Parameters:\n        a (float): The first term of the geometric series, can be a floating-point number.\n        r (float): The common ratio of the geometric series, can be a floating-point number.\n        t (int): The term number to find.\n        \n    Returns:\n        float: The t-nth term of the geometric series, will be a floating-point number.\n    \"\"\"\n    return a * (r ** (t - 1))\n\n# Example usage with floating-point numbers:\nfirst_term = 2.5\ncommon_ratio = 1.5\nterm_number = 5\nresult = tn_gp(first_term, common_ratio, term_number)\nprint(f\"The {term_number}-th term of the geometric series is: {result}\")\n", "result": "passed", "passed": true}
{"task_id": 56, "requirement": "Functionality Extension", "completion": "def check(number):\n    # Check if the number is negative\n    is_negative = number < 0\n    \n    # Convert the number to a string and remove the negative sign if present\n    number_str = str(abs(number))\n    \n    # Reverse the number string\n    reversed_number_str = number_str[::-1]\n    \n    # Convert the reversed string back to an integer\n    reversed_number = int(reversed_number_str)\n    \n    # If the original number was negative, make the reversed number negative\n    if is_negative:\n        reversed_number = -reversed_number\n    \n    # Calculate twice the reversed number\n    twice_reversed = 2 * reversed_number\n    \n    # Check if the given number is one less than twice its reverse\n    return number == twice_reversed - 1\n\n# Example usage:\npositive_number = 17\nnegative_number = -17\nprint(f\"Is {positive_number} one less than twice its reverse? {check(positive_number)}\")\nprint(f\"Is {negative_number} one less than twice its reverse? {check(negative_number)}\")\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpwekbei00.py\", line 23, in <module>\n    assert check(-37) == True\nAssertionError", "passed": false}
{"task_id": 57, "requirement": "Functionality Extension", "completion": "def find_max_num(digits):\n    # Convert each integer in the list to a string\n    str_digits = [str(digit) for digit in digits]\n    \n    # Sort the string digits in descending order\n    sorted_digits = sorted(str_digits, reverse=True)\n    \n    # Join the sorted digits into a single string\n    max_num_str = ''.join(sorted_digits)\n    \n    # Convert the string back to an integer\n    max_num = int(max_num_str)\n    \n    return max_num\n\n# Example usage with duplicate numbers:\ndigits = [3, 3, 5, 5, 9, 9]\nresult = find_max_num(digits)\nprint(\"The largest number that can be formed is:\", result)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpiydl0pzk.py\", line 15, in <module>\n    assert find_max_num([1, 1, 2, 2], 4) == 2211\nTypeError: find_max_num() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 58, "requirement": "Functionality Extension", "completion": "def opposite_signs(pairs):\n    results = []\n    for x, y in pairs:\n        results.append((x < 0 and y > 0) or (x > 0 and y < 0))\n    return results\n\n# Example usage:\npairs = [(-5, 10), (15, 20), (-3, -7), (8, -12)]\nprint(opposite_signs(pairs))  # Output: [True, False, False, True]\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpzqlnwsf2.py\", line 9, in <module>\n    assert opposite_signs_list([(1, -2), (3, 2), (-10, -10)]) == [True, False, False]\nNameError: name 'opposite_signs_list' is not defined", "passed": false}
{"task_id": 59, "requirement": "Functionality Extension", "completion": "def is_octagonal(n):\n    def calculate_octagonal(x):\n        return x * (3 * x - 2)\n    \n    if isinstance(n, int):\n        if n < 1:\n            return \"Input should be a positive integer\"\n        return calculate_octagonal(n)\n    elif isinstance(n, list):\n        return [calculate_octagonal(x) for x in n if isinstance(x, int) and x > 0]\n    else:\n        return \"Input should be either an integer or a list of integers\"\n\n# Example usage:\nsingle_octagonal = is_octagonal(5)\nprint(f\"The 5th octagonal number is: {single_octagonal}\")\n\nlist_of_octagonals = is_octagonal([1, 2, 3, 4, 5])\nprint(f\"The first 5 octagonal numbers are: {list_of_octagonals}\")\n", "result": "passed", "passed": true}
{"task_id": 60, "requirement": "Functionality Extension", "completion": "def max_len_sub(arr):\n    if not arr:\n        return 0\n    \n    # Dictionary to store the length of subsequence ending with each element\n    subseq_length = {}\n    \n    # Initialize the dictionary with 1 for each element\n    for num in arr:\n        subseq_length[num] = 1\n    \n    # Iterate through the array to build the subsequence lengths\n    for num in arr:\n        # Check if there's a subsequence ending with num-1\n        if num - 1 in subseq_length:\n            subseq_length[num] = max(subseq_length[num], subseq_length[num - 1] + 1)\n        # Check if there's a subsequence ending with num+1\n        if num + 1 in subseq_length:\n            subseq_length[num + 1] = max(subseq_length[num + 1], subseq_length[num] + 1)\n    \n    # The maximum length of subsequence with difference of 1 between adjacent elements\n    return max(subseq_length.values())\n\n# Example usage\narr = [1, 2, 3, 4, 5, 3, 2, 1]\nprint(max_len_sub(arr))  # Output: 5 (subsequence: [1, 2, 3, 2, 1])\n\narr2 = [10, 9, 8, 7, 6, 7, 8, 9, 10]\nprint(max_len_sub(arr2))  # Output: 9 (subsequence: [10, 9, 8, 7, 6, 7, 8, 9, 10])\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpuafwp2ou.py\", line 24, in <module>\n    assert max_len_sub([10, 7, 4, 1, -2], -3) == 5\nTypeError: max_len_sub() takes 1 positional argument but 2 were given", "passed": false}
