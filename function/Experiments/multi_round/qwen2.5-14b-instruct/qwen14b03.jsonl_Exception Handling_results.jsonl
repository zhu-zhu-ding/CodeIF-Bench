{"task_id": 11, "requirement": "Exception Handling", "completion": "def remove_occ(s, char):\n    \"\"\"\n    Removes the first and last occurrences of a given character from the string.\n\n    :param s: The original string.\n    :param char: The character to be removed.\n    :return: A new string with the first and last occurrences of the character removed.\n    \"\"\"\n    if len(char) != 1:\n        raise ValueError('Second parameter must be a single character.')\n\n    # Find the indices of the first and last occurrences of the character\n    try:\n        first_occurrence = s.index(char)\n        last_occurrence = s.rindex(char)\n    except ValueError:\n        # If the character is not found, return the original string\n        return s\n    \n    # Construct the new string without the first and last occurrences\n    new_string = s[:first_occurrence] + s[first_occurrence+1:last_occurrence] + s[last_occurrence+1:]\n    \n    return new_string\n\n# Example usage\nif __name__ == \"__main__\":\n    test_string = \"hello world\"\n    char_to_remove = \"l\"\n    print(remove_occ(test_string, char_to_remove))  # Output: \"heo word\"\n", "result": "passed", "passed": true}
{"task_id": 12, "requirement": "Exception Handling", "completion": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order based on the sum of its rows.\n    Raises a TypeError if input is invalid.\n    \n    Parameters:\n    - matrix (list of lists): The matrix to be sorted.\n    \n    Returns:\n    - list of lists: The sorted matrix.\n    \"\"\"\n    # Check if the input is a list\n    if not isinstance(matrix, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    # Validate that each element of the matrix is a list\n    if not all(isinstance(row, list) for row in matrix):\n        raise TypeError(\"Each element of the matrix must be a list.\")\n    \n    # Validate that all elements in the matrix are integers\n    for row in matrix:\n        if not all(isinstance(element, int) for element in row):\n            raise TypeError(\"All elements in the matrix must be integers.\")\n    \n    # Calculate the sum of each row and pair it with the row itself\n    summed_rows = [(sum(row), row) for row in matrix]\n    \n    # Sort the list of tuples based on the first element (the sum)\n    sorted_summed_rows = sorted(summed_rows)\n\n    # Extract the rows from the sorted list of tuples\n    sorted_matrix = [row for _, row in sorted_summed_rows]\n\n    return sorted_matrix\n\n# Example usage:\nif __name__ == \"__main__\":\n    example_matrix = [\n        [3, 4, 5],\n        [1, 2],\n        [6, 7, 8, 9],\n        [0]\n    ]\n    print(\"Original Matrix:\")\n    for row in example_matrix:\n        print(row)\n    \n    try:\n        sorted_matrix = sort_matrix(example_matrix)\n        print(\"\\nSorted Matrix:\")\n        for row in sorted_matrix:\n            print(row)\n    except TypeError as e:\n        print(f\"Error: {e}\")\n", "result": "passed", "passed": true}
{"task_id": 13, "requirement": "Exception Handling", "completion": "def count_common(words):\n    \"\"\"\n    This function takes a list of strings, counts the frequency of each word,\n    and returns the most common word(s) and their counts. It raises a TypeError\n    if the input is not a list of strings.\n    \n    :param words: A list of strings representing words.\n    :return: A tuple containing two lists: the first list contains the most common words,\n             and the second list contains their respective counts.\n    \"\"\"\n    if not isinstance(words, list) or not all(isinstance(word, str) for word in words):\n        raise TypeError(\"Input must be a list of strings\")\n\n    # Count the frequency of each word\n    from collections import Counter\n    word_counts = Counter(words)\n\n    # Find the maximum count\n    max_count = max(word_counts.values())\n\n    # Find all words that have the maximum count\n    most_common_words = [word for word, count in word_counts.items() if count == max_count]\n    most_common_counts = [max_count] * len(most_common_words)\n\n    return (most_common_words, most_common_counts)\n\n# Example usage:\nwords_example = ['apple', 'banana', 'apple', 'cherry', 'apple', 'date']\nprint(count_common(words_example))\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpxz3wdggk.py\", line 16, in <module>\n    assert count_common(['red','green','black','pink','black','white','black','eyes','white','black','orange','pink','pink','red','red','white','orange','white',\"black\",'pink','green','green','pink','green','pink','white','orange',\"orange\",'red']) == [('pink', 6), ('black', 5), ('white', 5), ('red', 4)]\nAssertionError", "passed": false}
{"task_id": 14, "requirement": "Exception Handling", "completion": "def find_volume(base, height_triangle, length_prism):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Parameters:\n    - base (float): The base length of the triangular face.\n    - height_triangle (float): The height of the triangular face.\n    - length_prism (float): The length of the prism.\n    \n    Returns:\n    float: The volume of the triangular prism.\n    \n    Raises:\n    ValueError: If any of the dimensions are non-positive or non-numeric.\n    \"\"\"\n    # Check if all inputs are numeric\n    if not all(isinstance(dim, (int, float)) for dim in [base, height_triangle, length_prism]):\n        raise ValueError(\"All dimensions must be numeric.\")\n        \n    # Check if all inputs are positive\n    if base <= 0 or height_triangle <= 0 or length_prism <= 0:\n        raise ValueError(\"All dimensions must be positive numbers.\")\n    \n    # Calculate the area of the triangular base\n    base_area = 0.5 * base * height_triangle\n    \n    # Calculate the volume of the triangular prism\n    volume = base_area * length_prism\n    \n    return volume\n\n# Example usage:\ntry:\n    volume = find_volume(4, 3, 10)\n    print(f\"The volume of the triangular prism is {volume} cubic units.\")\nexcept ValueError as e:\n    print(e)\n\n# Test cases to demonstrate error handling\ntry:\n    find_volume(-4, 3, 10)\nexcept ValueError as e:\n    print(e)  # Should output \"All dimensions must be positive numbers.\"\n\ntry:\n    find_volume(4, \"three\", 10)\nexcept ValueError as e:\n    print(e)  # Should output \"All dimensions must be numeric.\"\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp3l_kw3np.py\", line 34, in <module>\n    try: find_volume('a', 2, 3)\n  File \"/tmp/tmp3l_kw3np.py\", line 4, in find_volume\n    raise ValueError(\"All dimensions must be numeric.\")\nValueError: All dimensions must be numeric.\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp3l_kw3np.py\", line 35, in <module>\n    except ValueError as e: assert str(e) == 'All dimensions must be positive numbers.'\nAssertionError", "passed": false}
{"task_id": 15, "requirement": "Exception Handling", "completion": "import re\n\ndef split_lowerstring(input_string):\n    # Check if the input is a string\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Use regex to match each lowercase letter as a split point\n    pattern = r'(?<=[a-z])(?![a-z])'\n    \n    # Split the string using the found patterns\n    split_strings = re.split(pattern, input_string)\n    \n    # Filter out empty strings if there are any\n    non_empty_strings = [s for s in split_strings if s]\n    \n    return non_empty_strings\n\n# Example usage\ntry:\n    print(split_lowerstring(\"aBcDeFgHiJkLmNoPqRsTuVwXyZ\"))  # Expected output: ['a', 'B', 'c', 'D', 'e', 'F', 'g', 'H', 'i', 'J', 'k', 'L', 'm', 'N', 'o', 'P', 'q', 'R', 's', 'T', 'u', 'V', 'w', 'X', 'y', 'Z']\n    print(split_lowerstring(12345))  # Should raise a TypeError\nexcept TypeError as e:\n    print(e)  # Output: Input must be a string\n", "result": "failed: File \"/tmp/tmpihdzamba.py\", line 22\n    try: split_lowerstring(123); assert False, 'Expected TypeError' except TypeError: pass\n                                                                    ^\nSyntaxError: invalid syntax", "passed": false}
{"task_id": 16, "requirement": "Exception Handling", "completion": "import re\n\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Finds all sequences of lowercase letters joined with an underscore in the given text.\n\n    :param text: A string containing the text to search within.\n    :return: A list of strings that match the pattern.\n    :raises TypeError: If the input is not a string.\n    \"\"\"\n    # Check if the input is a string\n    if not isinstance(text, str):\n        raise TypeError(\"Input must be a string\")\n\n    # Define the regex pattern for finding sequences of lowercase letters joined with an underscore\n    pattern = r\"([a-z]+_[a-z]+)\"\n\n    # Use re.findall to find all occurrences of the pattern in the text\n    matches = re.findall(pattern, text)\n\n    return matches\n\n# Example usage:\ntry:\n    example_text = \"This_is_an_example_text_with_lower_case_words_and_this_one_is_special\"\n    print(text_lowercase_underscore(example_text))\nexcept TypeError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp1r_4_g6g.py\", line 17, in <module>\n    assert text_lowercase_underscore(\"aab_cbbbc\")==('Found a match!')\nAssertionError", "passed": false}
{"task_id": 17, "requirement": "Exception Handling", "completion": "def square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square.\n    \n    :param side_length: The length of one side of the square.\n    :return: The perimeter of the square.\n    :raises ValueError: If the side_length is negative.\n    \"\"\"\n    if side_length < 0:\n        raise ValueError(\"Side length cannot be negative\")\n    return 4 * side_length\n\n# Example usage:\ntry:\n    perimeter = square_perimeter(5)\n    print(\"The perimeter of the square is:\", perimeter)\nexcept ValueError as e:\n    print(e)\n\n# Testing with a negative value\ntry:\n    perimeter = square_perimeter(-3)\n    print(\"The perimeter of the square is:\", perimeter)\nexcept ValueError as e:\n    print(e)\n", "result": "passed", "passed": true}
{"task_id": 18, "requirement": "Exception Handling", "completion": "def remove_dirty_chars(main_string, chars_to_remove):\n    \"\"\"\n    Removes characters from main_string that are present in chars_to_remove.\n    \n    Parameters:\n    - main_string (str): The original string from which characters will be removed.\n    - chars_to_remove (str): The string containing characters to be removed from main_string.\n    \n    Raises:\n    - TypeError: If either main_string or chars_to_remove is not a string.\n    \n    Returns:\n    - str: The modified string after removing specified characters.\n    \"\"\"\n    # Check if both inputs are strings\n    if not isinstance(main_string, str) or not isinstance(chars_to_remove, str):\n        raise TypeError(\"Both main_string and chars_to_remove must be strings.\")\n    \n    # Create a set of characters to remove for faster lookup\n    chars_set = set(chars_to_remove)\n    \n    # Filter out unwanted characters\n    filtered_string = ''.join(char for char in main_string if char not in chars_set)\n    \n    return filtered_string\n\n# Example usage:\ntry:\n    original_str = \"Hello, World!\"\n    chars_to_remove = \"Helo\"\n    cleaned_str = remove_dirty_chars(original_str, chars_to_remove)\n    print(cleaned_str)  # Output should be \", Wrd!\"\nexcept TypeError as e:\n    print(e)\n", "result": "passed", "passed": true}
{"task_id": 19, "requirement": "Exception Handling", "completion": "def test_duplicate(arr):\n    \"\"\"\n    Check if the given list contains any duplicate elements.\n\n    :param arr: List of integers\n    :return: True if there are duplicates, False otherwise\n    :raises ValueError: If the input is not a list or if elements are not all integers\n    \"\"\"\n    if not isinstance(arr, list):\n        raise ValueError('Input must be a list')\n    \n    for item in arr:\n        if not isinstance(item, int):\n            raise ValueError('All elements in the list must be integers')\n\n    seen = set()\n    for number in arr:\n        if number in seen:\n            return True\n        seen.add(number)\n    return False\n\n# Example usage:\ntry:\n    print(test_duplicate([1, 2, 3, 4, 5, 2]))  # Output: True\n    print(test_duplicate([10, 22, 33, 44, 55]))  # Output: False\n    print(test_duplicate(\"not a list\"))  # Raises ValueError\n    print(test_duplicate([1, 2, \"three\", 4]))  # Raises ValueError\nexcept ValueError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp6schcimh.py\", line 25, in <module>\n    test_duplicate(None)\n  File \"/tmp/tmp6schcimh.py\", line 3, in test_duplicate\n    raise ValueError('Input must be a list')\nValueError: Input must be a list", "passed": false}
{"task_id": 20, "requirement": "Exception Handling", "completion": "def is_woodall(num):\n    \"\"\"\n    Check if the given number is a Woodall number.\n    \n    A Woodall number is of the form n * 2^n - 1 for some positive integer n.\n    \n    :param num: Integer to check\n    :return: True if num is a Woodall number, False otherwise\n    :raises TypeError: If the input is not an integer\n    \"\"\"\n    # Type checking\n    if not isinstance(num, int):\n        raise TypeError(\"Input must be an integer\")\n    \n    # If the number is less than 7 (the first Woodall number), it cannot be a Woodall number\n    if num < 7:\n        return False\n    \n    # Iterate over possible values of n\n    n = 1\n    while n * 2**n - 1 <= num:\n        woodall_num = n * 2**n - 1\n        if woodall_num == num:\n            return True\n        n += 1\n    return False\n\n# Example usage:\ntry:\n    print(is_woodall(7))   # True, because 7 is 1*2^1-1\n    print(is_woodall(23))  # True, because 23 is 2*2^2-1\n    print(is_woodall(63))  # True, because 63 is 3*2^3-1\n    print(is_woodall(10))  # False\n    print(is_woodall(1.5)) # Should raise TypeError\nexcept TypeError as e:\n    print(e)\n", "result": "passed", "passed": true}
{"task_id": 21, "requirement": "Exception Handling", "completion": "def multiples_of_num(m, n):\n    \"\"\"\n    Generates the first m multiples of the number n.\n\n    Parameters:\n    m (int): The number of multiples to generate. Must be non-negative.\n    n (int): The base number to find multiples of. Must be non-negative.\n\n    Returns:\n    list: A list containing the first m multiples of n.\n\n    Raises:\n    ValueError: If either m or n is negative.\n    \"\"\"\n    if m < 0 or n < 0:\n        raise ValueError(\"Both m and n must be non-negative.\")\n    \n    return [i * n for i in range(1, m + 1)]\n\n# Example usage:\ntry:\n    m = 5\n    n = 3\n    print(multiples_of_num(m, n))  # Output: [3, 6, 9, 12, 15]\nexcept ValueError as e:\n    print(e)\n", "result": "passed", "passed": true}
{"task_id": 22, "requirement": "Exception Handling", "completion": "def find_first_duplicate(nums):\n    if not isinstance(nums, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    seen = set()\n    for num in nums:\n        if not isinstance(num, int):\n            raise TypeError(\"All elements in the list must be integers.\")\n        \n        if num in seen:\n            return num\n        seen.add(num)\n    \n    return None\n\n# Example usage:\ntry:\n    array = [2, 5, 1, 2, 3, 5, 1, 2, 4]\n    print(find_first_duplicate(array))  # Output will be 2\nexcept TypeError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpgmftscoz.py\", line 19, in <module>\n    assert find_first_duplicate([1, 2, 3, 4])==-1\nAssertionError", "passed": false}
{"task_id": 23, "requirement": "Exception Handling", "completion": "def maximum_sum(list_of_lists):\n    \"\"\"\n    Finds the maximum sum of elements among all sublists in a given list of lists.\n    \n    Parameters:\n    - list_of_lists (list of lists): A list containing multiple sublists of integers.\n    \n    Raises:\n    - TypeError: If the input is not a list of lists or if any sublist contains non-integer elements.\n    \n    Returns:\n    - int: The maximum sum of elements found in any of the sublists.\n    \"\"\"\n    if not isinstance(list_of_lists, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    max_sum = float('-inf')  # Initialize with negative infinity to handle negative numbers as well\n    \n    for sublist in list_of_lists:\n        if not isinstance(sublist, list):\n            raise TypeError(\"Each element of the main list must be a sublist.\")\n        \n        if not all(isinstance(x, int) for x in sublist):\n            raise TypeError(\"All elements in a sublist must be integers.\")\n        \n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n# Example usage:\ntry:\n    example_list_of_lists = [[1, 2, 3], [4, 5, \"six\"], [-7, -8, 9], [0]]\n    print(maximum_sum(example_list_of_lists))\nexcept TypeError as e:\n    print(e)\n\n# Another example with correct input\ntry:\n    example_list_of_lists = [[1, 2, 3], [4, 5, 6], [-7, -8, 9], [0]]\n    print(maximum_sum(example_list_of_lists))  # Should output 15\nexcept TypeError as e:\n    print(e)\n", "result": "failed: File \"/tmp/tmp2iz2p8b1.py\", line 29\n    try: maximum_sum([[1, 2], [3, 'a']]); assert False, 'Expected TypeError' except TypeError: pass\n                                                                             ^\nSyntaxError: invalid syntax", "passed": false}
{"task_id": 24, "requirement": "Exception Handling", "completion": "def binary_to_decimal(binary_str):\n    \"\"\"\n    Convert a binary number (as a string) to its decimal equivalent.\n    \n    :param binary_str: A string representing a binary number.\n    :return: The decimal equivalent of the binary number.\n    :raises ValueError: If the input is not a valid binary string.\n    \"\"\"\n    # Validate the input string to ensure it only contains '0' and '1'\n    if not all(char in '01' for char in binary_str):\n        raise ValueError('Invalid binary number')\n    \n    decimal_value = 0\n    # Iterate over the binary string in reverse order\n    for index, digit in enumerate(reversed(binary_str)):\n        # Calculate the decimal value\n        decimal_value += int(digit) * (2 ** index)\n    return decimal_value\n\n# Example usage:\ntry:\n    print(binary_to_decimal('1011'))  # Output should be 11\n    print(binary_to_decimal('1021'))  # Should raise ValueError\nexcept ValueError as e:\n    print(e)\n", "result": "failed: File \"/tmp/tmpb1j73q9o.py\", line 20\n    try: binary_to_decimal('102'); assert False, 'Expected ValueError' except ValueError as e: assert str(e) == 'Invalid binary number'\n                                                                       ^\nSyntaxError: invalid syntax", "passed": false}
{"task_id": 25, "requirement": "Exception Handling", "completion": "from collections import Counter\n\ndef find_product(arr):\n    # Check if the input is a list\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list\")\n    \n    # Check if every element in the list is an integer\n    if not all(isinstance(x, int) for x in arr):\n        raise TypeError(\"All elements in the list must be integers\")\n    \n    # Count the frequency of each element in the array\n    freq = Counter(arr)\n    \n    # Calculate the product of non-repeated elements\n    product = 1\n    for element, count in freq.items():\n        if count == 1:\n            product *= element\n    \n    return product\n\n# Example usage:\ntry:\n    arr = [2, 3, 4, 5, 6, 3, 4]\n    print(find_product(arr))  # Output should be 2 * 5 * 6 = 60\nexcept TypeError as e:\n    print(e)\n\ntry:\n    arr = [2, 3, \"4\", 5]  # This will raise a TypeError\n    print(find_product(arr))\nexcept TypeError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpzwm974oo.py\", line 28, in <module>\n    assert find_product([1,1,2,3],4) == 6\nTypeError: find_product() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 26, "requirement": "Exception Handling", "completion": "def check_k_elements(tuples_list, k_elements):\n    \"\"\"\n    Checks if any tuple in the list contains all the specified k elements.\n    \n    :param tuples_list: List of tuples to be checked.\n    :param k_elements: A list or set of elements to look for within each tuple.\n    :return: True if any tuple contains all the specified k elements, False otherwise.\n    :raises TypeError: If the input is not a list of tuples or k_elements is not a list or set.\n    \"\"\"\n    # Type checking\n    if not isinstance(tuples_list, list) or not all(isinstance(item, tuple) for item in tuples_list):\n        raise TypeError(\"tuples_list must be a list of tuples\")\n    \n    if not isinstance(k_elements, (list, set)):\n        raise TypeError(\"k_elements must be a list or set\")\n\n    # Convert k_elements to a set for efficient lookup\n    k_set = set(k_elements)\n    \n    for tup in tuples_list:\n        # Check if the tuple contains all elements in k_set\n        if k_set.issubset(tup):\n            return True\n    \n    return False\n\n# Example usage:\ntry:\n    print(check_k_elements([(1, 2, 3), (4, 5, 6), (7, 8, 9, 10)], [2, 3]))  # Output: True\n    print(check_k_elements([(1, 2, 3), (4, 5, 6), (7, 8, 9, 10)], [2, 3, 4]))  # Output: False\n    print(check_k_elements([(1, 2, 3), (4, 5, 6), (7, 8, 9, 10)], \"invalid\"))  # Should raise TypeError\nexcept TypeError as e:\n    print(e)\n\ntry:\n    print(check_k_elements(\"not a list\", [2, 3]))  # Should raise TypeError\nexcept TypeError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpdeecwa96.py\", line 25, in <module>\n    assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == True\n  File \"/tmp/tmpdeecwa96.py\", line 6, in check_k_elements\n    raise TypeError(\"k_elements must be a list or set\")\nTypeError: k_elements must be a list or set", "passed": false}
{"task_id": 27, "requirement": "Exception Handling", "completion": "import re\n\ndef remove_digits(strings):\n    \"\"\"\n    Removes all digits from each string in the provided list of strings.\n    \n    :param strings: List of strings from which digits are to be removed\n    :raises TypeError: If input is not a list or if any element in the list is not a string\n    :return: A new list of strings with all digits removed\n    \"\"\"\n    if not isinstance(strings, list):\n        raise TypeError(\"Input must be a list\")\n    \n    for item in strings:\n        if not isinstance(item, str):\n            raise TypeError(\"All elements in the list must be strings\")\n    \n    # Removing digits using regular expressions\n    return [re.sub(r'\\d', '', s) for s in strings]\n\n# Example usage:\nexample_list = [\"abc123\", \"456def\", \"7890\"]\ncleaned_list = remove_digits(example_list)\nprint(cleaned_list)  # Output should be ['abc', 'def', '']\n\n# Test with invalid inputs\ntry:\n    remove_digits(\"not a list\")  # Should raise TypeError\nexcept TypeError as e:\n    print(e)\n\ntry:\n    remove_digits([\"valid1\", 123, \"invalid\"])  # Should raise TypeError\nexcept TypeError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp9tfm8_mm.py\", line 23, in <module>\n    assert remove(['4words', '3letters', '4digits']) == ['words', 'letters', 'digits']\nNameError: name 'remove' is not defined", "passed": false}
{"task_id": 28, "requirement": "Exception Handling", "completion": "def binomial_coeff(n, k):\n    \"\"\"\n    Calculate the binomial coefficient (n choose k).\n\n    Parameters:\n    n (int): The total number of items.\n    k (int): The number of items to choose.\n\n    Returns:\n    int: The binomial coefficient C(n, k).\n\n    Raises:\n    ValueError: If inputs are invalid according to the constraints.\n    \"\"\"\n    if not isinstance(n, int) or not isinstance(k, int):\n        raise ValueError(\"Both n and k must be integers.\")\n    if n < 0 or k < 0:\n        raise ValueError(\"Inputs must be non-negative.\")\n    if k > n:\n        raise ValueError(\"k must not be greater than n\")\n\n    # Optimization to minimize the number of operations\n    if k > n - k:\n        k = n - k\n\n    res = 1\n    for i in range(k):\n        res *= (n - i)\n        res //= (i + 1)\n    return res\n\n# Example usage:\ntry:\n    print(binomial_coeff(5, 2))  # Expected output: 10\n    print(binomial_coeff(10, 3)) # Expected output: 120\n    print(binomial_coeff(5, 6))  # Should raise ValueError\nexcept ValueError as e:\n    print(e)\n\ntry:\n    print(binomial_coeff(-1, 2)) # Should raise ValueError\nexcept ValueError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpk3wpo51k.py\", line 30, in <module>\n    try: binomial_coeff(-1, 2)\n  File \"/tmp/tmpk3wpo51k.py\", line 5, in binomial_coeff\n    raise ValueError(\"Inputs must be non-negative.\")\nValueError: Inputs must be non-negative.\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpk3wpo51k.py\", line 31, in <module>\n    except ValueError as e: assert str(e) == 'Inputs must be non-negative and k must not be greater than n'\nAssertionError", "passed": false}
{"task_id": 29, "requirement": "Exception Handling", "completion": "def get_odd_occurrence(arr):\n    # Check if the input is a list\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list\")\n    \n    # Check if every element in the list is an integer\n    if not all(isinstance(x, int) for x in arr):\n        raise TypeError(\"All elements in the list must be integers\")\n    \n    # Dictionary to store the count of each element\n    count_dict = {}\n    \n    # Count the occurrences of each element\n    for element in arr:\n        if element in count_dict:\n            count_dict[element] += 1\n        else:\n            count_dict[element] = 1\n    \n    # Find and return the element with an odd occurrence\n    for element, count in count_dict.items():\n        if count % 2 != 0:\n            return element\n    \n    # If no element occurs an odd number of times, return None\n    return None\n\n# Example usage:\ntry:\n    arr = [1, 2, 3, 2, 3, 1, 3]\n    print(get_odd_occurrence(arr))  # Output should be 3\nexcept TypeError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpsw4w4fqu.py\", line 28, in <module>\n    assert get_odd_occurrence([1,2,3,1,2,3,1],7) == 1\nTypeError: get_odd_occurrence() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 30, "requirement": "Exception Handling", "completion": "def count_substring_with_equal_ends_optimized(s):\n    \"\"\"\n    Counts all substrings starting and ending with the same character using frequency counting.\n    \n    :param s: Input string\n    :return: Number of substrings starting and ending with the same character\n    \"\"\"\n    # Check if the input is a string\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    \n    char_count = Counter(s)\n    count = sum((freq * (freq + 1)) // 2 for freq in char_count.values())\n    return count\n\n# Example usage:\ntry:\n    print(count_substring_with_equal_ends_optimized(\"abcab\"))  # Expected output: 7\n    print(count_substring_with_equal_ends_optimized(12345))    # Should raise TypeError\nexcept TypeError as e:\n    print(e)\n", "result": "failed: File \"/tmp/tmpl5zvu7g8.py\", line 17\n    try: count_substring_with_equal_ends(123); assert False, 'Expected TypeError' except TypeError: pass\n                                                                                  ^\nSyntaxError: invalid syntax", "passed": false}
{"task_id": 31, "requirement": "Exception Handling", "completion": "import heapq\nfrom collections import defaultdict\n\ndef func(lists, k):\n    # Dictionary to count occurrences of each integer\n    count = defaultdict(int)\n    distinct_integers = set()  # Set to track distinct integers\n    \n    # Count the occurrence of each integer in the lists and collect distinct integers\n    for lst in lists:\n        for num in lst:\n            count[num] += 1\n            distinct_integers.add(num)\n    \n    # Check if k is valid\n    if k > len(distinct_integers):\n        raise ValueError('k cannot be greater than the number of distinct integers')\n    \n    # Min-heap to keep track of top k elements based on their frequencies\n    heap = []\n    \n    # Push elements into the heap if its size is less than k or if the current element's frequency is greater than the smallest frequency in the heap\n    for num, freq in count.items():\n        if len(heap) < k:\n            heapq.heappush(heap, (freq, num))\n        elif freq > heap[0][0]:\n            # Replace the root of the heap if the current element's frequency is higher\n            heapq.heapreplace(heap, (freq, num))\n    \n    # Extract the top k elements from the heap\n    result = [num for _, num in heap]\n    \n    return result\n\n# Example usage:\nlists = [\n    [1, 4, 5, 8],\n    [4, 5, 6, 7],\n    [1, 3, 4, 6],\n    [2, 4, 6, 8]\n]\n\nk = 2\nprint(func(lists, k))  # Output should be the top 2 most frequent integers\n\nk = 10  # This should raise an error because there are fewer than 10 distinct integers\ntry:\n    print(func(lists, k))\nexcept ValueError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpx9kogff2.py\", line 41, in <module>\n    assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],3)==[5, 7, 1]\nAssertionError", "passed": false}
{"task_id": 32, "requirement": "Exception Handling", "completion": "def max_prime_factors(n):\n    if not isinstance(n, int) or n < 2:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    max_prime = -1\n    \n    # Remove all factors of 2\n    while n % 2 == 0:\n        max_prime = 2\n        n //= 2\n    \n    # Check for odd factors from 3 onwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            max_prime = factor\n            n //= factor\n        factor += 2\n    \n    # If n is a prime number greater than 2\n    if n > 2:\n        max_prime = n\n    \n    return max_prime\n\n# Example usage:\ntry:\n    print(max_prime_factors(13195))  # Output: 29\n    print(max_prime_factors(2048))   # Output: 2\n    print(max_prime_factors(-10))    # Should raise ValueError\nexcept ValueError as e:\n    print(e)\n", "result": "passed", "passed": true}
{"task_id": 33, "requirement": "Exception Handling", "completion": "def decimal_to_binary(decimal_number):\n    \"\"\"\n    Convert a decimal number to its binary representation.\n    \n    Parameters:\n    - decimal_number (int): The decimal number to be converted.\n    \n    Returns:\n    - str: The binary representation of the decimal number.\n    \n    Raises:\n    - ValueError: If the input is not a non-negative integer.\n    \"\"\"\n    if not isinstance(decimal_number, int) or decimal_number < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    # Base case for recursion or loop termination\n    if decimal_number == 0:\n        return '0'\n    \n    binary_digits = []\n    while decimal_number > 0:\n        binary_digits.append(str(decimal_number % 2))\n        decimal_number //= 2\n    \n    # Joining the list in reverse order to form the binary string\n    return ''.join(reversed(binary_digits))\n\n# Example usage:\ntry:\n    print(decimal_to_binary(10))  # Output: \"1010\"\n    print(decimal_to_binary(255)) # Output: \"11111111\"\n    print(decimal_to_binary(-2))  # Should raise ValueError\nexcept ValueError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpdavvlcvk.py\", line 20, in <module>\n    assert decimal_to_binary(10) == 1010\nAssertionError", "passed": false}
{"task_id": 34, "requirement": "Exception Handling", "completion": "def find_missing(arr):\n    \"\"\"\n    Finds the missing number in a sorted array of integers in arithmetic progression.\n    \n    Parameters:\n    arr (list): A sorted list of integers in arithmetic progression with one missing number.\n    \n    Raises:\n    ValueError: If the input list is not sorted.\n    \n    Returns:\n    int: The missing number in the array.\n    \"\"\"\n    # Check if the array is sorted\n    if arr != sorted(arr):\n        raise ValueError(\"Input list must be sorted.\")\n    \n    if not arr:\n        return None\n    \n    n = len(arr)\n    total_diff = arr[-1] - arr[0]\n    expected_diff = total_diff // n\n    \n    for i in range(1, n):\n        if arr[i] != arr[i-1] + expected_diff:\n            return arr[i-1] + expected_diff\n    \n    # Additional checks to ensure the missing number is not at the boundaries\n    if arr[0] != 0 and arr[0] != expected_diff:\n        return expected_diff\n    elif arr[-1] != arr[0] + (n+1) * expected_diff:\n        return arr[-1] + expected_diff\n    \n    return None\n\n# Example usage:\ntry:\n    arr_example_1 = [0, 1, 2, 4, 5, 6, 7, 8]\n    print(find_missing(arr_example_1))  # Output should be 3\n    \n    arr_example_2 = [2, 3, 4, 6, 7, 8]\n    print(find_missing(arr_example_2))  # Output should be 5\n    \n    arr_example_3 = [5, 3, 4, 6, 7, 8]\n    print(find_missing(arr_example_3))  # Should raise ValueError\nexcept ValueError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp4n8xicf4.py\", line 29, in <module>\n    assert find_missing([1,2,3,5],4) == 4\nTypeError: find_missing() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 35, "requirement": "Exception Handling", "completion": "def find_rect_num(n):\n    \"\"\"\n    Calculate the n-th rectangular number.\n    \n    :param n: An integer representing the position in the sequence of rectangular numbers.\n    :return: The n-th rectangular number.\n    :raises ValueError: If n is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    return n * (n + 1)\n\n# Example usage:\nif __name__ == \"__main__\":\n    try:\n        n = 5  # For example, let's find the 5th rectangular number\n        print(f\"The {n}-th rectangular number is: {find_rect_num(n)}\")\n        \n        # Testing invalid inputs\n        print(f\"The {-2}-th rectangular number is: {find_rect_num(-2)}\")  # Should raise ValueError\n    except ValueError as e:\n        print(e)\n", "result": "passed", "passed": true}
{"task_id": 36, "requirement": "Exception Handling", "completion": "def find_nth_digit(dividend, divisor, n):\n    # Check for division by zero\n    if divisor == 0:\n        raise ValueError('Denominator cannot be zero')\n    \n    # Perform the integer division to get the whole number part of the result\n    quotient = dividend // divisor\n    \n    # Get the remainder for the decimal part calculation\n    remainder = dividend % divisor\n    \n    # Initialize an empty string to hold the decimal part digits\n    decimal_digits = \"\"\n    \n    # Loop to generate the decimal part until we have enough digits or reach a repeating cycle\n    visited_remainders = {}\n    index = 0\n    \n    while remainder != 0 and len(decimal_digits) < n + 10:  # Add some buffer to ensure we have enough digits\n        if remainder in visited_remainders:\n            # A repeating cycle is detected\n            break\n        \n        visited_remainders[remainder] = index\n        remainder *= 10\n        new_digit = remainder // divisor\n        decimal_digits += str(new_digit)\n        remainder %= divisor\n        index += 1\n    \n    # If the loop breaks due to a repeating cycle or we didn't generate enough digits\n    if remainder in visited_remainders or len(decimal_digits) == 0:\n        return -1  # Indicate that the nth digit couldn't be found\n    \n    # Extract the nth digit from the decimal part\n    nth_digit = int(decimal_digits[n-1]) if n <= len(decimal_digits) else -1\n    \n    return nth_digit\n\n# Example usage:\ntry:\n    print(find_nth_digit(1, 2, 3))  # Should print 0 because 1/2 = 0.500... and the 3rd digit is 0\n    print(find_nth_digit(2, 3, 5))  # Should print 6 because 2/3 = 0.666... and the 5th digit is 6\nexcept ValueError as e:\n    print(e)\n\n# Test division by zero\ntry:\n    print(find_nth_digit(1, 0, 1))  # Should raise ValueError\nexcept ValueError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp63l1ns5b.py\", line 43, in <module>\n    assert find_nth_digit(5,6,5) == 3\nAssertionError", "passed": false}
{"task_id": 37, "requirement": "Exception Handling", "completion": "def sort_mixed_list(mixed_list):\n    # Check if the input is a list\n    if not isinstance(mixed_list, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    # Initialize lists to hold integers and strings\n    integers = []\n    strings = []\n    \n    # Iterate through the list to separate integers and strings\n    for item in mixed_list:\n        if isinstance(item, int):\n            integers.append(item)\n        elif isinstance(item, str):\n            strings.append(item)\n        else:\n            raise TypeError(\"List items must be either integers or strings.\")\n    \n    # Sort each list\n    integers.sort()\n    strings.sort()\n    \n    # Concatenate the sorted lists\n    sorted_list = integers + strings\n    \n    return sorted_list\n\n# Example usage:\ntry:\n    mixed_list = [5, \"banana\", 3, \"apple\", 7, \"cherry\"]\n    sorted_list = sort_mixed_list(mixed_list)\n    print(sorted_list)  # Expected output: [3, 5, 7, 'apple', 'banana', 'cherry']\nexcept TypeError as e:\n    print(e)\n\n# Testing with invalid inputs\ntry:\n    invalid_input = [5, \"banana\", 3.14, \"apple\", 7, \"cherry\"]\n    sort_mixed_list(invalid_input)\nexcept TypeError as e:\n    print(e)  # Should raise an error for the float value\n\ntry:\n    not_a_list = \"Not a list\"\n    sort_mixed_list(not_a_list)\nexcept TypeError as e:\n    print(e)  # Should raise an error for the non-list input\n", "result": "passed", "passed": true}
{"task_id": 38, "requirement": "Exception Handling", "completion": "def div_even_odd(numbers):\n    \"\"\"\n    Divides the first even number by the first odd number in the given list.\n    \n    :param numbers: List of integers.\n    :return: The division result of the first even number by the first odd number.\n             Raises ValueError if the list does not contain at least one even and one odd number.\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    for num in numbers:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        \n        # Once both first even and first odd are found, break the loop\n        if first_even is not None and first_odd is not None:\n            break\n    \n    # Check if both first even and first odd were found\n    if first_even is None or first_odd is None:\n        raise ValueError('List must contain at least one even and one odd number.')\n    \n    # Perform the division\n    try:\n        result = first_even / first_odd\n    except ZeroDivisionError:\n        # Handle the case where the first odd number is zero\n        raise ValueError('First odd number cannot be zero.')\n    \n    return result\n\n# Example usage:\ntry:\n    print(div_even_odd([5, 3, 2, 8]))  # Output should be 2.0 (2/1)\n    print(div_even_odd([2, 4, 6]))     # Raises ValueError, no odd number\n    print(div_even_odd([1, 3, 5]))     # Raises ValueError, no even number\n    print(div_even_odd([2, 0, 4]))     # Raises ValueError, first odd number is zero\nexcept ValueError as e:\n    print(e)\n", "result": "failed: File \"/tmp/tmpibg8risl.py\", line 33\n    try: div_even_odd([2, 4, 6]); assert False; except ValueError as e: assert str(e) == 'List must contain at least one even and one odd number.'\n                                                ^\nSyntaxError: invalid syntax", "passed": false}
{"task_id": 39, "requirement": "Exception Handling", "completion": "from collections import Counter\n\ndef rearrange_string(s):\n    # Validate input type\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string\")\n    \n    # Validate input content\n    if not s.islower():\n        raise ValueError(\"String must contain only lowercase letters\")\n    \n    # Step 1: Count the frequency of each character\n    char_count = Counter(s)\n    \n    # Step 2: Sort characters by their frequency (descending order)\n    sorted_chars = sorted(char_count.items(), key=lambda x: -x[1])\n    \n    result = []\n    used_char = None\n    \n    while sorted_chars:\n        for i, (char, count) in enumerate(sorted_chars):\n            if char != used_char:\n                # Add the character to the result\n                result.append(char)\n                used_char = char\n                # Decrease the count\n                sorted_chars[i] = (char, count - 1)\n                \n                # Remove the character from the list if its count becomes zero\n                if count - 1 == 0:\n                    del sorted_chars[i]\n                break\n        else:\n            # If we couldn't find a suitable character to add, return False\n            return False\n    \n    # Check if the last two characters are the same\n    if len(result) > 1 and result[-1] == result[-2]:\n        return False\n    \n    return True\n\n# Example usage:\ntry:\n    print(rearrange_string(\"aab\"))  # Output: True\n    print(rearrange_string(\"aaab\")) # Output: False\n    print(rearrange_string(\"AaBb\")) # Raises ValueError: String must contain only lowercase letters\nexcept ValueError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpyc9rkl80.py\", line 41, in <module>\n    assert rearange_string(\"aab\")==('aba')\nNameError: name 'rearange_string' is not defined", "passed": false}
{"task_id": 40, "requirement": "Exception Handling", "completion": "from collections import Counter\nfrom itertools import chain\n\ndef freq_element(list_of_lists):\n    # Check if the input is a list and if each element is also a list\n    if not isinstance(list_of_lists, list) or not all(isinstance(sublist, list) for sublist in list_of_lists):\n        raise TypeError(\"Input must be a list of lists\")\n    \n    # Flatten the list of lists into a single list\n    flattened_list = list(chain(*list_of_lists))\n    \n    # Count the frequency of each element in the flattened list\n    freq_counter = Counter(flattened_list)\n    \n    return freq_counter\n\n# Example usage:\ntry:\n    list_of_lists = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [1, 2, 3, 4],\n        [7, 8, 9]\n    ]\n    print(freq_element(list_of_lists))\nexcept TypeError as e:\n    print(e)\n\n# Example with incorrect input type\ntry:\n    invalid_input = [1, 2, 3]  # This is not a list of lists\n    print(freq_element(invalid_input))\nexcept TypeError as e:\n    print(e)\n", "result": "failed: File \"/tmp/tmph4jx5hbo.py\", line 32\n    try: freq_element('not a list'); assert False; except TypeError: assert True\n                                                   ^\nSyntaxError: invalid syntax", "passed": false}
{"task_id": 41, "requirement": "Exception Handling", "completion": "def filter_evennumbers(numbers):\n    # Check if the input is a list\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list\")\n    \n    # Check if every element in the list is an integer\n    if not all(isinstance(x, int) for x in numbers):\n        raise TypeError(\"All elements in the list must be integers\")\n    \n    # Use filter() with a lambda function to filter even numbers\n    even_numbers = filter(lambda x: x % 2 == 0, numbers)\n    # Convert the filter object to a list before returning\n    return list(even_numbers)\n\n# Example usage:\nexample_list = [1, 2, 3, 4, 5, 6]\nprint(filter_evennumbers(example_list))  # Output: [2, 4, 6]\n\n# Incorrect usage examples\ntry:\n    print(filter_evennumbers(\"not a list\"))\nexcept TypeError as e:\n    print(e)  # Output: Input must be a list\n\ntry:\n    print(filter_evennumbers([1, 2, \"three\", 4]))\nexcept TypeError as e:\n    print(e)  # Output: All elements in the list must be integers\n", "result": "passed", "passed": true}
{"task_id": 42, "requirement": "Exception Handling", "completion": "def find_sum(arr):\n    \"\"\"\n    Finds the sum of all repeated elements in a given list.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    int: The sum of all repeated elements in the list.\n    \n    Raises:\n    TypeError: If the input is not a list.\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list\")\n    \n    # Dictionary to store the count of each element\n    element_count = {}\n    \n    # Iterate through the list to populate the dictionary with counts\n    for element in arr:\n        if element in element_count:\n            element_count[element] += 1\n        else:\n            element_count[element] = 1\n    \n    # Calculate the sum of elements that appear more than once\n    repeated_sum = sum(element * (count - 1) for element, count in element_count.items() if count > 1)\n    \n    return repeated_sum\n\n# Example usage:\nexample_list = [1, 2, 3, 2, 3, 4, 5, 3]\nprint(find_sum(example_list))  # Output will be 10 because 2 appears twice (2*1=2) and 3 appears three times (3*2=6), total is 2+6=8 but corrected as 2+(3*2)=8\n\n# Testing with invalid input\ntry:\n    print(find_sum('not a list'))\nexcept TypeError as e:\n    print(e)  # This will output \"Input must be a list\"\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp2wsv7txj.py\", line 23, in <module>\n    assert find_sum([1,2,3,1,1,4,5,6],8) == 3\nTypeError: find_sum() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 43, "requirement": "Exception Handling", "completion": "import re\n\ndef text_match(text):\n    # Check if the input is a string\n    if not isinstance(text, str):\n        raise TypeError(\"Input must be a string\")\n\n    # Define the regex pattern to match sequences of lowercase letters joined with an underscore\n    pattern = r'\\b[a-z]+_[a-z]+\\b'\n    \n    # Find all occurrences of the pattern in the provided text\n    matches = re.findall(pattern, text)\n    \n    return matches\n\n# Example usage:\ntry:\n    sample_text = \"this_is_a_sample_text with_multiple_matches_like_this_one_and_another_example\"\n    print(text_match(sample_text))\nexcept TypeError as e:\n    print(e)\n\ntry:\n    non_string_input = 12345\n    print(text_match(non_string_input))\nexcept TypeError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp8vk6gsa4.py\", line 22, in <module>\n    assert text_match(\"aab_cbbbc\") == 'Found a match!'\nAssertionError", "passed": false}
{"task_id": 44, "requirement": "Exception Handling", "completion": "import re\n\ndef text_match_string(text, pattern):\n    \"\"\"\n    This function checks if the given pattern (word) is at the beginning of the text.\n    \n    :param text: String to be searched\n    :param pattern: Word to match at the beginning of the text\n    :return: True if the pattern is found at the beginning of the text, False otherwise\n    \"\"\"\n    # Check if both inputs are strings\n    if not isinstance(text, str) or not isinstance(pattern, str):\n        raise TypeError(\"Both 'text' and 'pattern' must be strings\")\n    \n    # Compile a regex pattern to match the word at the start of the string\n    regex = re.compile(r'^' + re.escape(pattern))\n    \n    # Search for the pattern in the text\n    match = regex.search(text)\n    \n    # If match is found, return True; otherwise, return False\n    return bool(match)\n\n# Example usage:\nprint(text_match_string(\"Hello world\", \"Hello\"))  # Should return True\nprint(text_match_string(\"world Hello\", \"Hello\"))  # Should return False\ntry:\n    print(text_match_string(123, \"Hello\"))  # Should raise TypeError\nexcept TypeError as e:\n    print(e)\n", "result": "failed: File \"/tmp/tmpzgmd2_bk.py\", line 22\n    try: text_match_string(123); assert False, 'TypeError not raised' except TypeError: pass\n                                                                      ^\nSyntaxError: invalid syntax", "passed": false}
{"task_id": 45, "requirement": "Exception Handling", "completion": "from math import gcd\n\ndef get_gcd(numbers):\n    \"\"\"\n    Find the greatest common divisor (GCD) of all elements in the given list of integers.\n    \n    :param numbers: List[int] - A list of positive integers.\n    :return: int - The GCD of all elements in the list.\n    :raises ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError('Input list cannot be empty.')\n    \n    # Initialize gcd_result with the first element of the list\n    gcd_result = numbers[0]\n    \n    # Iterate through the list starting from the second element\n    for num in numbers[1:]:\n        gcd_result = gcd(gcd_result, num)\n        \n    return gcd_result\n\n# Example usages:\ntry:\n    numbers = [8, 12, 24]\n    print(\"The GCD of\", numbers, \"is:\", get_gcd(numbers))\n    \n    numbers = []\n    print(get_gcd(numbers))  # This should raise an exception\nexcept ValueError as e:\n    print(e)\n", "result": "passed", "passed": true}
{"task_id": 46, "requirement": "Exception Handling", "completion": "def test_distinct(numbers):\n    \"\"\"\n    Determine if all numbers in the list are distinct.\n\n    Args:\n    - numbers: A list of integers.\n\n    Raises:\n    - TypeError: If the input is not a list or if any element in the list is not an integer.\n\n    Returns:\n    - True if all numbers are distinct, False otherwise.\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    if not all(isinstance(x, int) for x in numbers):\n        raise TypeError(\"All elements in the list must be integers.\")\n    \n    return len(numbers) == len(set(numbers))\n\n# Example usage:\ntry:\n    print(test_distinct([1, 2, 3, 4]))  # Should print True\n    print(test_distinct([1, 2, 2, 3]))  # Should print False\n    print(test_distinct([1, '2', 3, 4]))  # Should raise TypeError\nexcept TypeError as e:\n    print(e)\n", "result": "passed", "passed": true}
{"task_id": 47, "requirement": "Exception Handling", "completion": "def last_non_zero_digit(n):\n    if n < 5:\n        # Direct computation for small n\n        fact = 1\n        for i in range(2, n + 1):\n            fact *= i\n        return str(fact)[-1]\n    \n    # For larger n, we remove factors of 10 and take modulo 10\n    last_digit = 1\n    count_5 = 0\n    for i in range(2, n + 1):\n        current = i\n        # Count factors of 5\n        while current % 5 == 0:\n            current //= 5\n            count_5 += 1\n        # Remove factors of 2\n        while current % 2 == 0:\n            current //= 2\n        last_digit = (last_digit * (current % 10)) % 10\n    \n    # Handle remaining factors of 2\n    for _ in range(count_5):\n        if last_digit == 0:\n            break\n        last_digit = (last_digit * 2) % 10\n    \n    return last_digit\n\ndef compute_last_digit(a, b):\n    if a > b:\n        raise ValueError('a should not be greater than b')\n    \n    last_digit_a = int(last_non_zero_digit(a))\n    last_digit_b = int(last_non_zero_digit(b))\n    \n    # Calculate the last digit of the division\n    if last_digit_b == 0:\n        return 0  # Avoid division by zero\n    \n    # Find modular inverse of last_digit_b under modulo 10\n    inv_last_digit_b = pow(last_digit_b, -1, 10)\n    result = (last_digit_a * inv_last_digit_b) % 10\n    \n    return result\n\n# Example usage:\ntry:\n    print(compute_last_digit(3, 5))  # Expected output: Last digit of (3! / 5!) which simplifies to 3! since 5! has trailing zeros\nexcept ValueError as e:\n    print(e)\n\ntry:\n    print(compute_last_digit(5, 3))  # Should raise an error\nexcept ValueError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpd3yfsfya.py\", line 48, in <module>\n    assert compute_last_digit(2,4) == 2\n  File \"/tmp/tmpd3yfsfya.py\", line 36, in compute_last_digit\n    inv_last_digit_b = pow(last_digit_b, -1, 10)\nValueError: base is not invertible for the given modulus", "passed": false}
{"task_id": 48, "requirement": "Exception Handling", "completion": "def odd_bit_set_number(n):\n    \"\"\"\n    Set all odd bits of the given integer n to 1.\n    \n    Args:\n    - n (int): The input integer whose odd bits are to be set.\n    \n    Returns:\n    - int: The modified integer with all odd bits set to 1.\n    \n    Raises:\n    - TypeError: If the input is not an integer.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n    \n    # Determine the number of bits in the binary representation of n\n    num_bits = n.bit_length()\n    \n    # Create a mask where all odd bits are set to 1\n    mask = 0\n    for i in range(num_bits):\n        if i % 2 == 1:\n            mask |= (1 << i)\n    \n    # Set the odd bits of n using the mask\n    result = n | mask\n    \n    return result\n\n# Example usage:\ntry:\n    print(bin(odd_bit_set_number(10)))  # Example input: 10 (binary: 1010)\nexcept TypeError as e:\n    print(e)\n\ntry:\n    print(bin(odd_bit_set_number(10.5)))  # Invalid input: should raise TypeError\nexcept TypeError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpe6egjptn.py\", line 23, in <module>\n    assert odd_bit_set_number(10) == 15\nAssertionError", "passed": false}
{"task_id": 49, "requirement": "Exception Handling", "completion": "def specified_element(two_dim_list, index):\n    \"\"\"\n    Extracts the element at the specified index from each sub-list of a two-dimensional list.\n    \n    :param two_dim_list: A two-dimensional list (list of lists)\n    :param index: The index of the element to extract from each sub-list\n    :return: A list containing the extracted elements\n    \"\"\"\n    # Initialize an empty list to store the extracted elements\n    extracted_elements = []\n    \n    # Iterate through each sub-list in the two-dimensional list\n    for sublist in two_dim_list:\n        # Check if the index is within the bounds of the current sub-list\n        if 0 <= index < len(sublist):\n            # Append the element at the specified index to the extracted_elements list\n            extracted_elements.append(sublist[index])\n        else:\n            # Raise an IndexError with a descriptive message\n            raise IndexError(f\"Index {index} is out of range for sublist {sublist}\")\n\n    return extracted_elements\n\n# Example usage:\ntwo_dim_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\ntry:\n    print(specified_element(two_dim_list, 1))  # Should work fine\n    print(specified_element(two_dim_list, 5))  # Should raise an IndexError\nexcept IndexError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp6lubx6d9.py\", line 24, in <module>\n    try: specified_element([[1, 2], [3, 4]], 3)\n  File \"/tmp/tmp6lubx6d9.py\", line 12, in specified_element\n    raise IndexError(f\"Index {index} is out of range for sublist {sublist}\")\nIndexError: Index 3 is out of range for sublist [1, 2]\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp6lubx6d9.py\", line 25, in <module>\n    except IndexError as e: assert str(e) == 'Index out of range for sublist'\nAssertionError", "passed": false}
{"task_id": 50, "requirement": "Exception Handling", "completion": "def min_length_list(lists):\n    # Check if the input is a list of lists\n    if not all(isinstance(lst, list) for lst in lists):\n        raise ValueError('Input must be a list of lists.')\n    \n    # Use the min function with a key that returns the length of each list\n    return min(lists, key=lambda x: len(x))\n\n# Example usage:\ntry:\n    lists = [[1, 2, 3], [4, 5], [6], [7, 8, 9, 10]]\n    print(min_length_list(lists))  # Output: [6]\nexcept ValueError as e:\n    print(e)\n\ntry:\n    invalid_input = [1, 2, 3]  # This is not a list of lists\n    print(min_length_list(invalid_input))\nexcept ValueError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp2s_rky5c.py\", line 18, in <module>\n    assert min_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(1, [0])\nAssertionError", "passed": false}
{"task_id": 51, "requirement": "Exception Handling", "completion": "def check_equilateral(a, b, c):\n    \"\"\"\n    Check if a triangle with sides a, b, and c is equilateral.\n    \n    Parameters:\n    a (float): Length of the first side of the triangle.\n    b (float): Length of the second side of the triangle.\n    c (float): Length of the third side of the triangle.\n    \n    Raises:\n    ValueError: If any of the side lengths are non-positive.\n    \n    Returns:\n    None: Prints whether the triangle is equilateral or not.\n    \"\"\"\n    # Validate inputs\n    if a <= 0 or b <= 0 or c <= 0:\n        raise ValueError(\"Side lengths must be positive numbers.\")\n    \n    # Check if the triangle is equilateral\n    if a == b == c:\n        print(\"The triangle is equilateral.\")\n    else:\n        print(\"The triangle is not equilateral.\")\n\n# Example usage:\ncheck_equilateral(5, 5, 5)  # This should print \"The triangle is equilateral.\"\ncheck_equilateral(5, 4, 3)  # This should print \"The triangle is not equilateral.\"\ntry:\n    check_equilateral(-1, 5, 5)\nexcept ValueError as e:\n    print(e)  # This should print \"Side lengths must be positive numbers.\"\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpjhszvop4.py\", line 17, in <module>\n    assert check_equilateral(6,8,12)==False \nAssertionError", "passed": false}
{"task_id": 52, "requirement": "Exception Handling", "completion": "def parallelogram_area(base, height):\n    \"\"\"\n    Calculate the area of a parallelogram.\n    \n    Parameters:\n    base (float or int): The length of the base of the parallelogram.\n    height (float or int): The height of the parallelogram, measured perpendicularly from the base.\n    \n    Returns:\n    float: The area of the parallelogram.\n    \n    Raises:\n    TypeError: If either base or height is not a numerical value.\n    \"\"\"\n    # Check if the inputs are numerical\n    if not isinstance(base, (int, float)) or not isinstance(height, (int, float)):\n        raise TypeError(\"Both base and height must be numerical values.\")\n    \n    return base * height\n\n# Example usage:\ntry:\n    base = 5.0\n    height = 3.0\n    area = parallelogram_area(base, height)\n    print(f\"The area of the parallelogram with base {base} and height {height} is {area}\")\nexcept TypeError as e:\n    print(e)\n\n# Test with invalid input\ntry:\n    base = \"5\"\n    height = 3.0\n    area = parallelogram_area(base, height)\nexcept TypeError as e:\n    print(e)\n", "result": "passed", "passed": true}
{"task_id": 53, "requirement": "Exception Handling", "completion": "def check_equality(s):\n    \"\"\"\n    Check if the first and last characters of the string s are equal.\n\n    :param s: Input string\n    :return: True if the first and last characters are equal, False otherwise\n    :raises TypeError: If the input is not a string\n    \"\"\"\n    # Check if the input is a string\n    if not isinstance(s, str):\n        raise TypeError('Input must be a string')\n    \n    # Check if the string is empty or has only one character\n    if len(s) <= 1:\n        return True\n    \n    # Compare the first and last character\n    return s[0] == s[-1]\n\n# Example usage:\ntry:\n    print(check_equality(\"radar\"))  # Should print True\n    print(check_equality(\"hello\"))  # Should print False\n    print(check_equality(\"a\"))      # Should print True\n    print(check_equality(12345))    # Should raise a TypeError\nexcept TypeError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpdhi2hwuv.py\", line 18, in <module>\n    assert check_equality(\"abcda\") == \"Equal\"\nAssertionError", "passed": false}
{"task_id": 54, "requirement": "Exception Handling", "completion": "def counting_sort(arr):\n    # Check if the input is a list\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list\")\n    \n    # Check if the list is empty\n    if not arr:\n        return arr\n    \n    # Check if all elements in the list are integers\n    if not all(isinstance(x, int) for x in arr):\n        raise TypeError(\"All elements in the list must be integers\")\n    \n    # Find the maximum and minimum values in the array\n    max_val = max(arr)\n    min_val = min(arr)\n    \n    # The range of the numbers\n    range_of_numbers = max_val - min_val + 1\n    \n    # Initialize count array with zeros\n    count_arr = [0] * range_of_numbers\n    \n    # Store the count of each element in count_arr\n    for num in arr:\n        count_arr[num - min_val] += 1\n    \n    # Modify count_arr such that each element at each index\n    # stores the sum of previous counts\n    for i in range(1, len(count_arr)):\n        count_arr[i] += count_arr[i - 1]\n    \n    # Output array that will have sorted arr\n    output_arr = [0] * len(arr)\n    \n    # Build the output array\n    for num in reversed(arr):\n        output_arr[count_arr[num - min_val] - 1] = num\n        count_arr[num - min_val] -= 1\n    \n    return output_arr\n\n# Example usage:\ntry:\n    arr = [4, 2, 2, 8, 3, 3, 1]\n    sorted_arr = counting_sort(arr)\n    print(\"Sorted array:\", sorted_arr)\nexcept TypeError as e:\n    print(e)\n", "result": "passed", "passed": true}
{"task_id": 55, "requirement": "Exception Handling", "completion": "def tn_gp(a, r, n):\n    \"\"\"\n    Calculate the n-th term of a geometric progression.\n\n    Parameters:\n    a (float): The first term of the geometric sequence.\n    r (float): The common ratio of the geometric sequence.\n    n (int): The term number to calculate.\n\n    Returns:\n    float: The value of the n-th term.\n\n    Raises:\n    ValueError: If the term number n is less than 1.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Term number must be greater than 0\")\n    \n    return a * (r ** (n - 1))\n\n# Example usage:\na = 2  # First term\nr = 3  # Common ratio\nn = 4  # Term number to find\n\ntry:\n    result = tn_gp(a, r, n)\n    print(f\"The {n}-th term of the geometric series with first term {a} and common ratio {r} is: {result}\")\nexcept ValueError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpt2weedcb.py\", line 14, in <module>\n    assert tn_gp(1,5,2)==16\nAssertionError", "passed": false}
{"task_id": 56, "requirement": "Exception Handling", "completion": "def reverse_number(n):\n    \"\"\"Helper function to reverse the digits of a number.\"\"\"\n    return int(str(n)[::-1])\n\ndef check(number):\n    \"\"\"\n    Function to check if a given number is one less than twice its reverse.\n    \n    Parameters:\n    - number: An integer\n    \n    Returns:\n    - True if the number is one less than twice its reverse, False otherwise.\n    \n    Raises:\n    - TypeError: If the input is not an integer.\n    \"\"\"\n    if not isinstance(number, int):\n        raise TypeError(\"Input must be an integer.\")\n    \n    reversed_num = reverse_number(number)\n    doubled_reversed = 2 * reversed_num\n    one_less_than_twice_reverse = doubled_reversed - 1\n    \n    return number == one_less_than_twice_reverse\n\n# Example usage:\ntry:\n    print(check(47))  # Should return True because 2*74 - 1 = 147\n    print(check(83))  # Should return False\n    print(check(47.5))  # Should raise TypeError\nexcept TypeError as e:\n    print(e)\n", "result": "passed", "passed": true}
{"task_id": 57, "requirement": "Exception Handling", "completion": "def find_max_num(digits, num_digits=None):\n    if num_digits is not None and len(digits) < num_digits:\n        raise ValueError('Number of digits exceeds the length of the list.')\n    \n    # Convert all digits to strings\n    str_digits = [str(digit) for digit in digits]\n    \n    # If num_digits is specified, slice the list accordingly\n    if num_digits is not None:\n        str_digits = str_digits[:num_digits]\n    \n    # Sort the digits in descending order\n    str_digits.sort(reverse=True)\n    \n    # Join the sorted digits to form the largest number\n    max_num_str = ''.join(str_digits)\n    \n    # Convert the result back to an integer if needed\n    max_num = int(max_num_str)\n    \n    return max_num\n\n# Example usage:\ndigits = [5, 3, 7, 9, 0]\nprint(find_max_num(digits))  # Output will be 97530\n\ntry:\n    print(find_max_num(digits, 6))  # Should raise ValueError\nexcept ValueError as e:\n    print(e)  # Output: Number of digits exceeds the length of the list.\n", "result": "passed", "passed": true}
{"task_id": 58, "requirement": "Exception Handling", "completion": "def opposite_signs(a, b):\n    \"\"\"\n    Check if two integers have opposite signs.\n\n    Args:\n    a (int): The first integer.\n    b (int): The second integer.\n\n    Raises:\n    TypeError: If either input is not an integer.\n\n    Returns:\n    bool: True if the integers have opposite signs, False otherwise.\n    \"\"\"\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError(\"Both inputs must be integers.\")\n    \n    return a * b < 0\n\n# Example usage:\ntry:\n    print(opposite_signs(1, -2))  # Should print True\n    print(opposite_signs(-1, -2)) # Should print False\n    print(opposite_signs(1.5, -2)) # Should raise TypeError\nexcept TypeError as e:\n    print(e)\n", "result": "passed", "passed": true}
{"task_id": 59, "requirement": "Exception Handling", "completion": "def nth_octagonal_number(n):\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    return n * (3 * n - 2)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp3nst7jte.py\", line 5, in <module>\n    assert is_octagonal(5) == 65\nNameError: name 'is_octagonal' is not defined", "passed": false}
{"task_id": 60, "requirement": "Exception Handling", "completion": "def max_len_sub(arr):\n    if not isinstance(arr, list):\n        raise TypeError(\"The first argument must be a list.\")\n    \n    n = len(arr)\n    if n == 0:\n        return 0\n    \n    max_length = 1  # At least one element can form a subsequence of length 1\n    \n    # Dictionary to store the lengths of subsequences ending with each element\n    dp = {arr[0]: 1}\n    \n    for i in range(1, n):\n        current_max = 1  # Minimum length of subsequence ending with current element\n        for diff in [-1, 1]:\n            prev_val = arr[i] + diff\n            if prev_val in dp:\n                current_max = max(current_max, dp[prev_val] + 1)\n        \n        dp[arr[i]] = current_max\n        max_length = max(max_length, current_max)\n    \n    return max_length\n\n# Example usage:\narr = [1, 2, 3, 4, 5, 3, 2, 1]\nprint(max_len_sub(arr))  # Expected output: 4\n\n# Test with invalid inputs\ntry:\n    print(max_len_sub(\"not a list\"))\nexcept TypeError as e:\n    print(e)\n\ntry:\n    max_len_sub([1, 2, \"three\", 4])\nexcept TypeError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpagfnsoj0.py\", line 31, in <module>\n    assert max_len_sub([2, 5, 6, 3, 7, 6, 5, 8], 8) == 5\nTypeError: max_len_sub() takes 1 positional argument but 2 were given", "passed": false}
