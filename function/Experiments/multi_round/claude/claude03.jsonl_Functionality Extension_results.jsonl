{"task_id": 11, "requirement": "Functionality Extension", "completion": "def remove_occ(string, char, all=False):\n    # Handle empty string or character\n    if not string or not char:\n        return string\n    \n    if all:\n        # Remove all occurrences of the character\n        return string.replace(char, '')\n    else:\n        # Find first and last occurrence\n        first = string.find(char)\n        last = string.rfind(char)\n        \n        # If character not found, return original string\n        if first == -1:\n            return string\n        \n        # If only one occurrence, remove it\n        if first == last:\n            return string[:first] + string[first + 1:]\n        \n        # Remove both first and last occurrences\n        return string[:first] + string[first + 1:last] + string[last + 1:]\n", "result": "passed", "passed": true}
{"task_id": 12, "requirement": "Functionality Extension", "completion": "def sort_matrix(matrix):\n    # Find the maximum length among all rows\n    max_length = max(len(row) for row in matrix)\n    \n    # Create a function to calculate row sum, treating missing values as zeros\n    def row_sum(row):\n        # Pad row with zeros if needed and calculate sum\n        return sum(row + [0] * (max_length - len(row)))\n    \n    # Sort matrix rows based on padded sums\n    return sorted(matrix, key=row_sum)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpxw38geu6.py\", line 10, in <module>\n    assert sort_matrix([[1, 2, 3], [4, 5], [6]]) == [[6], [4, 5], [1, 2, 3]]\nAssertionError", "passed": false}
{"task_id": 13, "requirement": "Functionality Extension", "completion": "from collections import Counter\n\ndef count_common(text_dict, n=5):\n    \"\"\"\n    Count the most common words across all values in a dictionary.\n    \n    Args:\n        text_dict (dict): Dictionary containing text values\n        n (int): Number of most common words to return (default=5)\n    \n    Returns:\n        list: List of tuples containing (word, count) pairs\n        \n    Raises:\n        ValueError: If n is less than 1\n        TypeError: If text_dict is not a dictionary\n    \"\"\"\n    # Input validation\n    if not isinstance(text_dict, dict):\n        raise TypeError(\"Input must be a dictionary\")\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n\n    # Rest of the function remains the same\n    all_text = ' '.join(str(value) for value in text_dict.values())\n    words = all_text.lower().split()\n    word_counts = Counter(words)\n    return word_counts.most_common(n)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpgwf0fi3f.py\", line 13, in <module>\n    assert count_common(['apple', 'banana', 'apple', 'orange', 'banana', 'banana'], 2) == [('banana', 3), ('apple', 2)]\n  File \"/tmp/tmpgwf0fi3f.py\", line 5, in count_common\n    raise TypeError(\"Input must be a dictionary\")\nTypeError: Input must be a dictionary", "passed": false}
{"task_id": 14, "requirement": "Functionality Extension", "completion": "def find_volume(base_or_dimensions, height=None, length=None):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Args:\n        base_or_dimensions: Either the base length of the triangle as a float,\n                          or a list/tuple containing [base, height, length]\n        height (float, optional): The height of the triangle (if not using list/tuple)\n        length (float, optional): The length of the prism (if not using list/tuple)\n    \n    Returns:\n        float: The volume of the triangular prism\n    \n    Raises:\n        ValueError: If inputs are invalid or dimensions are negative\n    \"\"\"\n    # Handle list/tuple input\n    if isinstance(base_or_dimensions, (list, tuple)):\n        if len(base_or_dimensions) != 3:\n            raise ValueError(\"List/tuple must contain exactly 3 elements [base, height, length]\")\n        base, height, length = base_or_dimensions\n    else:\n        # Handle individual parameters\n        if height is None or length is None:\n            raise ValueError(\"When not using list/tuple, must provide base, height, and length\")\n        base = base_or_dimensions\n\n    # Validate inputs\n    if any(not isinstance(x, (int, float)) for x in (base, height, length)):\n        raise ValueError(\"All dimensions must be numbers\")\n    if any(x <= 0 for x in (base, height, length)):\n        raise ValueError(\"All dimensions must be positive numbers\")\n\n    # Calculate the volume\n    triangle_area = 0.5 * base * height\n    volume = triangle_area * length\n    \n    return volume\n", "result": "passed", "passed": true}
{"task_id": 15, "requirement": "Functionality Extension", "completion": "def split_lowerstring(text, include_lower=False):\n    result = []\n    current_word = \"\"\n    \n    for i, char in enumerate(text):\n        if char.islower():\n            if current_word:\n                result.append(current_word)\n            # Check for uppercase letters following this lowercase letter\n            current_word = char if include_lower else \"\"\n            j = i + 1\n            while j < len(text) and text[j].isupper():\n                current_word += text[j]\n                j += 1\n        else:\n            current_word += char\n    \n    # Append the last word if it exists\n    if current_word:\n        result.append(current_word)\n    \n    return result\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpjn042hir.py\", line 20, in <module>\n    assert split_lowerstring('AbCd', include_lower=True) == ['Ab', 'Cd']\nAssertionError", "passed": false}
{"task_id": 16, "requirement": "Functionality Extension", "completion": "import re\n\ndef text_lowercase_underscore(text):\n    pattern = r'[a-z]+(?:_[a-z]+)*'\n    matches = re.search(pattern, text)\n    return \"Found a match!\" if matches else \"No match found\"\n", "result": "passed", "passed": true}
{"task_id": 17, "requirement": "Functionality Extension", "completion": "def square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square, rounding the side length to nearest integer.\n    \n    Args:\n        side_length (float or int): Length of one side of the square\n        \n    Returns:\n        int: Perimeter of the square using rounded side length\n    \"\"\"\n    if side_length < 0:\n        raise ValueError(\"Side length cannot be negative\")\n    \n    # Round the side length to nearest integer\n    rounded_side = round(side_length)\n    perimeter = 4 * rounded_side\n    return perimeter\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpnxspfew7.py\", line 8, in <module>\n    assert square_perimeter(4.5) == 20\nAssertionError", "passed": false}
{"task_id": 18, "requirement": "Functionality Extension", "completion": "def remove_dirty_chars(string1: str, string2: str) -> str:\n    # Convert string2 to lowercase and create a set for O(1) lookup\n    chars_to_remove = set(string2.lower())\n    \n    # Use list comprehension to keep only characters whose lowercase version is not in chars_to_remove\n    return ''.join(char for char in string1 if char.lower() not in chars_to_remove)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp_1g91bx5.py\", line 6, in <module>\n    assert remove_dirty_chars('HelloWorld', 'hELLO') == 'World', 'Function should handle case-insensitive character removal.'\nAssertionError: Function should handle case-insensitive character removal.", "passed": false}
{"task_id": 19, "requirement": "Functionality Extension", "completion": "def test_duplicate(arr):\n    \"\"\"\n    Find all duplicate elements in an array.\n    \n    Args:\n        arr (list): List of integers to check\n        \n    Returns:\n        list: List of duplicate elements found, empty list if no duplicates\n    \"\"\"\n    seen = set()\n    duplicates = set()  # Using set to avoid duplicate entries in result\n    \n    for num in arr:\n        if num in seen:\n            duplicates.add(num)\n        else:\n            seen.add(num)\n    \n    return list(duplicates)  # Convert set to list for final result\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Test cases\n    arr1 = [1, 2, 3, 4, 5]\n    arr2 = [1, 2, 3, 2, 5, 1, 2, 3]\n    \n    print(f\"Duplicates in {arr1}: {test_duplicate(arr1)}\")  # []\n    print(f\"Duplicates in {arr2}: {test_duplicate(arr2)}\")  # [1, 2, 3]\n", "result": "passed", "passed": true}
{"task_id": 20, "requirement": "Functionality Extension", "completion": "def is_woodall(num):\n    \"\"\"\n    Check if a given number is a Woodall number and return a list of all Woodall numbers up to num\n    if num is positive.\n    \n    Args:\n        num (int): The number to check\n        \n    Returns:\n        If num is positive: List of all Woodall numbers up to num\n        If num is negative: Boolean indicating if num is a Woodall number\n    \"\"\"\n    if num < 1:\n        return False\n    \n    woodall_numbers = []\n    n = 1\n    \n    while True:\n        woodall = n * (2 ** n) - 1\n        if woodall > num:\n            break\n        woodall_numbers.append(woodall)\n        n += 1\n    \n    return woodall_numbers\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpuxg69g8c.py\", line 14, in <module>\n    assert is_woodall(15) == [1, 7, 15]\nAssertionError", "passed": false}
{"task_id": 21, "requirement": "Functionality Extension", "completion": "def multiples_of_num(n, m):\n    \"\"\"\n    Find m multiples of number n, supporting both integers and floating-point numbers.\n    \n    Args:\n        n (int or float): The number to find multiples of\n        m (int): The number of multiples to find\n    \n    Returns:\n        list: A list containing m multiples of n as the same type as input n\n    \"\"\"\n    # Convert n to float if it's not already\n    n = float(n)\n    return [round(n * i, 10) for i in range(1, m + 1)]\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp253myhoz.py\", line 5, in <module>\n    assert multiples_of_num(3, 2.5) == [2.5, 5.0, 7.5]\n  File \"/tmp/tmp253myhoz.py\", line 4, in multiples_of_num\n    return [round(n * i, 10) for i in range(1, m + 1)]\nTypeError: 'float' object cannot be interpreted as an integer", "passed": false}
{"task_id": 22, "requirement": "Functionality Extension", "completion": "def find_first_duplicate(arr):\n    seen = set()\n    duplicates = []\n    \n    for num in arr:\n        if num in seen and num not in duplicates:\n            duplicates.append(num)\n        seen.add(num)\n    \n    return duplicates\n", "result": "passed", "passed": true}
{"task_id": 23, "requirement": "Functionality Extension", "completion": "def maximum_sum(list_of_lists):\n    # Handle empty input\n    if not list_of_lists:\n        return 0\n    \n    # Handle non-list inputs\n    if not isinstance(list_of_lists, list):\n        raise TypeError(\"Input must be a list of lists\")\n    \n    # Verify all elements are lists and contain numbers\n    for sublist in list_of_lists:\n        if not isinstance(sublist, list):\n            raise TypeError(\"All elements must be lists\")\n        if not all(isinstance(x, (int, float)) for x in sublist):\n            raise TypeError(\"All elements in sublists must be numbers\")\n        \n    # Find maximum sum including negative numbers\n    max_sum = float('-inf')  # Initialize with negative infinity\n    for sublist in list_of_lists:\n        current_sum = sum(sublist)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n", "result": "passed", "passed": true}
{"task_id": 24, "requirement": "Functionality Extension", "completion": "def binary_to_decimal(binary):\n    try:\n        # Strip leading zeros and handle empty string case\n        binary = str(binary).lstrip('0')\n        if not binary:\n            return 0\n            \n        # Validate that the input contains only 0s and 1s\n        if not all(bit in '01' for bit in binary):\n            raise ValueError\n            \n        decimal = int(binary, 2)\n        return decimal\n    except ValueError:\n        return \"Invalid binary number\"\n", "result": "passed", "passed": true}
{"task_id": 25, "requirement": "Functionality Extension", "completion": "def find_product(arr):\n    # Handle empty array case\n    if not arr:\n        return 0\n    \n    # Convert array to set to remove duplicates\n    unique_elements = set(arr)\n    \n    # Calculate product of unique elements\n    product = 1\n    for num in unique_elements:\n        product *= num\n        \n    return product\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpsxt5fho4.py\", line 12, in <module>\n    assert find_product([-1, -2, 3, 3], 4) == 2\nTypeError: find_product() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 26, "requirement": "Functionality Extension", "completion": "def check_k_elements(tuple_list, k):\n    # Counter for tuples with exactly k elements\n    count_k_tuples = 0\n    \n    # Check each tuple's length\n    for tup in tuple_list:\n        if len(tup) == k:\n            count_k_tuples += 1\n    \n    # Create set of all elements for completeness check\n    elements = set()\n    for tup in tuple_list:\n        elements.update(tup)\n    \n    # Check if all numbers from 0 to k-1 are present\n    required_elements = set(range(k))\n    has_all_elements = elements == required_elements\n    \n    return has_all_elements, count_k_tuples\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp9jflq4r1.py\", line 16, in <module>\n    assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == 1\nAssertionError", "passed": false}
{"task_id": 27, "requirement": "Functionality Extension", "completion": "def remove(string_list, extra_chars=''):\n    # Convert extra_chars to a set for efficient lookup\n    chars_to_remove = set(extra_chars)\n    \n    return [''.join(char for char in s \n                   if not char.isdigit() and char not in chars_to_remove)\n            for s in string_list]\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmppbii6pxa.py\", line 7, in <module>\n    assert remove_extended(['abcd123', '456defg'], 'abcdef') == ['d', 'g']\nNameError: name 'remove_extended' is not defined", "passed": false}
{"task_id": 28, "requirement": "Functionality Extension", "completion": "from functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef binomial_coeff(n: int, k: int) -> int:\n    \"\"\"\n    Calculate the binomial coefficient C(n,k) efficiently for large numbers using memoization.\n    \n    Args:\n        n (int): Total number of items\n        k (int): Number of items to choose\n        \n    Returns:\n        int: The binomial coefficient value\n        \n    Raises:\n        ValueError: If n < 0 or k < 0 or k > n\n    \"\"\"\n    # Input validation\n    if n < 0 or k < 0 or k > n:\n        raise ValueError(\"Invalid input: Require n >= 0, k >= 0, and k <= n\")\n    \n    # Optimize by using the smaller value of k or n-k\n    k = min(k, n - k)\n    \n    # Base cases\n    if k == 0:\n        return 1\n    if k == 1:\n        return n\n    \n    # Use Pascal's identity: C(n,k) = C(n-1,k-1) + C(n-1,k)\n    return binomial_coeff(n - 1, k - 1) + binomial_coeff(n - 1, k)\n", "result": "passed", "passed": true}
{"task_id": 29, "requirement": "Functionality Extension", "completion": "def get_odd_occurrence(arr: list, arr_size: int) -> list:\n    # Dictionary to store the frequency of each element\n    count_dict = {}\n    \n    # Count occurrences of each element\n    for element in arr:\n        count_dict[element] = count_dict.get(element, 0) + 1\n    \n    # Find all elements with odd occurrences\n    odd_elements = [num for num, count in count_dict.items() if count % 2 != 0]\n    \n    return odd_elements\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpzuo1vkky.py\", line 10, in <module>\n    assert get_odd_occurrence([1, 2, 3, 1, 2, 3, 1, 3]) == [1, 3]\nTypeError: get_odd_occurrence() missing 1 required positional argument: 'arr_size'", "passed": false}
{"task_id": 30, "requirement": "Functionality Extension", "completion": "def count_substring_with_equal_ends(s):\n    if not s:\n        return 0\n        \n    n = len(s)\n    count = 0\n    \n    # Consider each possible substring\n    for i in range(n):\n        # Skip if first character is not alphabetic\n        if not s[i].isalpha():\n            continue\n            \n        for j in range(i, n):\n            # Only count if both first and last characters are alphabetic\n            # and they match (case-sensitive)\n            if s[j].isalpha() and s[i] == s[j]:\n                count += 1\n                \n    return count\n", "result": "passed", "passed": true}
{"task_id": 31, "requirement": "Functionality Extension", "completion": "from heapq import heappush, heappop\nfrom collections import Counter\n\ndef func(nums, k):\n    # Handle case where k is 0\n    if k == 0:\n        return []\n    \n    # Count frequency of each number\n    freq_counter = Counter(nums)\n    \n    # Create min heap to maintain top k elements\n    heap = []\n    \n    for num, freq in freq_counter.items():\n        heappush(heap, (freq, num))\n        if len(heap) > k:\n            heappop(heap)\n    \n    # Extract the k most frequent elements\n    result = []\n    while heap:\n        freq, num = heappop(heap)\n        result.append(num)\n    \n    return result[::-1]\n", "result": "passed", "passed": true}
{"task_id": 32, "requirement": "Functionality Extension", "completion": "def max_prime_factors(n, return_all=False):\n    prime_factors = []\n    \n    # Handle division by 2\n    while n % 2 == 0:\n        prime_factors.append(2)\n        n = n // 2\n    \n    # Check odd numbers up to sqrt(n)\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        while n % i == 0:\n            prime_factors.append(i)\n            n = n // i\n    \n    # If n is still greater than 2, it's prime itself\n    if n > 2:\n        prime_factors.append(int(n))  # Convert to int to handle large numbers\n    \n    # Return based on return_all parameter\n    if return_all:\n        return prime_factors\n    else:\n        return max(prime_factors) if prime_factors else -1\n", "result": "passed", "passed": true}
{"task_id": 33, "requirement": "Functionality Extension", "completion": "def decimal_to_binary(decimal_input):\n    def convert_single_number(decimal_num):\n        if decimal_num == 0:\n            return \"0\"\n        \n        # Handle negative numbers\n        is_negative = decimal_num < 0\n        decimal_num = abs(decimal_num)\n        \n        binary = \"\"\n        while decimal_num > 0:\n            binary = str(decimal_num % 2) + binary\n            decimal_num //= 2\n        \n        return \"-\" + binary if is_negative else binary\n    \n    # Handle single number\n    if isinstance(decimal_input, (int, float)):\n        return convert_single_number(int(decimal_input))\n    \n    # Handle list of numbers\n    elif isinstance(decimal_input, list):\n        return [convert_single_number(int(num)) for num in decimal_input]\n    \n    else:\n        raise TypeError(\"Input must be a number or a list of numbers\")\n", "result": "passed", "passed": true}
{"task_id": 34, "requirement": "Functionality Extension", "completion": "def find_missing(arr):\n    # Handle empty array\n    if not arr:\n        return []\n    \n    missing_nums = []\n    # Iterate through the range from first to last number\n    for i in range(arr[0], arr[-1]):\n        # If number i is not in array, it's missing\n        if i not in arr:\n            missing_nums.append(i)\n    \n    return missing_nums\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpbx9atbka.py\", line 12, in <module>\n    assert find_missing([1,3,6], 3) == [2, 4, 5]\nTypeError: find_missing() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 35, "requirement": "Functionality Extension", "completion": "def find_rect_num(n):\n    \"\"\"\n    Find rectangular number(s) for a single integer or list of integers.\n    \n    Args:\n        n (int or list): Single integer or list of integers (all must be > 0)\n    \n    Returns:\n        int or list: Single rectangular number or list of rectangular numbers\n    \n    Raises:\n        ValueError: If any input number is less than or equal to 0\n    \"\"\"\n    def calculate_single(x):\n        if x <= 0:\n            raise ValueError(\"All numbers must be positive integers\")\n        return x * (x + 1)\n    \n    # Handle list input\n    if isinstance(n, list):\n        return [calculate_single(x) for x in n]\n    \n    # Handle single integer input\n    return calculate_single(n)\n", "result": "passed", "passed": true}
{"task_id": 36, "requirement": "Functionality Extension", "completion": "def find_nth_digit(numerator, denominator, n):\n    if denominator == 0:\n        raise ValueError(\"Denominator cannot be zero\")\n    \n    # Work with absolute values\n    numerator = abs(numerator)\n    denominator = abs(denominator)\n    \n    # Get the decimal digits\n    quotient = numerator // denominator\n    remainder = numerator % denominator\n    \n    # If n is 0, return the digit before decimal point\n    if n == 0:\n        return str(quotient)[-1]\n    \n    # Calculate decimal digits\n    decimal_digits = \"\"\n    remainders = {}\n    position = 0\n    \n    while remainder != 0 and position < n + 1:\n        if remainder in remainders:\n            break\n            \n        remainders[remainder] = position\n        remainder *= 10\n        decimal_digits += str(remainder // denominator)\n        remainder %= denominator\n        position += 1\n    \n    # If we have enough digits\n    if n <= len(decimal_digits):\n        return decimal_digits[n-1]\n    else:\n        return \"0\"\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpddfqcy95.py\", line 30, in <module>\n    assert find_nth_digit(-1, 2, 1) == 5\nAssertionError", "passed": false}
{"task_id": 37, "requirement": "Functionality Extension", "completion": "def sort_mixed_list(mixed_list, reverse_strings=False):\n    # Separate integers and strings\n    integers = [x for x in mixed_list if isinstance(x, int)]\n    strings = [x for x in mixed_list if isinstance(x, str)]\n    \n    # Sort integers (always ascending)\n    integers.sort()\n    \n    # Sort strings based on reverse_strings parameter\n    strings.sort(reverse=reverse_strings)\n    \n    # Return combined sorted list\n    return integers + strings\n", "result": "passed", "passed": true}
{"task_id": 38, "requirement": "Functionality Extension", "completion": "def div_even_odd(numbers):\n    # Initialize variables to store first even and odd numbers\n    first_even = None\n    first_odd = None\n    \n    # Find first even and odd numbers, including negative numbers\n    for num in numbers:\n        # Check for even number using absolute value\n        if first_even is None and abs(num) % 2 == 0:\n            first_even = num\n        # Check for odd number using absolute value\n        if first_odd is None and abs(num) % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    \n    # Check if both even and odd numbers were found\n    if first_even is None or first_odd is None:\n        return \"Cannot perform division: missing even or odd number\"\n    \n    # Perform division and return result\n    return first_even / first_odd\n", "result": "passed", "passed": true}
{"task_id": 39, "requirement": "Functionality Extension", "completion": "from collections import Counter\nfrom typing import List\n\ndef rearrange_string(s: str) -> List[str]:\n    def backtrack(counter: Counter, prev_char: str, current: str, all_results: List[str]):\n        # Base case: if current string length equals input string length\n        if len(current) == len(s):\n            all_results.append(current)\n            return\n        \n        # Try each available character that's not the same as previous\n        for char in counter:\n            if counter[char] > 0 and char != prev_char:\n                # Use the character\n                counter[char] -= 1\n                backtrack(counter, char, current + char, all_results)\n                # Backtrack\n                counter[char] += 1\n    \n    # Initialize variables\n    char_count = Counter(s)\n    results = []\n    \n    # Start backtracking with empty string and no previous character\n    backtrack(char_count, '', '', results)\n    \n    # Return all found arrangements, or empty list if none possible\n    return sorted(results) if results else []\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpybwe60o3.py\", line 24, in <module>\n    assert set(rearange_string('aabb')) == {'abab', 'baba'}\nNameError: name 'rearange_string' is not defined", "passed": false}
{"task_id": 40, "requirement": "Functionality Extension", "completion": "from collections import Counter\n\ndef freq_element(nested_list):\n    def flatten_and_get_ints(lst):\n        # Helper function to recursively flatten list and collect integers\n        numbers = []\n        for item in lst:\n            if isinstance(item, list):\n                numbers.extend(flatten_and_get_ints(item))\n            elif isinstance(item, int):\n                numbers.append(item)\n        return numbers\n    \n    # Get all integers from nested structure and count frequencies\n    all_integers = flatten_and_get_ints(nested_list)\n    return dict(Counter(all_integers))\n\n# Example usage\nif __name__ == \"__main__\":\n    # Test cases with different nesting levels\n    test_list = [\n        [1, 2, [3, 4]], \n        [2, [3, [4, 1]], 5], \n        [[1, 2], 3]\n    ]\n    result = freq_element(test_list)\n    print(result)  # Output: {1: 3, 2: 2, 3: 2, 4: 2, 5: 1}\n    \n    # Test with mixed types and deep nesting\n    test_list2 = [\n        [1, \"a\", [2, [3, 4.5]], [5]],\n        [1, [2, [\"b\", [6, 1]]]]\n    ]\n    print(freq_element(test_list2))  # Output: {1: 3, 2: 2, 3: 1, 5: 1, 6: 1}\n", "result": "passed", "passed": true}
{"task_id": 41, "requirement": "Functionality Extension", "completion": "def filter_evennumbers(numbers):\n    # First filter out non-integer values, then filter even numbers\n    return list(filter(lambda x: x % 2 == 0, \n                filter(lambda x: isinstance(x, int), numbers)))\n", "result": "passed", "passed": true}
{"task_id": 42, "requirement": "Functionality Extension", "completion": "def find_sum(arr):\n    # Create a dictionary to store element frequencies\n    freq = {}\n    \n    # Count frequency of each element (including negative numbers)\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Calculate sum of repeated elements (works for both positive and negative numbers)\n    repeated_sum = sum(num for num, count in freq.items() if count > 1)\n    \n    return repeated_sum\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpieq3iu03.py\", line 10, in <module>\n    assert find_sum([-1, -2, -3, -1, -1], 5) == -2\nTypeError: find_sum() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 43, "requirement": "Functionality Extension", "completion": "import re\n\ndef text_match(text):\n    pattern = r'^[a-z]+(?:_[a-z]+)+$'\n    if re.search(pattern, text):\n        return True\n    return False\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpm2ioq6nb.py\", line 7, in <module>\n    assert text_match('abc_def_ghi') == 'Found a match!'\nAssertionError", "passed": false}
{"task_id": 45, "requirement": "Functionality Extension", "completion": "def get_gcd(arr):\n    from math import gcd\n    from functools import reduce\n    \n    if not arr:\n        return None\n    \n    # Filter out zeros and get absolute values\n    non_zero = [abs(num) for num in arr if num != 0]\n    \n    # If all elements are zero, return 0\n    if not non_zero:\n        return 0\n    \n    # Calculate GCD of non-zero elements\n    return reduce(gcd, non_zero)\n", "result": "passed", "passed": true}
{"task_id": 46, "requirement": "Functionality Extension", "completion": "def test_distinct(numbers, tolerance=1e-10):\n    \"\"\"\n    Check if all numbers in the given sequence are distinct, with special handling for floating-point numbers.\n    \n    Args:\n        numbers: An iterable of numbers (integers or floats)\n        tolerance: The minimum difference between numbers to consider them distinct (default: 1e-10)\n        \n    Returns:\n        bool: True if all numbers are distinct, False otherwise\n    \"\"\"\n    if not numbers:\n        return True\n    \n    # Convert to list and sort\n    sorted_nums = sorted(numbers)\n    \n    # Compare adjacent numbers\n    for i in range(len(sorted_nums) - 1):\n        if abs(sorted_nums[i] - sorted_nums[i + 1]) < tolerance:\n            return False\n            \n    return True\n", "result": "passed", "passed": true}
{"task_id": 47, "requirement": "Functionality Extension", "completion": "def compute_last_digit(a, b):\n    # Handle cases involving zero\n    if a == b:\n        return 1\n    if a > b:\n        return 0\n    if b == 0:\n        return 1\n    \n    # If a is 0, we need to calculate the entire b!\n    if a == 0:\n        result = 1\n        for i in range(1, b + 1):\n            result = (result * (i % 10)) % 10\n        return result\n    \n    # Original logic for non-zero cases\n    result = 1\n    for i in range(a + 1, b + 1):\n        result = (result * (i % 10)) % 10\n        \n    return result\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpewmrhau4.py\", line 20, in <module>\n    assert compute_last_digit(0, 5) == 1\nAssertionError", "passed": false}
{"task_id": 48, "requirement": "Functionality Extension", "completion": "def odd_bit_set_number(n):\n    # Get absolute value of the input number\n    num = abs(n)\n    \n    # Create a mask with all odd bits set (1,3,5,...)\n    # In binary: ...1010101\n    mask = 0xAAAAAAAA\n    \n    # Perform OR operation to set all odd bits\n    result = num | mask\n    \n    # Preserve the original sign\n    return -result if n < 0 else result\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp_9y7anm6.py\", line 11, in <module>\n    assert odd_bit_set_number(-10) == 15\nAssertionError", "passed": false}
{"task_id": 49, "requirement": "Functionality Extension", "completion": "def specified_element(matrix, position=0):\n    \"\"\"\n    Extract elements from a specified position in each sublist of a 2D list.\n    Supports both positive and negative indices.\n    \n    Args:\n        matrix (list): A 2D list/matrix\n        position (int, optional): Position of element to extract (defaults to 0)\n                                Negative indices count from the end\n    \n    Returns:\n        list: Elements from the specified position of each sublist\n    \"\"\"\n    result = []\n    for sublist in matrix:\n        # Check if sublist exists and has enough elements\n        if sublist:\n            # For negative indices, check against negative length\n            # For positive indices, check against positive length\n            if (position < 0 and abs(position) <= len(sublist)) or \\\n               (position >= 0 and position < len(sublist)):\n                result.append(sublist[position])\n    return result\n", "result": "passed", "passed": true}
{"task_id": 51, "requirement": "Functionality Extension", "completion": "def check_equilateral(side1, side2, side3):\n    if side1 == side2 == side3:\n        return \"This is an equilateral triangle\"\n    elif side1 == side2 or side2 == side3 or side1 == side3:\n        return \"This is an isosceles triangle\"\n    else:\n        return \"This is a scalene triangle\"\n\n# Example usage\nprint(check_equilateral(5, 5, 5))    # Equilateral\nprint(check_equilateral(5, 5, 4))    # Isosceles\nprint(check_equilateral(3, 4, 5))    # Scalene\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpp34_zd99.py\", line 12, in <module>\n    assert check_equilateral(5, 5, 3) == 'isosceles'\nAssertionError", "passed": false}
{"task_id": 52, "requirement": "Functionality Extension", "completion": "def parallelogram_area(measurements):\n    \"\"\"\n    Calculate the areas of multiple parallelograms.\n    \n    Args:\n        measurements (list): List of tuples, where each tuple contains (base, height)\n        \n    Returns:\n        list: List of areas for each parallelogram\n    \"\"\"\n    if not isinstance(measurements, list):\n        raise TypeError(\"Input must be a list of tuples\")\n    \n    areas = []\n    for base, height in measurements:\n        if not (isinstance(base, (int, float)) and isinstance(height, (int, float))):\n            raise TypeError(\"Base and height must be numbers\")\n        if base <= 0 or height <= 0:\n            raise ValueError(\"Base and height must be positive numbers\")\n        \n        areas.append(base * height)\n    \n    return areas\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmppqnxrczm.py\", line 12, in <module>\n    assert parallelogram_area_list([(10, 20), (15, 20), (8, 9)]) == [200, 300, 72]\nNameError: name 'parallelogram_area_list' is not defined", "passed": false}
{"task_id": 53, "requirement": "Functionality Extension", "completion": "def check_equality(text):\n    if not text:  # Check if string is empty\n        return False\n    \n    # Convert first and last characters to lowercase for case-insensitive comparison\n    first_char = text[0].lower()\n    last_char = text[-1].lower()\n    \n    return first_char == last_char\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpen_p3fot.py\", line 8, in <module>\n    assert check_equality('Abca') == 'Equal'\nAssertionError", "passed": false}
{"task_id": 54, "requirement": "Functionality Extension", "completion": "def counting_sort(arr):\n    if not arr:\n        return arr\n    \n    # Find range of array elements\n    max_val = max(arr)\n    min_val = min(arr)\n    range_of_elements = max_val - min_val + 1\n    \n    # Initialize counting array with zeros\n    count = [0] * range_of_elements\n    \n    # Count occurrences of each element\n    # Shift the index by min_val to handle negative numbers\n    for num in arr:\n        count[num - min_val] += 1\n        \n    # Reconstruct the sorted array\n    index = 0\n    for i in range(range_of_elements):\n        # Add each number current_num = i + min_val\n        # count[i] times to the original array\n        while count[i] > 0:\n            arr[index] = i + min_val\n            index += 1\n            count[i] -= 1\n            \n    return arr\n", "result": "passed", "passed": true}
{"task_id": 55, "requirement": "Functionality Extension", "completion": "def tn_gp(a: float, r: float, n: int) -> float:\n    \"\"\"\n    Calculate the nth term of a geometric progression with floating-point precision.\n    \n    Parameters:\n        a (float): First term of the geometric progression\n        r (float): Common ratio\n        n (int): Position of the term to find (must be positive integer)\n    \n    Returns:\n        float: The nth term of the geometric progression\n        \n    Raises:\n        ValueError: If n is less than 1 or if inputs are invalid\n        TypeError: If n is not an integer\n    \"\"\"\n    # Input validation\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    try:\n        a = float(a)\n        r = float(r)\n    except (ValueError, TypeError):\n        raise ValueError(\"First term and ratio must be numeric values\")\n        \n    return float(a * (r ** (n - 1)))\n", "result": "passed", "passed": true}
{"task_id": 56, "requirement": "Functionality Extension", "completion": "def check(num):\n    # Handle negative numbers by storing the sign\n    is_negative = num < 0\n    # Work with absolute value\n    abs_num = abs(num)\n    \n    # Convert to string and reverse\n    num_str = str(abs_num)\n    reverse_num = int(num_str[::-1])\n    \n    # Apply the original sign to the reversed number\n    if is_negative:\n        reverse_num = -reverse_num\n    \n    # Check if number is one less than twice its reverse\n    return num == (2 * reverse_num - 1)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp8bwbav_v.py\", line 15, in <module>\n    assert check(-37) == True\nAssertionError", "passed": false}
{"task_id": 57, "requirement": "Functionality Extension", "completion": "def find_max_num(digits):\n    # Input validation\n    if not digits:\n        return 0\n    if not all(isinstance(d, int) and 0 <= d <= 9 for d in digits):\n        raise ValueError(\"Input must be a list of single digits (0-9)\")\n    \n    # Convert digits to strings and sort in descending order\n    # This naturally handles duplicates as they'll be placed next to each other\n    digits_str = [str(d) for d in digits]\n    digits_str.sort(reverse=True)\n    \n    # Join the sorted digits to form the largest number\n    return int(''.join(digits_str))\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpfgmajpoq.py\", line 13, in <module>\n    assert find_max_num([1, 1, 2, 2], 4) == 2211\nTypeError: find_max_num() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 58, "requirement": "Functionality Extension", "completion": "def opposite_signs(number_pairs: list[tuple[int, int]]) -> list[bool]:\n    \"\"\"\n    Check if pairs of integers have opposite signs.\n    \n    Args:\n        number_pairs (list[tuple[int, int]]): List of integer pairs\n        \n    Returns:\n        list[bool]: List of boolean values indicating whether each pair has opposite signs\n    \n    Example:\n        >>> opposite_signs([(1, -2), (-3, -4), (5, -6)])\n        [True, False, True]\n    \"\"\"\n    return [pair[0] * pair[1] < 0 for pair in number_pairs]\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpd3pwhl56.py\", line 3, in <module>\n    assert opposite_signs_list([(1, -2), (3, 2), (-10, -10)]) == [True, False, False]\nNameError: name 'opposite_signs_list' is not defined", "passed": false}
{"task_id": 59, "requirement": "Functionality Extension", "completion": "def is_octagonal(n):\n    \"\"\"\n    Calculate octagonal number(s).\n    \n    Args:\n        n: Can be either:\n           - int: The position of the octagonal number to calculate (must be positive)\n           - list: A list of positions to calculate multiple octagonal numbers\n    \n    Returns:\n        int or list: Single octagonal number if n is int, list of octagonal numbers if n is list\n    \n    Raises:\n        ValueError: If n (or any value in n if it's a list) is less than or equal to 0\n    \"\"\"\n    def calculate_octagonal(x):\n        if x <= 0:\n            raise ValueError(\"Values must be positive integers\")\n        return x * (3 * x - 2)\n    \n    if isinstance(n, list):\n        return [calculate_octagonal(i) for i in n]\n    else:\n        return calculate_octagonal(n)\n", "result": "passed", "passed": true}
{"task_id": 60, "requirement": "Functionality Extension", "completion": "def max_len_sub(arr):\n    if not arr or len(arr) < 2:\n        return len(arr)\n    \n    n = len(arr)\n    # dp[i] stores the length of subsequence ending at index i\n    dp = [1] * n\n    # Also store the previous element used in the subsequence\n    prev_element = [-1] * n\n    max_length = 1\n    \n    for i in range(1, n):\n        for j in range(i):\n            # Check if current element can form a valid subsequence with previous element\n            curr_diff = arr[i] - arr[j]\n            # If there's no previous element for j, any difference is valid\n            prev_diff = arr[j] - arr[prev_element[j]] if prev_element[j] != -1 else curr_diff\n            \n            # Check if differences have the same sign (both positive or both negative)\n            if (prev_element[j] == -1 or \n                (curr_diff > 0 and prev_diff > 0) or \n                (curr_diff < 0 and prev_diff < 0)):\n                if dp[j] + 1 > dp[i]:\n                    dp[i] = dp[j] + 1\n                    prev_element[i] = j\n        max_length = max(max_length, dp[i])\n    \n    return max_length\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpep0zsrz4.py\", line 25, in <module>\n    assert max_len_sub([10, 7, 4, 1, -2], -3) == 5\nTypeError: max_len_sub() takes 1 positional argument but 2 were given", "passed": false}
