{"task_id": 11, "requirement": "Functionality Extension", "completion": "def remove_occ(s: str, char: str, all: bool = False) -> str:\n    \"\"\"\n    Remove the first and last occurrence of the specified character from the string.\n    If 'all' is True, remove all occurrences of the character.\n    \n    Parameters:\n    s (str): The input string.\n    char (str): The character to be removed from the string.\n    all (bool): If True, remove all occurrences of the character. Default is False.\n    \n    Returns:\n    str: The modified string with the specified occurrences of the character removed.\n    \"\"\"\n    if not s or len(char) != 1:\n        return s\n\n    if all:\n        return s.replace(char, \"\")\n    \n    first_occurrence = s.find(char)\n    last_occurrence = s.rfind(char)\n    \n    # If the character does not exist in the string, return the original string\n    if first_occurrence == -1 or last_occurrence == -1:\n        return s\n    \n    # If the first and last occurrences are the same, it means there's only one occurrence\n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence+1:]\n    \n    # Construct the new string without the first and last occurrence of the character\n    part1 = s[:first_occurrence] + s[first_occurrence+1:last_occurrence]\n    part2 = s[last_occurrence+1:]\n    \n    return part1 + part2\n\n# Example usage:\nprint(remove_occ(\"hello world\", \"l\"))  # Output: \"heo word\"\nprint(remove_occ(\"banana\", \"a\"))       # Output: \"bnn\"\nprint(remove_occ(\"apple\", \"p\"))        # Output: \"ale\"\nprint(remove_occ(\"test\", \"x\"))         # Output: \"test\" (no 'x' in the string)\n\n# Removing all occurrences\nprint(remove_occ(\"hello world\", \"l\", all=True))  # Output: \"heo word\"\nprint(remove_occ(\"banana\", \"a\", all=True))       # Output: \"bnn\"\nprint(remove_occ(\"apple\", \"p\", all=True))        # Output: \"ae\"\nprint(remove_occ(\"test\", \"t\", all=True))         # Output: \"es\"\n", "result": "passed", "passed": true}
{"task_id": 12, "requirement": "Functionality Extension", "completion": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n    Treats missing values in rows of varying lengths as zeros.\n    \n    :param matrix: List[List[int]], a 2D list representing the matrix.\n    :return: List[List[int]], the sorted matrix.\n    \"\"\"\n    # Find the maximum row length\n    max_length = max(len(row) for row in matrix)\n    \n    # Pad shorter rows with zeros\n    padded_matrix = [row + [0] * (max_length - len(row)) for row in matrix]\n    \n    # Sort the padded matrix based on the sum of each row\n    sorted_matrix = sorted(padded_matrix, key=sum)\n    \n    return sorted_matrix\n\n# Example usage:\nif __name__ == \"__main__\":\n    matrix = [\n        [3, 4, 7],\n        [1, 2],\n        [8, 0, 2, 5]\n    ]\n    \n    print(\"Original Matrix:\")\n    for row in matrix:\n        print(row)\n    \n    sorted_matrix = sort_matrix(matrix)\n    print(\"\\nSorted Matrix:\")\n    for row in sorted_matrix:\n        print(row)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp24krmmjy.py\", line 23, in <module>\n    assert sort_matrix([[1, 2, 3], [4, 5], [6]]) == [[6], [4, 5], [1, 2, 3]]\nAssertionError", "passed": false}
{"task_id": 13, "requirement": "Functionality Extension", "completion": "from collections import Counter\n\ndef count_common(word_dict, top_n=None):\n    \"\"\"\n    Counts the most common words across all lists in the given dictionary.\n    \n    :param word_dict: A dictionary where each value is a list of words.\n    :param top_n: Optional; the number of top frequent words to return. If None, returns all words.\n    :return: A list of tuples (word, count) sorted by frequency, or a Counter object if top_n is None.\n    \"\"\"\n    # Flatten the list of words from the dictionary values\n    all_words = [word for sublist in word_dict.values() for word in sublist]\n    \n    # Count the frequency of each word\n    word_counts = Counter(all_words)\n    \n    if top_n is not None:\n        # Return only the top_n most common words\n        return word_counts.most_common(top_n)\n    else:\n        # Return the full counter object\n        return word_counts\n\n# Example usage:\nexample_dict = {\n    'doc1': ['apple', 'banana', 'apple'],\n    'doc2': ['banana', 'cherry', 'apple', 'apple'],\n    'doc3': ['cherry', 'banana']\n}\n\ntop_2_words = count_common(example_dict, top_n=2)\nprint(top_2_words)  # Prints the top 2 most common words and their counts\n\nall_words = count_common(example_dict)\nprint(all_words.most_common())  # Prints the most common words and their counts\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp93sltyfj.py\", line 23, in <module>\n    assert count_common(['apple', 'banana', 'apple', 'orange', 'banana', 'banana'], 2) == [('banana', 3), ('apple', 2)]\n  File \"/tmp/tmp93sltyfj.py\", line 4, in count_common\n    all_words = [word for sublist in word_dict.values() for word in sublist]\nAttributeError: 'list' object has no attribute 'values'", "passed": false}
{"task_id": 14, "requirement": "Functionality Extension", "completion": "def find_volume(dimensions):\n    \"\"\"\n    Calculate the volume of a triangular prism given a list or tuple of dimensions.\n    \n    Parameters:\n    - dimensions (list/tuple): A list or tuple containing three elements:\n                               [base, height_triangle, length]\n                               where base is the length of the base of the triangular face,\n                               height_triangle is the height of the triangular face (perpendicular distance from the base to the opposite vertex),\n                               and length is the length of the prism (distance between the two triangular faces).\n    \n    Returns:\n    float: The volume of the triangular prism.\n    \"\"\"\n    if not isinstance(dimensions, (list, tuple)) or len(dimensions) != 3:\n        raise ValueError(\"Input must be a list or tuple of three elements: [base, height_triangle, length]\")\n    \n    base, height_triangle, length = dimensions\n    \n    # Calculate the area of the triangular base\n    base_area = 0.5 * base * height_triangle\n    \n    # Calculate the volume of the prism\n    volume = base_area * length\n    \n    return volume\n\n# Example usage:\ndimensions = [5, 4, 10]  # base, height_triangle, length\nvolume = find_volume(dimensions)\nprint(f\"The volume of the triangular prism is {volume} cubic units.\")\n", "result": "passed", "passed": true}
{"task_id": 15, "requirement": "Functionality Extension", "completion": "import re\n\ndef split_lowerstring(input_string, include_lower=False):\n    if include_lower:\n        # Include lowercase letters at the start of each segment\n        pattern = r'([a-z])([^a-z]*)'\n    else:\n        # Split at lowercase letters but do not include them\n        pattern = r'(?<=[a-z])'\n    \n    if include_lower:\n        # Find all matches and combine the lowercase letter with the following characters\n        matches = re.findall(pattern, input_string)\n        result = [lower + rest for lower, rest in matches]\n    else:\n        # Split the string at lowercase letters\n        result = re.split(pattern, input_string)\n        # Filter out any empty strings that may result from splitting\n        result = [segment for segment in result if segment]\n\n    return result\n\n# Example usage:\nexample_string = \"HelloWorldPython\"\n\n# Without including lowercase letters\nresult1 = split_lowerstring(example_string)\nprint(result1)  # Output: ['H', 'ello', 'W', 'orld', 'P', 'ython']\n\n# Including lowercase letters\nresult2 = split_lowerstring(example_string, include_lower=True)\nprint(result2)  # Output: ['hHello', 'wWorld', 'pPython']\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpxltolmzq.py\", line 27, in <module>\n    assert split_lowerstring('AbCd', include_lower=True) == ['Ab', 'Cd']\nAssertionError", "passed": false}
{"task_id": 16, "requirement": "Functionality Extension", "completion": "import re\n\ndef text_lowercase_underscore(text):\n    # Define the pattern to match sequences of lowercase letters joined with underscores\n    pattern = r'\\b[a-z]+(_[a-z]+)+\\b'\n    \n    # Use re.search to find if there is at least one occurrence of the pattern in the text\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'No match found!'\n\n# Example usage:\nexample_text = \"This is a_test_string with some_lowercase_sequences and_more_examples.\"\nresult = text_lowercase_underscore(example_text)\nprint(result)  # Output should be 'Found a match!'\n\nexample_text_no_match = \"This is A_TEST_STRING with NO_lowercase_sequences.\"\nresult_no_match = text_lowercase_underscore(example_text_no_match)\nprint(result_no_match)  # Output should be 'No match found!'\n", "result": "passed", "passed": true}
{"task_id": 17, "requirement": "Functionality Extension", "completion": "def square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square after rounding the side length to the nearest integer.\n    \n    Parameters:\n    side_length (float): The length of one side of the square.\n    \n    Returns:\n    int: The rounded perimeter of the square.\n    \"\"\"\n    if side_length < 0:\n        raise ValueError(\"Side length cannot be negative.\")\n    # Round the side length to the nearest integer\n    rounded_side_length = round(side_length)\n    # Calculate the perimeter\n    perimeter = 4 * rounded_side_length\n    return perimeter\n\n# Example usage:\nside = 5.7\nprint(f\"The perimeter of a square with side length {side} is {square_perimeter(side)}\")\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp6x1uazph.py\", line 12, in <module>\n    assert square_perimeter(4.5) == 20\nAssertionError", "passed": false}
{"task_id": 18, "requirement": "Functionality Extension", "completion": "def remove_dirty_chars(source_str, dirty_chars):\n    \"\"\"\n    Removes characters from source_str that are present in dirty_chars, ignoring case.\n    \n    :param source_str: The original string from which characters will be removed.\n    :param dirty_chars: A string containing characters to be removed from source_str.\n    :return: A new string with the specified characters removed in a case-insensitive manner.\n    \"\"\"\n    # Convert both strings to lowercase for case-insensitive comparison\n    source_str_lower = source_str.lower()\n    dirty_chars_lower = dirty_chars.lower()\n    \n    # Create a set of characters to remove for faster lookup\n    dirty_set = set(dirty_chars_lower)\n    \n    # Use list comprehension to filter out unwanted characters while preserving the original case\n    cleaned_str = ''.join([char for char, lower_char in zip(source_str, source_str_lower) if lower_char not in dirty_set])\n    \n    return cleaned_str\n\n# Example usage:\nsource_string = \"Hello World\"\ndirty_characters = \"ld\"\ncleaned_string = remove_dirty_chars(source_string, dirty_characters)\nprint(cleaned_string)  # Output: \"Heo Wor\"\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpx6tekat5.py\", line 15, in <module>\n    assert remove_dirty_chars('HelloWorld', 'hELLO') == 'World', 'Function should handle case-insensitive character removal.'\nAssertionError: Function should handle case-insensitive character removal.", "passed": false}
{"task_id": 19, "requirement": "Functionality Extension", "completion": "def test_duplicate(nums):\n    # Dictionary to keep track of counts of each element\n    count_dict = {}\n    \n    # Iterate through the list and count occurrences of each element\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # List to store duplicates\n    duplicates = []\n    \n    # Check which elements have a count greater than 1\n    for num, count in count_dict.items():\n        if count > 1:\n            duplicates.append(num)\n    \n    return duplicates\n\n# Example usage:\nnums = [1, 2, 3, 4, 5, 1, 2]\nprint(test_duplicate(nums))  # Output: [1, 2]\n\nnums = [1, 2, 3, 4, 5]\nprint(test_duplicate(nums))  # Output: []\n", "result": "passed", "passed": true}
{"task_id": 20, "requirement": "Functionality Extension", "completion": "def is_woodall(num):\n    \"\"\"\n    Check if the given number is a Woodall number or return a list of all Woodall numbers up to the given number.\n    \n    A Woodall number is defined as n * 2^n - 1 for some integer n.\n    \n    Parameters:\n    num (int): The number to check or the upper limit for generating Woodall numbers.\n    \n    Returns:\n    bool or list: True if the number is a Woodall number, False otherwise, or a list of Woodall numbers up to num.\n    \"\"\"\n    if num <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    def generate_woodall_numbers(limit):\n        woodall_numbers = []\n        n = 1\n        while True:\n            woodall_number = n * 2**n - 1\n            if woodall_number > limit:\n                break\n            woodall_numbers.append(woodall_number)\n            n += 1\n        return woodall_numbers\n    \n    woodall_list = generate_woodall_numbers(num)\n    \n    # Check if the given number is in the list of Woodall numbers\n    if num in woodall_list:\n        return True\n    else:\n        return woodall_list\n\n# Example usage:\nprint(is_woodall(23))  # True, because 23 is a Woodall number\nprint(is_woodall(50))  # [7, 23, 31, 47], because these are the Woodall numbers up to 50\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpjuc5es0z.py\", line 24, in <module>\n    assert is_woodall(15) == [1, 7, 15]\nAssertionError", "passed": false}
{"task_id": 21, "requirement": "Functionality Extension", "completion": "def multiples_of_num(n, m):\n    \"\"\"\n    Generates a list of m multiples of n.\n    \n    Parameters:\n    n (float or int): The base number to find multiples of.\n    m (int): The number of multiples to generate.\n    \n    Returns:\n    list: A list of m multiples of n, as floating-point numbers.\n    \"\"\"\n    return [float(n * i) for i in range(1, m + 1)]\n\n# Example usage:\nprint(multiples_of_num(5, 4))       # Output: [5.0, 10.0, 15.0, 20.0]\nprint(multiples_of_num(2.5, 3))     # Output: [2.5, 5.0, 7.5]\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpwkauftdz.py\", line 6, in <module>\n    assert multiples_of_num(3, 2.5) == [2.5, 5.0, 7.5]\n  File \"/tmp/tmpwkauftdz.py\", line 2, in multiples_of_num\n    return [float(n * i) for i in range(1, m + 1)]\nTypeError: 'float' object cannot be interpreted as an integer", "passed": false}
{"task_id": 22, "requirement": "Functionality Extension", "completion": "def find_all_duplicates(arr):\n    \"\"\"\n    Finds and returns a list of all duplicate elements in the given array of integers,\n    in the order they first appear.\n\n    :param arr: List[int] - The array of integers to search for duplicates.\n    :return: List[int] - A list of duplicates in the order they first appear, or an empty list if no duplicates exist.\n    \"\"\"\n    seen = set()\n    duplicates = []\n    duplicate_set = set()\n\n    for num in arr:\n        if num in seen:\n            if num not in duplicate_set:\n                duplicates.append(num)\n                duplicate_set.add(num)\n        else:\n            seen.add(num)\n    \n    return duplicates\n\n# Example usage:\nif __name__ == \"__main__\":\n    example_array = [2, 5, 1, 2, 3, 5, 1, 2, 4]\n    print(find_all_duplicates(example_array))  # Output should be [2, 5, 1]\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp_euib9mc.py\", line 17, in <module>\n    assert find_first_duplicate([1, 2, 3, 2, 4, 5, 4]) == [2, 4]\nNameError: name 'find_first_duplicate' is not defined", "passed": false}
{"task_id": 23, "requirement": "Functionality Extension", "completion": "def maximum_sum(list_of_lists):\n    # Check if the list of lists is empty\n    if not list_of_lists:\n        return 0  # Return 0 if the list is empty\n    \n    # Calculate the sum of each sublist and return the maximum sum\n    return max(sum(sublist) for sublist in list_of_lists)\n\n# Example usage:\nexample_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(maximum_sum(example_list))  # Output will be 24\n\nexample_list_with_negatives = [[-1, -2, -3], [4, 5, -6], [7, 8, 9]]\nprint(maximum_sum(example_list_with_negatives))  # Output will be 24\n\nempty_list = []\nprint(maximum_sum(empty_list))  # Output will be 0\n\nmixed_list = [[-1, -2, -3], [], [0]]\nprint(maximum_sum(mixed_list))  # Output will be 0\n", "result": "passed", "passed": true}
{"task_id": 24, "requirement": "Functionality Extension", "completion": "def binary_to_decimal(binary_str):\n    \"\"\"\n    Convert a binary number (given as a string) to its decimal equivalent.\n    \n    Parameters:\n    - binary_str (str): A string representing a binary number.\n    \n    Returns:\n    - int: The decimal equivalent of the binary number.\n    \n    Raises:\n    - ValueError: If the input string is not a valid binary number.\n    \n    Example:\n    >>> binary_to_decimal('001011')\n    11\n    \"\"\"\n    # Validate the input to ensure it only contains '0' and '1'\n    if not all(char in '01' for char in binary_str):\n        raise ValueError(\"Input is not a valid binary number\")\n    \n    # Convert the binary string to decimal\n    return int(binary_str, 2)\n\n# Example usage:\nif __name__ == \"__main__\":\n    binary_number = \"001011\"\n    try:\n        decimal_number = binary_to_decimal(binary_number)\n        print(f\"The decimal equivalent of binary {binary_number} is {decimal_number}\")\n    except ValueError as e:\n        print(e)\n", "result": "passed", "passed": true}
{"task_id": 25, "requirement": "Functionality Extension", "completion": "from functools import reduce\nfrom operator import mul\n\ndef find_product(arr):\n    \"\"\"\n    Calculate the product of non-repeated elements in the given array.\n    \n    Parameters:\n    arr (list): A list of integers, which may include negative numbers and duplicates.\n    \n    Returns:\n    int: The product of the unique elements in the array. Returns 1 if there are no elements.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # Check if the set is empty\n    if not unique_elements:\n        return 1  # Return 1 if there are no elements to avoid issues with multiplication\n    \n    # Use reduce to multiply all unique elements together\n    product = reduce(mul, unique_elements, 1)\n    \n    return product\n\n# Example usage:\narr = [1, -2, 3, -2, 4]\nprint(find_product(arr))  # Output should be 12 because 1 * (-2) * 3 * 4 = -24, but considering unique values 1 * (-2) * 3 * 4 = 24\n\narr_empty = []\nprint(find_product(arr_empty))  # Output should be 1\n\narr_with_zeros = [0, -1, 0, 2, -1]\nprint(find_product(arr_with_zeros))  # Output should be 0\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpx4fh0jm3.py\", line 19, in <module>\n    assert find_product([-1, -2, 3, 3], 4) == 2\nTypeError: find_product() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 26, "requirement": "Functionality Extension", "completion": "def check_k_elements(tuples_list, k):\n    \"\"\"\n    Count the number of tuples in the provided list that have exactly k elements.\n\n    :param tuples_list: List of tuples to be checked.\n    :param k: The number of elements each tuple should have.\n    :return: The count of tuples that have exactly k elements.\n    \"\"\"\n    count = 0  # Initialize the counter to zero\n    # Iterate over each tuple in the list\n    for tup in tuples_list:\n        # Check if the current tuple has exactly k elements\n        if len(tup) == k:\n            count += 1  # Increment the counter if the condition is met\n    return count  # Return the final count\n\n# Example usage:\nexample_tuples = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\nk = 3\nprint(check_k_elements(example_tuples, k))  # Output: 3\n\nexample_tuples_with_mismatch = [(1, 2, 3), (4, 5), (7, 8, 9)]\nk = 3\nprint(check_k_elements(example_tuples_with_mismatch, k))  # Output: 2\n", "result": "passed", "passed": true}
{"task_id": 27, "requirement": "Functionality Extension", "completion": "def remove(strings, extra_chars=''):\n    \"\"\"\n    Removes all digits and specified extra characters from each string in the given list.\n\n    :param strings: List of strings from which digits and extra characters will be removed.\n    :param extra_chars: String containing extra characters to be removed.\n    :return: A new list of strings with all digits and extra characters removed.\n    \"\"\"\n    # Create a set of characters to remove for faster lookup\n    chars_to_remove = set(extra_chars + '0123456789')\n    \n    return [''.join(char for char in string if char not in chars_to_remove) for string in strings]\n\n# Example usage:\nexample_list = [\"abc123\", \"def456ghi789\", \"0jkl\"]\nextra_chars_to_remove = \"!@#$\"\ncleaned_list = remove(example_list, extra_chars_to_remove)\nprint(cleaned_list)  # Output: ['abc', 'defghi', 'jkl']\n\n# Another example without extra characters\ncleaned_list_no_extra = remove(example_list)\nprint(cleaned_list_no_extra)  # Output: ['abc', 'defghi', 'jkl']\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpakue5inc.py\", line 13, in <module>\n    assert remove_extended(['abcd123', '456defg'], 'abcdef') == ['d', 'g']\nNameError: name 'remove_extended' is not defined", "passed": false}
{"task_id": 28, "requirement": "Functionality Extension", "completion": "def binomial_coeff(n, k):\n    \"\"\"\n    Calculate the binomial coefficient, also known as \"n choose k\".\n    \n    Parameters:\n    n (int): The total number of items.\n    k (int): The number of items to choose.\n    \n    Returns:\n    int: The binomial coefficient.\n    \"\"\"\n    # Initialize a memoization table with zeros\n    memo = [[0] * (k + 1) for _ in range(n + 1)]\n    \n    # Base cases\n    for i in range(n + 1):\n        memo[i][0] = 1  # C(i, 0) is always 1\n        if i <= k:\n            memo[i][i] = 1  # C(i, i) is always 1\n    \n    # Fill the memoization table\n    for i in range(1, n + 1):\n        for j in range(1, min(i, k) + 1):\n            memo[i][j] = memo[i - 1][j - 1] + memo[i - 1][j]\n    \n    return memo[n][k]\n\n# Example usage:\nprint(binomial_coeff(5, 2))  # Output: 10\nprint(binomial_coeff(100, 50))  # Output: 100891344545564193334812497256\n", "result": "passed", "passed": true}
{"task_id": 29, "requirement": "Functionality Extension", "completion": "from typing import List\n\ndef get_odd_occurrence(arr: List[int], arr_size: int) -> List[int]:\n    # Create a dictionary to store counts of each element\n    count_dict = {}\n    \n    # Iterate through the array and update counts in the dictionary\n    for num in arr:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Find and collect all elements with an odd count\n    odd_occurrences = [num for num, count in count_dict.items() if count % 2 != 0]\n    \n    return odd_occurrences\n\n# Example usage:\narr = [1, 2, 3, 2, 3, 1, 3, 4, 4, 5]\narr_size = len(arr)\nprint(get_odd_occurrence(arr, arr_size))  # Output should be [3, 5]\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpgss4_6m5.py\", line 18, in <module>\n    assert get_odd_occurrence([1, 2, 3, 1, 2, 3, 1, 3]) == [1, 3]\nTypeError: get_odd_occurrence() missing 1 required positional argument: 'arr_size'", "passed": false}
{"task_id": 30, "requirement": "Functionality Extension", "completion": "def count_substring_with_equal_ends(s):\n    \"\"\"\n    Counts all substrings of the given string s that start and end with the same alphabetic character.\n\n    :param s: Input string\n    :return: The number of substrings that start and end with the same alphabetic character.\n    \"\"\"\n    # Filter out non-alphabetic characters\n    filtered_s = ''.join(filter(str.isalpha, s))\n    \n    n = len(filtered_s)\n    # This will store the frequency of each character in the filtered string\n    char_count = {}\n    for char in filtered_s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # The total count of such substrings\n    total_count = 0\n\n    # For each character, calculate how many substrings can be formed\n    for count in char_count.values():\n        # If a character appears 'k' times, then there are k*(k+1)/2 substrings\n        # that start and end with this character.\n        total_count += count * (count + 1) // 2\n\n    return total_count\n\n# Example usage\ns = \"a!b#c aBc\"\nprint(count_substring_with_equal_ends(s))  # Output should be 7\n", "result": "passed", "passed": true}
{"task_id": 31, "requirement": "Functionality Extension", "completion": "import heapq\nfrom collections import Counter\n\ndef func(lists, k):\n    # Handle the case where k is zero\n    if k == 0:\n        return []\n\n    # Combine all lists into one list\n    combined_list = []\n    for lst in lists:\n        combined_list.extend(lst)\n    \n    # Count the frequency of each element\n    freq_counter = Counter(combined_list)\n    \n    # Use a min-heap to keep track of the top k elements\n    # The heap will store tuples of (-count, number) so that the smallest count is at the top\n    # We negate the count because Python's heapq only supports min-heaps\n    heap = []\n    \n    for num, count in freq_counter.items():\n        if len(heap) < k:\n            heapq.heappush(heap, (count, num))\n        else:\n            # If the current count is greater than the smallest count in the heap,\n            # replace the smallest count with the current count\n            if count > heap[0][0]:\n                heapq.heapreplace(heap, (count, num))\n    \n    # Extract the numbers from the heap and sort them based on their counts and values\n    result = [num for count, num in sorted(heap, reverse=True)]\n    \n    return result\n\n# Example usage:\nlists = [\n    [1, 2, 3],\n    [2, 3, 4],\n    [3, 4, 5]\n]\nk = 0\nprint(func(lists, k))  # Output: []\n\nk = 2\nprint(func(lists, k))  # Output might be [3, 2] depending on the input\n", "result": "passed", "passed": true}
{"task_id": 32, "requirement": "Functionality Extension", "completion": "def max_prime_factors(n, return_all=False):\n    # Handle edge cases where n is less than 2\n    if n < 2:\n        return [] if return_all else None\n    \n    prime_factors = []\n    \n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        prime_factors.append(2)\n        n //= 2\n\n    # Now n must be odd, start checking from 3\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor += 2\n\n    # If n becomes a prime number greater than 2\n    if n > 2:\n        prime_factors.append(n)\n\n    if return_all:\n        return prime_factors\n    else:\n        return prime_factors[-1] if prime_factors else None\n\n# Example usage:\nprint(max_prime_factors(13195))  # Output should be 29\nprint(max_prime_factors(13195, return_all=True))  # Output should be [5, 7, 13, 29]\n", "result": "passed", "passed": true}
{"task_id": 33, "requirement": "Functionality Extension", "completion": "def decimal_to_binary(decimal_number):\n    if decimal_number == 0:\n        return \"0\"\n    \n    binary_digits = []\n    \n    while decimal_number > 0:\n        remainder = decimal_number % 2\n        binary_digits.append(str(remainder))\n        decimal_number //= 2\n    \n    # The binary digits are in reverse order now, so we need to reverse them.\n    binary_digits.reverse()\n    \n    return ''.join(binary_digits)\n\ndef decimals_to_binaries(decimal_numbers):\n    return [decimal_to_binary(num) for num in decimal_numbers]\n\n# Example usage:\ndecimal_list = [10, 255, 0, 8]\nbinary_list = decimals_to_binaries(decimal_list)\nprint(binary_list)  # Output: ['1010', '11111111', '0', '1000']\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpozsl1h49.py\", line 18, in <module>\n    assert decimal_to_binary([10, 1, 20]) == ['1010', '1', '10100']\n  File \"/tmp/tmpozsl1h49.py\", line 5, in decimal_to_binary\n    while decimal_number > 0:\nTypeError: '>' not supported between instances of 'list' and 'int'", "passed": false}
{"task_id": 34, "requirement": "Functionality Extension", "completion": "def find_missing(arr):\n    \"\"\"\n    Finds all missing numbers in a sorted array of consecutive integers.\n    \n    :param arr: List[int] - A list of sorted integers with one or more missing numbers.\n    :return: List[int] - A list of all missing numbers in the sequence.\n    \"\"\"\n    if not arr:\n        return []  # Return an empty list if the array is empty\n\n    missing_numbers = []\n    expected_value = arr[0]\n\n    for num in arr:\n        while expected_value < num:\n            missing_numbers.append(expected_value)\n            expected_value += 1\n        expected_value += 1\n\n    return missing_numbers\n\n# Example usage:\narr = [1, 2, 4, 7, 8, 10]\nmissing_numbers = find_missing(arr)\nprint(missing_numbers)  # Output should be [3, 5, 6, 9]\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp6hg5zurh.py\", line 16, in <module>\n    assert find_missing([1,3,6], 3) == [2, 4, 5]\nTypeError: find_missing() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 35, "requirement": "Functionality Extension", "completion": "def find_rect_num(n):\n    \"\"\"\n    Finds the n-th rectangular number.\n    \n    Parameters:\n    n (int): The position of the rectangular number in the sequence.\n    \n    Returns:\n    int: The n-th rectangular number.\n    \"\"\"\n    return n * (n + 1)\n\ndef find_rect_nums(numbers):\n    \"\"\"\n    Finds the rectangular numbers for a list of integers.\n    \n    Parameters:\n    numbers (list of int): A list of positions for the rectangular numbers.\n    \n    Returns:\n    list of int: A list of corresponding rectangular numbers.\n    \"\"\"\n    return [find_rect_num(n) for n in numbers]\n\n# Example usage:\nnumbers_list = [1, 2, 3, 4, 5]\nrect_numbers = find_rect_nums(numbers_list)\nprint(rect_numbers)  # Output will be [2, 6, 12, 20, 30]\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpx1kabrf1.py\", line 9, in <module>\n    assert find_rect_num([1, 2, 3]) == [2, 6, 12]\n  File \"/tmp/tmpx1kabrf1.py\", line 2, in find_rect_num\n    return n * (n + 1)\nTypeError: can only concatenate list (not \"int\") to list", "passed": false}
{"task_id": 36, "requirement": "Functionality Extension", "completion": "def find_nth_digit(numerator, denominator, n):\n    \"\"\"\n    Finds the nth digit after the decimal point in the result of |numerator| / |denominator|.\n    \n    :param numerator: The numerator of the fraction (can be negative).\n    :param denominator: The denominator of the fraction (can be negative).\n    :param n: The position of the digit after the decimal point to retrieve.\n    :return: The nth digit after the decimal point as an integer, or None if the position exceeds the precision.\n    \"\"\"\n    # Take the absolute values to handle negative inputs\n    numerator = abs(numerator)\n    denominator = abs(denominator)\n\n    # Perform integer division to get the whole number part and the remainder\n    _, remainder = divmod(numerator, denominator)\n    \n    # Initialize variables\n    digits = []\n    seen_remainders = {}\n    \n    # Process the decimal part\n    for i in range(n + 1):  # We go one extra to check for repeats\n        if remainder == 0:\n            break  # Finite decimal, no more digits\n        \n        if remainder in seen_remainders:\n            start_repeat = seen_remainders[remainder]\n            repeat_len = len(digits) - start_repeat\n            # If n is within the repeating part\n            if n >= start_repeat:\n                return int(digits[start_repeat + (n - start_repeat) % repeat_len])\n            else:\n                break  # n is before the repeating part\n        \n        seen_remainders[remainder] = i\n        remainder *= 10\n        quotient, remainder = divmod(remainder, denominator)\n        digits.append(str(quotient))\n    \n    # Check if we have enough digits\n    if n < len(digits):\n        return int(digits[n])\n    else:\n        return None  # Not enough digits or beyond the repeating sequence\n\n# Example usage:\nprint(find_nth_digit(1, 3, 2))       # Should print 3 (for 0.333...)\nprint(find_nth_digit(-1, 7, 5))      # Should print 8 (for 0.142857142857...)\nprint(find_nth_digit(1, -3, 2))      # Should print 3 (for 0.333...)\nprint(find_nth_digit(-1, -7, 5))     # Should print 8 (for 0.142857142857...)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp_15u8r9c.py\", line 36, in <module>\n    assert find_nth_digit(-1, 2, 1) == 5\nAssertionError", "passed": false}
{"task_id": 37, "requirement": "Functionality Extension", "completion": "def sort_mixed_list(mixed_list, reverse_strings=False):\n    # Separate the list into integers and strings\n    integers = [item for item in mixed_list if isinstance(item, int)]\n    strings = [item for item in mixed_list if isinstance(item, str)]\n    \n    # Sort the integers and strings separately\n    sorted_integers = sorted(integers)\n    sorted_strings = sorted(strings, reverse=reverse_strings)\n    \n    # Combine the sorted lists\n    sorted_mixed_list = sorted_integers + sorted_strings\n    \n    return sorted_mixed_list\n\n# Example usage:\nexample_list = [34, \"apple\", 67, \"banana\", 12, \"cherry\"]\n\n# Sort with default settings (strings not reversed)\nsorted_list_default = sort_mixed_list(example_list)\nprint(sorted_list_default)  # Output: [12, 34, 67, 'apple', 'banana', 'cherry']\n\n# Sort with strings in reverse lexicographical order\nsorted_list_reversed_strings = sort_mixed_list(example_list, reverse_strings=True)\nprint(sorted_list_reversed_strings)  # Output: [12, 34, 67, 'cherry', 'banana', 'apple']\n", "result": "passed", "passed": true}
{"task_id": 38, "requirement": "Functionality Extension", "completion": "def div_even_odd(numbers):\n    # Initialize variables to store the first even and odd numbers\n    first_even = None\n    first_odd = None\n    \n    # Iterate through the list to find the first even and odd numbers\n    for num in numbers:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        \n        # Break the loop if both even and odd numbers are found\n        if first_even is not None and first_odd is not None:\n            break\n    \n    # Check if both even and odd numbers were found\n    if first_even is None:\n        return \"No even number found in the list.\"\n    if first_odd is None:\n        return \"No odd number found in the list.\"\n    \n    # Perform the division and return the result\n    try:\n        result = first_even / first_odd\n    except ZeroDivisionError:\n        return \"Cannot divide by zero.\"\n    \n    return result\n\n# Example usage:\nnumbers_list = [-5, -4, 7, 3, 4, 8, 9]\nprint(div_even_odd(numbers_list))  # Output: 1.0\n", "result": "passed", "passed": true}
{"task_id": 39, "requirement": "Functionality Extension", "completion": "from collections import Counter\n\ndef is_valid_permutation(s):\n    \"\"\"Check if the string s has no two adjacent characters that are the same.\"\"\"\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            return False\n    return True\n\ndef generate_permutations(char_count, path, length, result):\n    \"\"\"Recursively generate all permutations and check validity.\"\"\"\n    if len(path) == length:\n        if is_valid_permutation(path):\n            result.append(path)\n        return\n    \n    for char in char_count:\n        if char_count[char] > 0:\n            char_count[char] -= 1\n            generate_permutations(char_count, path + char, length, result)\n            char_count[char] += 1\n\ndef rearrange_string(s):\n    char_count = Counter(s)\n    result = []\n    generate_permutations(char_count, '', len(s), result)\n    return result\n\n# Example usage:\ns = \"aab\"\nprint(rearrange_string(s))  # Possible output: [\"aba\", \"bab\"]\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp5p02fgee.py\", line 27, in <module>\n    assert set(rearange_string('aabb')) == {'abab', 'baba'}\nNameError: name 'rearange_string' is not defined", "passed": false}
{"task_id": 40, "requirement": "Functionality Extension", "completion": "from collections import Counter\n\ndef flatten(nested_list):\n    \"\"\"Recursively flattens a nested list.\"\"\"\n    flat_list = []\n    for item in nested_list:\n        if isinstance(item, list):\n            flat_list.extend(flatten(item))\n        else:\n            flat_list.append(item)\n    return flat_list\n\ndef freq_element(nested_list):\n    \"\"\"Finds the frequency of all integer elements in a nested list of arbitrary depth.\"\"\"\n    # Flatten the nested list\n    flat_list = flatten(nested_list)\n    \n    # Filter out non-integer elements\n    int_list = [item for item in flat_list if isinstance(item, int)]\n    \n    # Use Counter to count the frequency of each integer element\n    freq_counter = Counter(int_list)\n    \n    return freq_counter\n\n# Example usage:\nnested_list = [[1, 2, [3, 4]], [5, [6, [7, 8], 9]], [10, [11, [12]]]]\nresult = freq_element(nested_list)\nprint(result)  # Output will be a Counter object with frequencies of each integer element\n", "result": "passed", "passed": true}
{"task_id": 41, "requirement": "Functionality Extension", "completion": "def filter_evennumbers(numbers):\n    # Filter out non-integer values\n    integers_only = filter(lambda x: isinstance(x, int), numbers)\n    \n    # Filter even numbers from the remaining integer values\n    even_numbers = filter(lambda x: x % 2 == 0, integers_only)\n    \n    # Convert the filter object to a list before returning\n    return list(even_numbers)\n\n# Example usage:\nnumbers_list = [1, 2, 3, 4, 5, 6, 'a', 7.5, True, None, 8]\nfiltered_list = filter_evennumbers(numbers_list)\nprint(filtered_list)  # Output will be [2, 4, 6, 8]\n", "result": "passed", "passed": true}
{"task_id": 42, "requirement": "Functionality Extension", "completion": "from collections import Counter\n\ndef find_sum(arr):\n    \"\"\"\n    Calculate the sum of elements that appear more than once in the array.\n    \n    Parameters:\n    arr (list): The input array which may contain integers (positive or negative).\n    \n    Returns:\n    int: The sum of repeated elements.\n    \"\"\"\n    # Count the occurrences of each element in the array\n    counts = Counter(arr)\n    \n    # Sum the elements that appear more than once\n    total_sum = sum(element for element, count in counts.items() if count > 1)\n    \n    return total_sum\n\n# Example usage:\narr = [1, 2, -3, 2, 4, -5, -5]\nprint(find_sum(arr))  # Output should be -3 because 2 + (-5) = -3\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpll9v87ij.py\", line 11, in <module>\n    assert find_sum([-1, -2, -3, -1, -1], 5) == -2\nTypeError: find_sum() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 43, "requirement": "Functionality Extension", "completion": "import re\n\ndef text_match(text):\n    # Regular expression pattern to match sequences of lowercase letters joined with one or more underscores\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    \n    # Using re.match to check if the pattern matches the entire string from start (^) to end ($)\n    if re.match(pattern, text):\n        return True\n    else:\n        return False\n\n# Example usage:\nprint(text_match(\"abc_def\"))          # Should return True\nprint(text_match(\"abc_def_ghi_jkl\"))  # Should return True\nprint(text_match(\"Abc_def\"))          # Should return False because it starts with an uppercase letter\nprint(text_match(\"abc_def_123\"))      # Should return False because it contains non-lowercase characters\nprint(text_match(\"abc\"))              # Should return True because it is a valid single sequence\nprint(text_match(\"abc__def\"))         # Should return False because it has consecutive underscores\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpnumt2e07.py\", line 17, in <module>\n    assert text_match('abc_def_ghi') == 'Found a match!'\nAssertionError", "passed": false}
{"task_id": 45, "requirement": "Functionality Extension", "completion": "from functools import reduce\nimport math\n\ndef get_gcd(arr):\n    # Filter out zeros\n    non_zero_arr = [x for x in arr if x != 0]\n    \n    # Check if the resulting list is empty\n    if not non_zero_arr:\n        raise ValueError(\"Array must contain at least one non-zero element\")\n    \n    return reduce(lambda x, y: math.gcd(x, y), non_zero_arr)\n\n# Example usage:\nnumbers = [24, 108, 90, 0]\nprint(get_gcd(numbers))  # Output will be 6\n\nnumbers_with_only_zeros = [0, 0, 0]\ntry:\n    print(get_gcd(numbers_with_only_zeros))\nexcept ValueError as e:\n    print(e)  # Output will be \"Array must contain at least one non-zero element\"\n", "result": "passed", "passed": true}
{"task_id": 46, "requirement": "Functionality Extension", "completion": "def test_distinct(numbers):\n    \"\"\"\n    Check if all numbers in the list are distinct.\n    \n    :param numbers: List of integers or floats\n    :return: True if all numbers are distinct, False otherwise\n    \"\"\"\n    # Convert the list into a set to remove duplicates\n    unique_numbers = set(numbers)\n    \n    # Compare the length of the original list with the set\n    return len(numbers) == len(unique_numbers)\n\n# Example usage:\nprint(test_distinct([1.0, 2.5, 3.1, 4.0]))  # Expected output: True\nprint(test_distinct([1.0, 2.5, 2.5, 4.0]))  # Expected output: False\nprint(test_distinct([1, 2.5, 3.1, 4]))      # Expected output: True\nprint(test_distinct([1, 2.5, 2.5, 4]))      # Expected output: False\n", "result": "passed", "passed": true}
{"task_id": 47, "requirement": "Functionality Extension", "completion": "def compute_last_digit(a, b):\n    \"\"\"\n    Compute the last digit of b! / a!.\n    \n    :param a: The lower integer for the factorial division.\n    :param b: The higher integer for the factorial division.\n    :return: The last digit of the result of b! / a!.\n    \"\"\"\n    # Handle the case where a or b is zero\n    if a == 0 or b == 0:\n        return 1\n    \n    # Ensure b is greater than a\n    if b < a:\n        return 1  # If b < a, the division would be 1\n    \n    # Initialize the last digit as 1 (neutral element for multiplication)\n    last_digit = 1\n    \n    # Multiply the last digits from a+1 to b\n    for i in range(a + 1, b + 1):\n        last_digit = (last_digit * (i % 10)) % 10\n        \n        # If at any point the last digit becomes 0, it will remain 0\n        if last_digit == 0:\n            break\n    \n    return last_digit\n\n# Example usage:\nprint(compute_last_digit(3, 5))  # Output should be 2, because 5! / 3! = 20, and the last digit is 0\nprint(compute_last_digit(4, 7))  # Output should be 4, because 7! / 4! = 5*6*7 = 210, and the last digit is 0\nprint(compute_last_digit(0, 5))  # Output should be 0, because 5! / 0! = 5! and the last digit of 5! is 0\nprint(compute_last_digit(3, 0))  # Output should be 1, because 0! / 3! = 1 / 3! = 1\n", "result": "passed", "passed": true}
{"task_id": 48, "requirement": "Functionality Extension", "completion": "def odd_bit_set_number(n):\n    # Handle negative numbers by working with their absolute value\n    abs_n = abs(n)\n    \n    # Initialize mask to 0\n    mask = 0\n    \n    # Set all odd bits in the mask\n    i = 0\n    while (1 << i) <= abs_n:\n        mask |= (1 << (2 * i))\n        i += 1\n    \n    # Apply the mask to the absolute value using bitwise OR\n    result = abs_n | mask\n    \n    # If the original number was negative, return the negative of the result\n    if n < 0:\n        result = -result\n    \n    return result\n\n# Example usage:\nnumber = -10  # Binary: -1010\nresult = odd_bit_set_number(number)\nprint(f\"Given number: {number} (binary: {'-' + bin(abs(number))[2:] if number < 0 else bin(number)[2:]})\")\nprint(f\"Result after setting odd bits: {result} (binary: {'-' + bin(abs(result))[2:] if result < 0 else bin(result)[2:]})\")\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmplnvtkdyq.py\", line 22, in <module>\n    assert odd_bit_set_number(-10) == 15\nAssertionError", "passed": false}
{"task_id": 49, "requirement": "Functionality Extension", "completion": "def specified_element(two_d_list, index=0):\n    \"\"\"\n    Extracts the element at the specified index from each sublist within a two-dimensional list.\n    Negative indices are allowed and will count from the end of each sublist.\n\n    Parameters:\n    two_d_list (list of lists): The two-dimensional list to process.\n    index (int): The index of the element to extract from each sublist. Defaults to 0 (first element).\n                 Negative values are allowed and will count from the end of the sublist.\n\n    Returns:\n    list: A list containing the extracted elements.\n\n    Raises:\n    IndexError: If the provided index is out of range for any sublist.\n    TypeError: If two_d_list is not a list of lists.\n    \"\"\"\n\n    # Check if all elements in two_d_list are lists themselves\n    if not all(isinstance(sublist, list) for sublist in two_d_list):\n        raise TypeError(\"two_d_list must be a list of lists\")\n\n    # Extract the specified index element from each sublist\n    try:\n        return [sublist[index] for sublist in two_d_list]\n    except IndexError as e:\n        raise IndexError(f\"Provided index {index} is out of range for some sublists.\") from e\n\n# Example usage:\nexample_2d_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(specified_element(example_2d_list))       # Output: [1, 4, 7]\nprint(specified_element(example_2d_list, 1))    # Output: [2, 5, 8]\nprint(specified_element(example_2d_list, -1))   # Output: [3, 6, 9]\nprint(specified_element(example_2d_list, -2))   # Output: [2, 5, 8]\n", "result": "passed", "passed": true}
{"task_id": 51, "requirement": "Functionality Extension", "completion": "def check_triangle_type(side1, side2, side3):\n    # Check if any two sides are equal\n    if side1 == side2 == side3:\n        print(\"The triangle is equilateral.\")\n    elif side1 == side2 or side2 == side3 or side1 == side3:\n        print(\"The triangle is isosceles.\")\n    else:\n        print(\"The triangle is neither equilateral nor isosceles.\")\n\n# Example usage:\n# check_triangle_type(5, 5, 5)  # This will print \"The triangle is equilateral.\"\n# check_triangle_type(5, 6, 5)  # This will print \"The triangle is isosceles.\"\n# check_triangle_type(5, 7, 8)  # This will print \"The triangle is neither equilateral nor isosceles.\"\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp4ml6j5fl.py\", line 13, in <module>\n    assert check_equilateral(5, 5, 3) == 'isosceles'\nNameError: name 'check_equilateral' is not defined", "passed": false}
{"task_id": 52, "requirement": "Functionality Extension", "completion": "def parallelogram_area(parallelograms):\n    \"\"\"\n    Calculate the areas of multiple parallelograms given their bases and heights.\n\n    Parameters:\n    parallelograms (list of tuples): A list where each tuple contains two floats:\n                                     the base and the height of a parallelogram.\n\n    Returns:\n    list of floats: A list containing the areas of the parallelograms.\n    \"\"\"\n    areas = []\n    for base, height in parallelograms:\n        area = base * height\n        areas.append(area)\n    return areas\n\n# Example usage:\nparallelograms = [(5.0, 3.0), (4.0, 2.5), (6.0, 1.5)]\nareas = parallelogram_area(parallelograms)\nprint(f\"The areas of the parallelograms are: {areas}\")\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpb7hki8xk.py\", line 11, in <module>\n    assert parallelogram_area_list([(10, 20), (15, 20), (8, 9)]) == [200, 300, 72]\nNameError: name 'parallelogram_area_list' is not defined", "passed": false}
{"task_id": 53, "requirement": "Functionality Extension", "completion": "def check_equality(s):\n    # Check if the string is empty or has only one character\n    if len(s) <= 1:\n        return True\n    \n    # Convert the first and last character to lowercase for comparison\n    return s[0].lower() == s[-1].lower()\n\n# Example usage:\nprint(check_equality(\"Radar\"))  # Output: True\nprint(check_equality(\"Python\")) # Output: False\nprint(check_equality(\"A\"))      # Output: True\nprint(check_equality(\"\"))       # Output: True\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp27c2wt4e.py\", line 12, in <module>\n    assert check_equality('Abca') == 'Equal'\nAssertionError", "passed": false}
{"task_id": 54, "requirement": "Functionality Extension", "completion": "def counting_sort(arr):\n    if len(arr) == 0:\n        return []\n    \n    # Find the minimum and maximum elements in the array\n    min_element = min(arr)\n    max_element = max(arr)\n    \n    # Shift the array to make all elements non-negative\n    shift = -min_element\n    shifted_arr = [x + shift for x in arr]\n    \n    # Find the range of the shifted array\n    range_of_elements = max_element - min_element + 1\n    \n    # Initialize count array with zeros\n    count = [0] * range_of_elements\n    \n    # Count each element in the shifted array\n    for num in shifted_arr:\n        count[num] += 1\n    \n    # Modify count array such that each element at each index\n    # stores the sum of previous counts\n    for i in range(1, len(count)):\n        count[i] += count[i - 1]\n    \n    # Output array to store the sorted elements\n    output = [0] * len(arr)\n    \n    # Build the output array\n    for num in reversed(shifted_arr):\n        output[count[num] - 1] = num - shift\n        count[num] -= 1\n    \n    return output\n\n# Example usage:\narr = [4, -2, -2, 8, 3, -3, 1]\nsorted_arr = counting_sort(arr)\nprint(sorted_arr)  # Output: [-3, -2, -2, 1, 3, 4, 8]\n", "result": "passed", "passed": true}
{"task_id": 55, "requirement": "Functionality Extension", "completion": "def tn_gp(a1, r, n):\n    \"\"\"\n    Calculate the n-th term of a geometric series.\n    \n    Parameters:\n    a1 (float): The first term of the geometric series.\n    r (float): The common ratio of the geometric series.\n    n (int): The term number to calculate in the series.\n    \n    Returns:\n    float: The value of the n-th term in the geometric series.\n    \"\"\"\n    # Calculate the n-th term using the formula a_n = a1 * r^(n-1)\n    nth_term = a1 * (r ** (n - 1))\n    return float(nth_term)\n\n# Example usage:\n# Find the 5th term of a geometric series with the first term 2.0 and common ratio 3.0\nprint(tn_gp(2.0, 3.0, 5))  # Output should be 486.0\n\n# Another example with floating-point numbers\nprint(tn_gp(1.5, 2.5, 4))  # Output should be 31.25\n", "result": "passed", "passed": true}
{"task_id": 56, "requirement": "Functionality Extension", "completion": "def check(num):\n    # Handle the case where num is zero\n    if num == 0:\n        return False\n    \n    # Determine the sign of the number\n    sign = -1 if num < 0 else 1\n    \n    # Get the absolute value of the number\n    abs_num = abs(num)\n    \n    # Convert the absolute value to a string to reverse it easily\n    abs_num_str = str(abs_num)\n    \n    # Reverse the string representation of the number\n    reversed_num_str = abs_num_str[::-1]\n    \n    # Convert the reversed string back to an integer and apply the original sign\n    reversed_num = int(reversed_num_str) * sign\n    \n    # Calculate twice the reversed number\n    twice_reversed = 2 * reversed_num\n    \n    # Check if the original number is one less than twice the reversed number\n    return num == twice_reversed - 1\n\n# Example usage:\nprint(check(7))     # Output: False\nprint(check(-7))    # Output: False\nprint(check(21))    # Output: False\nprint(check(-21))   # Output: False\nprint(check(35))    # Output: False\nprint(check(-35))   # Output: False\n\n# Finding an example that satisfies the condition\nprint(check(76))    # Output: True (since 67*2-1=133, and 76+1=77 which is not 133, find correct example)\nprint(check(-76))   # Output: False\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpo5u0po5p.py\", line 30, in <module>\n    assert check(-37) == True\nAssertionError", "passed": false}
{"task_id": 57, "requirement": "Functionality Extension", "completion": "def find_max_num(digits):\n    \"\"\"\n    Given a list of digits, returns the largest number that can be formed using those digits.\n    \n    :param digits: List[int] - A list of integers (digits from 0 to 9)\n    :return: int - The largest number that can be formed with the given digits\n    \"\"\"\n    # Sort the digits in descending order\n    sorted_digits = sorted(digits, reverse=True)\n    \n    # Join them together as a string and convert to integer\n    max_num_str = ''.join(map(str, sorted_digits))\n    return int(max_num_str)\n\n# Example usage:\nprint(find_max_num([3, 30, 34, 5, 9]))  # Output: 9534330\nprint(find_max_num([1, 2, 3, 4, 5]))    # Output: 54321\nprint(find_max_num([1, 1, 2, 2, 3, 3])) # Output: 332211\nprint(find_max_num([0, 0, 1]))          # Output: 100\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp7i_sdjt3.py\", line 12, in <module>\n    assert find_max_num([1, 1, 2, 2], 4) == 2211\nTypeError: find_max_num() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 58, "requirement": "Functionality Extension", "completion": "def opposite_signs(pairs):\n    \"\"\"\n    Check if each pair of integers in the given list has opposite signs.\n\n    Parameters:\n    pairs (list of tuples): A list where each element is a tuple of two integers.\n\n    Returns:\n    list of bool: A list of boolean values indicating whether the integers in each pair have opposite signs.\n    \"\"\"\n    results = []\n    for a, b in pairs:\n        results.append((a * b) < 0)\n    return results\n\n# Example usage:\npairs = [(10, -20), (-5, -10), (0, 10), (-3, 4)]\nprint(opposite_signs(pairs))  # Output: [True, False, False, True]\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp75np6o1_.py\", line 9, in <module>\n    assert opposite_signs_list([(1, -2), (3, 2), (-10, -10)]) == [True, False, False]\nNameError: name 'opposite_signs_list' is not defined", "passed": false}
{"task_id": 59, "requirement": "Functionality Extension", "completion": "def is_octagonal(n):\n    \"\"\"\n    Calculate the nth octagonal number or a list of octagonal numbers.\n    \n    Parameters:\n    n (int or list of int): The position(s) in the sequence of octagonal numbers.\n    \n    Returns:\n    int or list of int: The nth octagonal number or a list of octagonal numbers.\n    \"\"\"\n    if isinstance(n, list):\n        # If n is a list, return a list of octagonal numbers for each element in the list\n        return [i * (3 * i - 2) for i in n]\n    else:\n        # If n is an integer, return the nth octagonal number\n        return n * (3 * n - 2)\n\n# Example usage:\nprint(is_octagonal(1))          # Output: 1\nprint(is_octagonal([1, 2, 3]))  # Output: [1, 8, 21]\nprint(is_octagonal(4))          # Output: 40\nprint(is_octagonal([5, 6]))     # Output: [65, 96]\n", "result": "passed", "passed": true}
{"task_id": 60, "requirement": "Functionality Extension", "completion": "def max_len_sub(arr, k):\n    \"\"\"\n    Finds the maximum length of a subsequence with the absolute difference \n    between adjacent elements not exceeding k.\n    \n    Parameters:\n    arr (List[int]): The input array.\n    k (int): The maximum allowed absolute difference between adjacent elements.\n    \n    Returns:\n    int: The length of the longest such subsequence.\n    \"\"\"\n    if not arr:\n        return 0\n    \n    # Dictionary to store the length of the longest subsequence ending with each element\n    dp = {}\n    max_length = 1\n    \n    for num in arr:\n        # Calculate the length of the longest subsequence ending with num\n        current_max = 1\n        for prev_num, length in dp.items():\n            if abs(num - prev_num) <= k:\n                current_max = max(current_max, length + 1)\n        \n        dp[num] = current_max\n        max_length = max(max_length, current_max)\n    \n    return max_length\n\n# Example usage:\narr = [4, 2, 3, 4, 5, 6]\nk = 1\nprint(max_len_sub(arr, k))  # Output should be 5 because the longest subsequence is [2, 3, 4, 5, 6]\n\narr = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\nk = 1\nprint(max_len_sub(arr, k))  # Output should be 10 because the longest subsequence is [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n\narr = [1, 3, 5, 7, 9, 11]\nk = 2\nprint(max_len_sub(arr, k))  # Output should be 6 because the longest subsequence is [1, 3, 5, 7, 9, 11]\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpj1qnrw24.py\", line 26, in <module>\n    assert max_len_sub([10, 7, 4, 1, -2], -3) == 5\nAssertionError", "passed": false}
