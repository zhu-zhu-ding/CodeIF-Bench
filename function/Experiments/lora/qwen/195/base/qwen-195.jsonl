{"task_id": 11, "completion": "Certainly! Below is a Python function `remove_occ` that removes the first and last occurrence of a given character from a string:\n\n```python\ndef remove_occ(s, ch):\n    # Find the index of the first occurrence of the character\n    first_index = s.find(ch)\n    \n    if first_index == -1:\n        return s  # Character not found in the string\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n    \n    # Find the index of the last occurrence of the character\n    last_index = s.rfind(ch)\n    \n    if last_index == -1:\n        return s  # Character not found in the string (shouldn't happen due to previous check)\n    \n    # Remove the last occurrence\n    s = s[:last_index] + s[last_index + 1:]\n    \n    return s\n\n# Example usage:\ninput_string = \"hello world\"\ncharacter_to_remove = 'l'\nresult = remove_occ(input_string, character_to_remove)\nprint(result)  # Output: \"heo word\"\n```\n\n### Explanation:\n1. **Finding the First Occurrence**: The `find` method is used to get the index of the first occurrence of the character.\n2. **Removing the First Occurrence**: If the character is found (`first_index != -1`), it is removed by slicing the string.\n3. **Finding the Last Occurrence**: The `rfind` method is used to get the index of the last occurrence of the character.\n4. **Removing the Last Occurrence**: If the character is found (`last_index != -1`), it is removed by slicing the string again.\n\nThis function ensures that both the first and last occurrences of the specified character are removed from the string."}
{"task_id": 12, "completion": "Certainly! Below is a Python function called `sort_matrix` that sorts a given matrix (list of lists) in ascending order based on the sum of its rows.\n\n```python\ndef sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix\n\n# Example usage:\nmatrix = [\n    [3, 2, 1],\n    [6, 5, 4],\n    [9, 8, 7]\n]\n\nsorted_matrix = sort_matrix(matrix)\nprint(sorted_matrix)\n```\n\n### Explanation:\n- The `sorted` function is used to sort the matrix.\n- The `key` parameter of the `sorted` function is set to a lambda function that calculates the sum of each row (`lambda row: sum(row)`).\n- This ensures that the matrix is sorted in ascending order based on the sum of its rows.\n\nWhen you run the example usage, the output will be:\n```\n[[3, 2, 1], [6, 5, 4], [9, 8, 7]]\n```\n\nThis indicates that the matrix has been sorted such that the row with the smallest sum comes first."}
{"task_id": 13, "completion": "Certainly! Below is a Python function called `count_common` that takes a dictionary as input and returns the most common words along with their counts.\n\n```python\nfrom collections import Counter\n\ndef count_common(word_dict):\n    # Flatten the list of lists into a single list of words\n    all_words = [word for sublist in word_dict.values() for word in sublist]\n    \n    # Count the occurrences of each word\n    word_counts = Counter(all_words)\n    \n    # Get the most common words\n    most_common_words = word_counts.most_common()\n    \n    return most_common_words\n```\n\n### Example Usage:\n```python\n# Sample dictionary where keys are document IDs and values are lists of words\nsample_dict = {\n    1: ['apple', 'banana', 'cherry'],\n    2: ['banana', 'cherry', 'date'],\n    3: ['apple', 'apple', 'banana']\n}\n\n# Call the function\ncommon_words = count_common(sample_dict)\n\n# Print the result\nprint(common_words)\n```\n\n### Explanation:\n1. **Flatten the List**: The function first flattens the list of lists (`word_dict.values()`) into a single list of words.\n2. **Count Words**: It then uses `Counter` from the `collections` module to count the occurrences of each word.\n3. **Get Most Common Words**: Finally, it retrieves the most common words using the `most_common()` method of the `Counter` object.\n\nThis function will return a list of tuples, where each tuple contains a word and its count, sorted by frequency in descending order."}
{"task_id": 14, "completion": "Certainly! To calculate the volume of a triangular prism, you need to know the base area of the triangular face and its height (or length). The formula for the volume \\( V \\) of a triangular prism is:\n\n\\[ V = \\text{Base Area} \\times \\text{Height} \\]\n\nHere's a Python function `find_volume` that takes the base area and height as inputs and returns the volume of the triangular prism:\n\n```python\ndef find_volume(base_area, height):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n\n    Parameters:\n    base_area (float): The area of the triangular base.\n    height (float): The height (or length) of the prism.\n\n    Returns:\n    float: The volume of the triangular prism.\n    \"\"\"\n    if base_area < 0 or height < 0:\n        raise ValueError(\"Base area and height must be non-negative.\")\n    \n    volume = base_area * height\n    return volume\n```\n\n### Example Usage:\nIf you have a triangular base with an area of 15 square units and the height of the prism is 10 units, you can call the function like this:\n\n```python\nbase_area = 15\nheight = 10\nvolume = find_volume(base_area, height)\nprint(f\"The volume of the triangular prism is: {volume} cubic units\")\n```\n\nThis will output:\n\n```\nThe volume of the triangular prism is: 150 cubic units\n```\n\nMake sure to validate the inputs to ensure they are non-negative, as negative values don't make sense in this context."}
{"task_id": 15, "completion": "Certainly! Below is a Python function called `split_lowerstring` that splits a given string at lowercase letters:\n\n```python\nimport re\n\ndef split_lowerstring(text):\n    return re.findall('[a-z][^a-z]*', text)\n\n# Example usage:\ntext = \"HelloWorldThisIsPython\"\nresult = split_lowerstring(text)\nprint(result)  # Output: ['Hello', 'World', 'This', 'Is', 'Python']\n```\n\n### Explanation:\n- The function uses the `re.findall` method from the `re` module to find all substrings where a lowercase letter (`[a-z]`) is followed by zero or more non-lowercase characters (`[^a-z]*`).\n- This effectively splits the input string at each lowercase letter.\n\nFeel free to use this function in your code!"}
{"task_id": 16, "completion": "Certainly! Below is a Python function named `text_lowercase_underscore` that uses regular expressions to find sequences of lowercase letters joined with an underscore:\n\n```python\nimport re\n\ndef text_lowercase_underscore(text):\n    pattern = r'[a-z]+_[a-z]+'\n    matches = re.findall(pattern, text)\n    return matches\n```\n\n### Explanation:\n- The function `text_lowercase_underscore` takes a single argument `text`, which is the string to be searched.\n- It uses the `re` module to define a regular expression pattern that matches sequences of lowercase letters joined with an underscore (`[a-z]+_[a-z]+`).\n- The `re.findall` function is used to find all non-overlapping matches of the pattern in the string and returns them as a list.\n\n### Example Usage:\n```python\ntext = \"hello_world this_is_a_test example_string\"\nresult = text_lowercase_underscore(text)\nprint(result)  # Output: ['hello_world', 'this_is_a_test']\n```\n\nThis function will return a list of all substrings in the input text that match the specified pattern."}
{"task_id": 17, "completion": "Certainly! Below is a Python function named `square_perimeter` that calculates the perimeter of a square given the length of one side:\n\n```python\ndef square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square.\n\n    Parameters:\n    side_length (float or int): The length of one side of the square.\n\n    Returns:\n    float or int: The perimeter of the square.\n    \"\"\"\n    if not isinstance(side_length, (int, float)):\n        raise ValueError(\"The side length must be a number.\")\n    \n    return 4 * side_length\n```\n\n### Explanation:\n- **Function Name**: `square_perimeter`\n- **Parameters**:\n  - `side_length`: The length of one side of the square. This can be either an integer or a floating-point number.\n- **Return Value**: The perimeter of the square, which is calculated as `4 * side_length`.\n- **Error Handling**: The function checks if `side_length` is a number (either `int` or `float`). If not, it raises a `ValueError`.\n\n### Example Usage:\n```python\n# Example usage\nside = 5\nperimeter = square_perimeter(side)\nprint(f\"The perimeter of the square with side length {side} is {perimeter}.\")\n```\n\nThis will output:\n```\nThe perimeter of the square with side length 5 is 20.\n```"}
{"task_id": 18, "completion": "Certainly! Below is a Python function called `remove_dirty_chars` that removes characters from the first string (`str1`) which are present in the second string (`str2`):\n\n```python\ndef remove_dirty_chars(str1, str2):\n    # Create a set of characters to be removed for faster lookup\n    chars_to_remove = set(str2)\n    \n    # Use list comprehension to filter out unwanted characters\n    result = ''.join([char for char in str1 if char not in chars_to_remove])\n    \n    return result\n\n# Example usage:\nstr1 = \"hello world\"\nstr2 = \"ad\"\ncleaned_str = remove_dirty_chars(str1, str2)\nprint(cleaned_str)  # Output: \"hello worl\"\n```\n\n### Explanation:\n1. **Set Creation**: We create a set `chars_to_remove` from `str2`. Sets provide average O(1) time complexity for lookups, making the removal process more efficient.\n2. **List Comprehension**: We use a list comprehension to iterate over each character in `str1` and include it in the result only if it is not in `chars_to_remove`.\n3. **Joining Characters**: Finally, we join the filtered characters back into a single string using `''.join()`.\n\nThis function will effectively remove all characters from `str1` that are present in `str2`."}
{"task_id": 19, "completion": "Certainly! Below is a Python function named `test_duplicate` that checks if a given array of integers contains any duplicate elements:\n\n```python\ndef test_duplicate(arr):\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # Compare the length of the original list with the set\n    if len(unique_elements) == len(arr):\n        return False  # No duplicates found\n    else:\n        return True   # Duplicates found\n\n# Example usage:\narr1 = [1, 2, 3, 4, 5]\narr2 = [1, 2, 3, 3, 5]\n\nprint(test_duplicate(arr1))  # Output: False\nprint(test_duplicate(arr2))  # Output: True\n```\n\n### Explanation:\n- The function `test_duplicate` takes an array `arr` as input.\n- It converts the array to a set called `unique_elements`. A set automatically removes any duplicate values.\n- It then compares the length of the original array with the length of the set.\n  - If the lengths are equal, it means there were no duplicates in the array, so it returns `False`.\n  - If the lengths are not equal, it means there were duplicates in the array, so it returns `True`.\n\nThis approach is efficient because converting a list to a set and comparing their lengths has a time complexity of O(n), where n is the number of elements in the array."}
{"task_id": 20, "completion": "Sure! A Woodall number is of the form \\( n \\cdot 2^n - 1 \\) for some positive integer \\( n \\). Here's a Python function to check if a given number is a Woodall number:\n\n```python\ndef is_woodall(n):\n    if n < 1:\n        return False\n    \n    # Start with the smallest possible Woodall number (3)\n    woodall_number = 3\n    power_of_two = 2\n    \n    while woodall_number <= n:\n        if woodall_number == n:\n            return True\n        power_of_two *= 2\n        woodall_number = power_of_two * (power_of_two.bit_length() - 1)\n    \n    return False\n\n# Example usage:\nprint(is_woodall(7))  # True, because 3 * 2^3 - 1 = 23\nprint(is_woodall(23)) # True, because 3 * 2^3 - 1 = 23\nprint(is_woodall(15)) # False, not a Woodall number\n```\n\nThis function works by generating Woodall numbers in sequence and checking if they match the input number `n`. If it finds a match, it returns `True`; otherwise, it returns `False` after exhausting all possible Woodall numbers up to `n`."}
{"task_id": 21, "completion": "Certainly! Below is a Python function named `multiples_of_num` that takes two parameters: `n` (the number for which you want to find multiples) and `m` (the number of multiples you want). The function will return a list of the first `m` multiples of `n`.\n\n```python\ndef multiples_of_num(n, m):\n    \"\"\"\n    Find the first m multiples of n.\n\n    Parameters:\n    n (int): The number for which to find multiples.\n    m (int): The number of multiples to find.\n\n    Returns:\n    list: A list containing the first m multiples of n.\n    \"\"\"\n    if n == 0:\n        raise ValueError(\"The number n cannot be zero.\")\n    \n    multiples = [i * n for i in range(1, m + 1)]\n    return multiples\n\n# Example usage:\n# print(multiples_of_num(5, 3))  # Output: [5, 10, 15]\n```\n\n### Explanation:\n- The function `multiples_of_num` takes two arguments: `n` and `m`.\n- It checks if `n` is zero and raises a `ValueError` if it is, because division by zero is not allowed.\n- It uses a list comprehension to generate the first `m` multiples of `n`. The list comprehension iterates from 1 to `m` and multiplies each number by `n`.\n- Finally, it returns the list of multiples.\n\nYou can call this function with any integer values for `n` and `m` to get the desired multiples."}
{"task_id": 22, "completion": "Certainly! Below is a Python function `find_first_duplicate` that finds the first duplicate element in a given array of integers:\n\n```python\ndef find_first_duplicate(arr):\n    seen = set()\n    \n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    \n    return -1  # Return -1 if no duplicates are found\n\n# Example usage:\narr = [2, 5, 1, 2, 3, 5, 1]\nprint(find_first_duplicate(arr))  # Output: 2\n```\n\n### Explanation:\n1. **Initialization**: We initialize an empty set called `seen` to keep track of elements we have encountered so far.\n2. **Iteration**: We iterate through each element `num` in the input array `arr`.\n3. **Check for Duplicate**: For each element, we check if it is already in the `seen` set.\n   - If it is, we return that element as the first duplicate.\n   - If it is not, we add the element to the `seen` set.\n4. **Return -1**: If the loop completes without finding any duplicates, we return `-1`.\n\nThis approach ensures that we efficiently find the first duplicate with a time complexity of O(n), where n is the length of the array."}
{"task_id": 23, "completion": "Certainly! Below is a Python function named `maximum_sum` that takes a list of lists as input and returns the maximum sum of elements from any of the sublists.\n\n```python\ndef maximum_sum(list_of_lists):\n    if not list_of_lists:\n        return 0\n    max_sum = float('-inf')\n    for sublist in list_of_lists:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n    return max_sum\n\n# Example usage:\nlist_of_lists = [[1, 2, 3], [4, 5, 6], [10, 11]]\nprint(maximum_sum(list_of_lists))  # Output: 21\n```\n\n### Explanation:\n1. **Input Validation**: The function first checks if the input list is empty. If it is, it returns `0`.\n2. **Initialization**: It initializes `max_sum` to negative infinity (`float('-inf')`) to ensure any sum will be larger.\n3. **Iteration**: It iterates through each sublist in the list of lists.\n4. **Sum Calculation**: For each sublist, it calculates the sum of its elements using the `sum()` function.\n5. **Comparison**: It compares the current sum with `max_sum` and updates `max_sum` if the current sum is greater.\n6. **Return Result**: Finally, it returns the maximum sum found.\n\nThis function ensures that you get the maximum sum of any sublist within the given list of lists."}
{"task_id": 24, "completion": "Sure! Below is a Python function called `binary_to_decimal` that converts a given binary number (as a string) to its decimal equivalent:\n\n```python\ndef binary_to_decimal(binary):\n    \"\"\"\n    Convert a binary number (as a string) to its decimal equivalent.\n\n    Parameters:\n    binary (str): The binary number as a string.\n\n    Returns:\n    int: The decimal equivalent of the binary number.\n    \"\"\"\n    # Initialize the decimal value to 0\n    decimal = 0\n    \n    # Iterate over each character in the binary string\n    for i, digit in enumerate(reversed(binary)):\n        if digit == '1':\n            decimal += 2 ** i\n    \n    return decimal\n\n# Example usage:\nbinary_number = \"1101\"\ndecimal_number = binary_to_decimal(binary_number)\nprint(f\"The decimal equivalent of {binary_number} is {decimal_number}\")\n```\n\n### Explanation:\n1. **Initialization**: We start by initializing `decimal` to 0. This variable will store the final decimal value.\n2. **Iteration**: We iterate over each character in the reversed binary string using `enumerate(reversed(binary))`. This allows us to get both the index (`i`) and the digit itself.\n3. **Conversion**: For each digit, if it is '1', we add `2 ** i` to the `decimal` value. This works because each position in a binary number represents a power of 2.\n4. **Return**: Finally, we return the computed decimal value.\n\nThis function assumes that the input binary number is provided as a string. If you need to handle binary numbers as integers, you can modify the function accordingly."}
{"task_id": 25, "completion": "Certainly! Below is a Python function called `find_product` that calculates the product of non-repeated elements in a given array:\n\n```python\ndef find_product(arr):\n    from collections import Counter\n    \n    # Count the occurrences of each element in the array\n    count = Counter(arr)\n    \n    # Initialize the product to 1 (multiplicative identity)\n    product = 1\n    \n    # Iterate through the array and multiply only non-repeated elements\n    for num in arr:\n        if count[num] == 1:\n            product *= num\n    \n    return product\n\n# Example usage:\narr = [2, 3, 4, 2, 5, 6, 7, 8, 9, 9]\nprint(find_product(arr))  # Output will be 3 * 4 * 5 * 6 * 7 * 8 = 20160\n```\n\n### Explanation:\n1. **Counting Occurrences**: We use `collections.Counter` to count how many times each element appears in the array.\n2. **Initialization**: We initialize the `product` variable to 1 because multiplying any number by 1 does not change its value.\n3. **Iterating and Multiplying**: We iterate through the array and multiply the `product` by each element only if it appears exactly once in the array.\n\nThis function ensures that only non-repeated elements contribute to the final product."}
{"task_id": 26, "completion": "Certainly! Below is a Python function `check_k_elements` that checks if all tuples in a list have at least `k` elements:\n\n```python\ndef check_k_elements(test_list, K):\n    # Use a generator expression to count tuples with less than K elements\n    res = not any(len(sub) < K for sub in test_list)\n    return res\n```\n\n### Explanation:\n- The function takes two parameters: `test_list`, which is the list of tuples, and `K`, which is the minimum number of elements required.\n- It uses a generator expression inside the `any()` function to check if there is any tuple in the list that has fewer than `K` elements.\n- If no such tuple exists (i.e., all tuples have at least `K` elements), `any()` returns `False`, and `not any(...)` returns `True`.\n- Otherwise, it returns `False`.\n\n### Example Usage:\n```python\ntest_list = [(4, 5, 6), (7, 8), (9,)]\nK = 2\nprint(check_k_elements(test_list, K))  # Output: False\n\ntest_list = [(4, 5, 6), (7, 8, 9), (10, 11)]\nK = 2\nprint(check_k_elements(test_list, K))  # Output: True\n```\n\nThis function will correctly determine if all tuples in the list meet the specified length requirement."}
{"task_id": 27, "completion": "Certainly! Below is a Python function named `remove` that takes a list of strings as input and returns a new list with all digits removed from each string.\n\n```python\nimport re\n\ndef remove(strings):\n    # Define a regular expression pattern to match digits\n    digit_pattern = r'\\d'\n    \n    # Use list comprehension to apply the regex substitution to each string in the list\n    result = [re.sub(digit_pattern, '', s) for s in strings]\n    \n    return result\n```\n\n### Explanation:\n1. **Importing `re` module**: The `re` module provides support for regular expressions in Python.\n2. **Defining the `digit_pattern`**: This pattern matches any digit (0-9).\n3. **Using list comprehension**: For each string `s` in the input list `strings`, the `re.sub` function replaces all occurrences of digits in `s` with an empty string `''`.\n4. **Returning the result**: The modified list is returned.\n\n### Example Usage:\n```python\nstrings = ['abc123', 'def456', 'ghi789']\nresult = remove(strings)\nprint(result)  # Output: ['abc', 'def', 'ghi']\n```\n\nThis function will effectively remove all digits from each string in the provided list."}
{"task_id": 28, "completion": "Certainly! The binomial coefficient, often denoted as \\( C(n, k) \\) or \\( \\binom{n}{k} \\), represents the number of ways to choose \\( k \\) elements from a set of \\( n \\) elements without regard to the order of selection. It can be computed using the formula:\n\n\\[ C(n, k) = \\frac{n!}{k!(n-k)!} \\]\n\nHere's a Python function to compute the binomial coefficient using this formula:\n\n```python\nimport math\n\ndef binomial_coefficient(n, k):\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    coeff = 1\n    for i in range(k):\n        coeff *= (n - i)\n        coeff //= (i + 1)\n    return coeff\n\n# Example usage:\nn = 5\nk = 2\nprint(f\"C({n}, {k}) = {binomial_coefficient(n, k)}\")\n```\n\n### Explanation:\n1. **Importing `math`**: Although not strictly necessary for this implementation, importing `math` could be useful for other mathematical operations.\n2. **Function Definition**: The function `binomial_coefficient` takes two arguments, `n` and `k`.\n3. **Edge Cases**:\n   - If `k` is greater than `n`, the result is 0 because it's impossible to choose more elements than are available.\n   - If `k` is 0 or equal to `n`, the result is 1 because there is exactly one way to choose no elements or all elements.\n4. **Symmetry Optimization**: The line `k = min(k, n - k)` ensures that we only compute half of the terms in the factorial division, taking advantage of the symmetry property \\( C(n, k) = C(n, n-k) \\).\n5. **Iterative Calculation**: The loop calculates the binomial coefficient iteratively to avoid large intermediate values that could cause overflow.\n\nThis function efficiently computes the binomial coefficient using an iterative approach, which is generally more efficient than a recursive approach for larger values of `n` and `k`."}
{"task_id": 29, "completion": "Certainly! To find the element that occurs an odd number of times in a list, you can use a dictionary to count the occurrences of each element and then identify the one with an odd count. Here's how you can implement this:\n\n```python\ndef get_odd_occurrence(arr):\n    # Create a dictionary to store the count of each element\n    count_dict = {}\n    \n    # Iterate through the array and populate the dictionary\n    for num in arr:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Find the element with an odd count\n    for num, count in count_dict.items():\n        if count % 2 != 0:\n            return num\n    \n    # If no such element exists (which shouldn't happen in a valid input), return None\n    return None\n\n# Example usage:\narr = [20, 30, 40, 50, 60, 70, 80, 90, 100, 20]\nprint(get_odd_occurrence(arr))  # Output should be 20\n```\n\nThis function works as follows:\n1. It initializes an empty dictionary `count_dict` to store the count of each element.\n2. It iterates through the input list `arr`, updating the count of each element in the dictionary.\n3. After populating the dictionary, it iterates through the dictionary items to find the first element with an odd count and returns it.\n4. If no such element is found (which shouldn't happen in a valid input), it returns `None`.\n\nThis approach ensures that the function efficiently finds the element occurring an odd number of times with a time complexity of O(n)."}
{"task_id": 30, "completion": "Certainly! Below is a Python function `count_substring_with_equal_ends` that counts all substrings of a given string which start and end with the same character:\n\n```python\ndef count_substring_with_equal_ends(s):\n    def count_substrings_with_char(s, char):\n        count = 0\n        for i in range(len(s)):\n            if s[i] == char:\n                count += 1\n        return count\n\n    total_count = 0\n    n = len(s)\n    \n    # Count substrings starting and ending with each character\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if substring[0] == substring[-1]:\n                total_count += 1\n    \n    return total_count\n\n# Example usage:\ns = \"abcab\"\nprint(count_substring_with_equal_ends(s))  # Output will be the number of substrings starting and ending with the same character\n```\n\n### Explanation:\n1. **Function Definition**: The function `count_substring_with_equal_ends` takes a single argument `s`, which is the input string.\n2. **Helper Function**: Inside the main function, there's a helper function `count_substrings_with_char` that counts how many times a specific character appears in the string.\n3. **Main Logic**:\n   - Initialize `total_count` to 0.\n   - Iterate over all possible substrings of `s`.\n   - For each substring, check if the first and last characters are the same.\n   - If they are, increment `total_count`.\n4. **Return Result**: Finally, return the `total_count`.\n\nThis function efficiently counts all substrings that start and end with the same character by iterating through all possible substrings and checking their endpoints."}
{"task_id": 31, "completion": "To solve this problem, we can use the `heapq` module in Python, which provides an efficient way to handle heap queues or priority queues. We will also use the `collections.Counter` class to count the frequency of each integer across all lists. Here's how you can implement the `func` function:\n\n```python\nimport heapq\nfrom collections import Counter\n\ndef func(lists, k):\n    # Flatten the list of lists into a single list\n    flat_list = [num for sublist in lists for num in sublist]\n    \n    # Count the frequency of each number in the flattened list\n    freq_counter = Counter(flat_list)\n    \n    # Use heapq.nlargest to get the k numbers with the highest frequencies\n    result = heapq.nlargest(k, freq_counter.items(), key=lambda x: x[1])\n    \n    return result\n```\n\nThis function first flattens the list of lists into a single list. Then, it uses `Counter` to count the frequency of each number. Finally, it uses `heapq.nlargest` to find the k numbers with the highest frequencies. The result is returned as a list of tuples, where each tuple contains a number and its frequency."}
{"task_id": 32, "completion": "Certainly! Below is a Python function called `max_prime_factors` that finds the largest prime factor of a given number:\n\n```python\ndef max_prime_factors(n):\n    # Initialize the maximum prime factor variable\n    max_prime = -1\n    \n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        max_prime = 2\n        n //= 2\n    \n    # n must be odd at this point, so we can skip one element (Note i = i + 2)\n    for i in range(3, int(n**0.5) + 1, 2):\n        # While i divides n, print i and divide n\n        while n % i == 0:\n            max_prime = i\n            n //= i\n    \n    # This condition is to handle the case when n is a prime number greater than 2\n    if n > 2:\n        max_prime = n\n    \n    return max_prime\n\n# Example usage:\nnumber = 600851475143\nprint(f\"The largest prime factor of {number} is {max_prime_factors(number)}\")\n```\n\n### Explanation:\n1. **Initialization**: We start by initializing `max_prime` to `-1` to keep track of the largest prime factor found.\n2. **Remove Even Factors**: We repeatedly divide `n` by 2 until it becomes odd. This removes all even factors and sets `max_prime` to 2.\n3. **Iterate Over Odd Numbers**: We then iterate over odd numbers starting from 3 up to the square root of `n`. For each odd number `i`, we check if it divides `n`. If it does, we update `max_prime` and continue dividing `n` by `i`.\n4. **Handle Remaining Prime Number**: After the loop, if `n` is still greater than 2, it means `n` itself is a prime number, and we set `max_prime` to `n`.\n\nThis function efficiently finds the largest prime factor by reducing the problem size with each division step."}
{"task_id": 33, "completion": "Certainly! Below is a Python function named `decimal_to_binary` that converts a decimal number to its binary representation:\n\n```python\ndef decimal_to_binary(decimal_number):\n    if decimal_number == 0:\n        return \"0\"\n    \n    binary_digits = []\n    while decimal_number > 0:\n        remainder = decimal_number % 2\n        binary_digits.append(str(remainder))\n        decimal_number //= 2\n    \n    # The binary digits are in reverse order, so we need to reverse them\n    binary_digits.reverse()\n    \n    # Join the list into a string\n    binary_string = ''.join(binary_digits)\n    return binary_string\n\n# Example usage:\ndecimal_number = 13\nbinary_representation = decimal_to_binary(decimal_number)\nprint(f\"The binary representation of {decimal_number} is {binary_representation}\")\n```\n\n### Explanation:\n1. **Base Case**: If the input `decimal_number` is 0, the function immediately returns \"0\".\n2. **Conversion Process**:\n   - An empty list `binary_digits` is initialized to store the binary digits.\n   - A `while` loop runs as long as `decimal_number` is greater than 0.\n   - In each iteration, the remainder when `decimal_number` is divided by 2 (i.e., `decimal_number % 2`) is calculated and appended to `binary_digits`.\n   - The `decimal_number` is then updated to be the integer division of itself by 2 (`decimal_number //= 2`).\n3. **Reversing the List**:\n   - Since the binary digits are collected in reverse order, the list is reversed using `binary_digits.reverse()`.\n4. **Joining the Digits**:\n   - The list of binary digits is joined into a single string using `''.join(binary_digits)`.\n5. **Return the Result**:\n   - The resulting binary string is returned.\n\nThis function will correctly convert any non-negative integer to its binary representation."}
{"task_id": 34, "completion": "Certainly! To find the missing number in a sorted array, we can use a binary search approach for efficiency. The idea is to leverage the fact that the array is sorted and look for the point where the difference between the expected value and the actual value is not consistent.\n\nHere's a Python function `find_missing` that implements this approach:\n\n```python\ndef find_missing(arr):\n    def binary_search(left, right):\n        if left > right:\n            return -1\n        \n        mid = (left + right) // 2\n        \n        # Check if the missing element is at mid\n        if arr[mid] != mid + arr[0]:\n            if mid == 0 or arr[mid - 1] == mid - 1 + arr[0]:\n                return mid + arr[0]\n            return binary_search(left, mid - 1)\n        \n        # If the missing element is not at mid, check the right half\n        return binary_search(mid + 1, right)\n    \n    # Edge case: if the first element is not 0, then 0 is the missing element\n    if arr[0] != 0:\n        return 0\n    \n    n = len(arr)\n    return binary_search(0, n - 1)\n\n# Example usage:\narr = [1, 2, 3, 5, 6, 7, 8]\nprint(find_missing(arr))  # Output: 4\n```\n\n### Explanation:\n1. **Binary Search Function**: The `binary_search` function performs a binary search on the array segment defined by `left` and `right`.\n2. **Base Case**: If `left` exceeds `right`, it means there is no missing element in the current segment, so we return `-1`.\n3. **Mid Calculation**: Calculate the middle index `mid`.\n4. **Check Mid Element**:\n   - If `arr[mid]` is not equal to `mid + arr[0]`, it means the missing element is at `mid` or before `mid`. We then recursively search the left half.\n   - If `arr[mid]` is equal to `mid + arr[0]`, it means the missing element is after `mid`. We recursively search the right half.\n5. **Edge Case**: If the first element of the array is not `0`, then `0` is the missing element.\n\nThis approach ensures that we efficiently find the missing number with a time complexity of \\(O(\\log n)\\)."}
{"task_id": 35, "completion": "Certainly! A rectangular number (or square pyramidal number) is the sum of the first \\( n \\) squares. The formula to calculate the \\( n \\)-th rectangular number is:\n\n\\[ R(n) = \\frac{n(n + 1)(2n + 1)}{6} \\]\n\nHere's a Python function to compute the \\( n \\)-th rectangular number:\n\n```python\ndef find_rect_num(n):\n    if not isinstance(n, int) or n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    return n * (n + 1) * (2 * n + 1) // 6\n\n# Example usage:\nn = 5\nprint(f\"The {n}-th rectangular number is: {find_rect_num(n)}\")\n```\n\nThis function takes a non-negative integer `n` as input and returns the \\( n \\)-th rectangular number. It includes error handling to ensure that the input is a non-negative integer."}
{"task_id": 36, "completion": "Certainly! To find the nth digit in the decimal representation of a proper fraction (i.e., a fraction where the numerator is less than the denominator), we can use long division. Here's a Python function `find_nth_digit` that accomplishes this:\n\n```python\ndef find_nth_digit(numerator, denominator, n):\n    if numerator >= denominator:\n        raise ValueError(\"Numerator must be less than the denominator for a proper fraction.\")\n    \n    # Dictionary to store remainders and their corresponding positions\n    remainder_positions = {}\n    quotient_digits = []\n    remainder = numerator\n    \n    # Perform long division until we reach the nth digit or detect a repeating cycle\n    while remainder != 0 and len(quotient_digits) < n:\n        if remainder in remainder_positions:\n            start_index = remainder_positions[remainder]\n            non_repeating = ''.join(map(str, quotient_digits[:start_index]))\n            repeating = ''.join(map(str, quotient_digits[start_index:n]))\n            break\n        \n        remainder_positions[remainder] = len(quotient_digits)\n        remainder *= 10\n        quotient_digit = remainder // denominator\n        quotient_digits.append(quotient_digit)\n        remainder = remainder % denominator\n    \n    # If we didn't reach the nth digit, it means the fraction terminates\n    if len(quotient_digits) < n:\n        return None\n    \n    # Return the nth digit\n    return int(''.join(map(str, quotient_digits))[-n])\n\n# Example usage:\nnumerator = 1\ndenominator = 3\nn = 5\nprint(find_nth_digit(numerator, denominator, n))  # Output: 3\n```\n\n### Explanation:\n1. **Input Validation**: The function first checks if the numerator is less than the denominator. If not, it raises a `ValueError`.\n2. **Long Division Simulation**:\n   - We use a dictionary `remainder_positions` to keep track of remainders and their positions in the quotient.\n   - We perform the long division step-by-step, multiplying the remainder by 10 and dividing by the denominator to get each digit of the quotient.\n   - If a remainder repeats, it indicates a repeating cycle.\n3. **Handling Terminating Decimals**:\n   - If the length of `quotient_digits` is less than `n`, it means the fraction terminates before reaching the nth digit, so the function returns `None`.\n4. **Returning the nth Digit**:\n   - If a repeating cycle is detected, the function extracts the non-repeating and repeating parts.\n   - It then returns the nth digit from the end of the quotient digits.\n\nThis function should work correctly for any proper fraction and will handle both terminating and repeating decimals."}
{"task_id": 37, "completion": "Certainly! To sort a mixed list of integers and strings in Python, you can use the `sorted()` function with a custom key that handles both types appropriately. Here's how you can do it:\n\n```python\ndef sort_mixed_list(mixed_list):\n    # Separate integers and strings into two lists\n    int_part = sorted([item for item in mixed_list if isinstance(item, int)])\n    str_part = sorted([item for item in mixed_list if isinstance(item, str)])\n    \n    # Combine the sorted parts\n    sorted_list = int_part + str_part\n    return sorted_list\n\n# Example usage:\nmixed_list = [1, \"apple\", 2, \"banana\", 3, \"cherry\"]\nsorted_list = sort_mixed_list(mixed_list)\nprint(sorted_list)  # Output: [1, 2, 3, 'apple', 'banana', 'cherry']\n```\n\n### Explanation:\n1. **Separate Integers and Strings**: We use list comprehensions to create two separate lists: one for integers (`int_part`) and one for strings (`str_part`).\n2. **Sort Each Part**: We sort each part separately using the `sorted()` function.\n3. **Combine Sorted Parts**: Finally, we concatenate the sorted integer list and the sorted string list to get the final sorted mixed list.\n\nThis approach ensures that integers and strings are sorted independently and then combined in their original order."}
{"task_id": 38, "completion": "Certainly! Below is a Python function named `div_even_odd` that takes a list as input and returns the division of the first even number by the first odd number in the list.\n\n```python\ndef div_even_odd(lst):\n    # Find the first even number in the list\n    first_even = next((x for x in lst if x % 2 == 0), None)\n    \n    # Find the first odd number in the list\n    first_odd = next((x for x in lst if x % 2 != 0), None)\n    \n    # Check if both even and odd numbers exist in the list\n    if first_even is not None and first_odd is not None:\n        return first_even / first_odd\n    else:\n        raise ValueError(\"The list must contain at least one even and one odd number.\")\n\n# Example usage:\nexample_list = [3, 5, 7, 8, 10]\nresult = div_even_odd(example_list)\nprint(result)  # Output will be 8.0 / 3.0\n```\n\n### Explanation:\n1. **Finding the First Even Number**: The `next` function with a generator expression `(x for x in lst if x % 2 == 0)` iterates through the list and returns the first even number it encounters. If no even number is found, it returns `None`.\n2. **Finding the First Odd Number**: Similarly, the `next` function with a generator expression `(x for x in lst if x % 2 != 0)` iterates through the list and returns the first odd number it encounters. If no odd number is found, it returns `None`.\n3. **Division Calculation**: If both an even and an odd number are found, the function returns their division result. Otherwise, it raises a `ValueError`.\n\nThis function ensures that the list contains at least one even and one odd number before performing the division, thus avoiding potential errors."}
{"task_id": 39, "completion": "Certainly! To determine if the letters of a given string can be rearranged such that no two adjacent characters are the same, we can use a greedy algorithm with a priority queue (max-heap). Here's how you can implement this in Python:\n\n```python\nimport heapq\nfrom collections import Counter\n\ndef rearrange_string(s):\n    # Count the frequency of each character\n    char_count = Counter(s)\n    \n    # Create a max-heap based on character frequency\n    max_heap = [(-freq, char) for char, freq in char_count.items()]\n    heapq.heapify(max_heap)\n    \n    prev_char = None\n    prev_freq = 0\n    result = []\n    \n    while max_heap or prev_freq:\n        if prev_freq < 0:\n            heapq.heappush(max_heap, (prev_freq, prev_char))\n        \n        if not max_heap:\n            return \"\"  # It's not possible to rearrange\n        \n        freq, char = heapq.heappop(max_heap)\n        result.append(char)\n        prev_char = char\n        prev_freq = freq + 1\n    \n    return ''.join(result)\n\n# Example usage:\ns = \"aabbcc\"\nprint(rearrange_string(s))  # Output could be \"abcabc\" or any valid rearrangement\n```\n\n### Explanation:\n1. **Count Character Frequencies**: We use `collections.Counter` to count the frequency of each character in the input string.\n2. **Max-Heap Initialization**: We create a max-heap (using negative frequencies to simulate a max-heap with Python's `heapq`, which is a min-heap by default).\n3. **Greedy Rearrangement**:\n   - While there are elements in the heap or leftover characters from the previous iteration:\n     - If there are leftover characters from the previous iteration, push them back into the heap.\n     - Pop the most frequent character from the heap.\n     - Append it to the result list.\n     - Update `prev_char` and `prev_freq` to keep track of the last processed character.\n4. **Check Validity**: If at any point the heap is empty but there are still characters left to process (`prev_freq`), it means it's impossible to rearrange the string as required.\n\nThis approach ensures that the most frequent characters are always placed first, reducing the likelihood of placing two identical characters next to each other."}
{"task_id": 40, "completion": "Certainly! To find the frequency of elements in a given list of lists using the `collections` module, you can use the `Counter` class from the `collections` module. Here's how you can implement the `freq_element` function:\n\n```python\nfrom collections import Counter\n\ndef freq_element(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    frequency = Counter(flattened_list)\n    \n    return frequency\n\n# Example usage:\nlist_of_lists = [[1, 2, 3], [2, 3, 4], [4, 5]]\nprint(freq_element(list_of_lists))\n```\n\nIn this code:\n- We first flatten the list of lists into a single list using a list comprehension.\n- Then, we use the `Counter` class to count the frequency of each element in the flattened list.\n- Finally, we return the resulting `Counter` object, which contains the frequency of each element.\n\nWhen you run the example usage, it will output:\n```\nCounter({2: 2, 3: 2, 4: 2, 1: 1, 5: 1})\n```\n\nThis indicates that the number 2 appears twice, 3 appears twice, 4 appears twice, 1 appears once, and 5 appears once in the given list of lists."}
{"task_id": 41, "completion": "Certainly! Below is the implementation of the `filter_evennumbers` function that filters out even numbers from a list using a lambda function:\n\n```python\ndef filter_evennumbers(numbers):\n    # Use the filter function with a lambda to filter even numbers\n    even_numbers = list(filter(lambda x: (x % 2 == 0), numbers))\n    return even_numbers\n\n# Example usage:\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nresult = filter_evennumbers(numbers)\nprint(result)  # Output: [2, 4, 6, 8, 10]\n```\n\nIn this function:\n- The `filter` function takes two arguments: a function and an iterable.\n- The lambda function `lambda x: (x % 2 == 0)` checks if a number is even.\n- The `filter` function applies this lambda function to each element in the `numbers` list and returns an iterator containing only the elements for which the lambda function returns `True`.\n- Finally, we convert the filter object to a list using `list()` and return it."}
{"task_id": 42, "completion": "Certainly! Below is a Python function called `find_sum` that finds the sum of repeated elements in a given array:\n\n```python\ndef find_sum(arr):\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    \n    # Iterate through the array and count the frequency of each element\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    \n    # Calculate the sum of repeated elements (elements with frequency greater than 1)\n    repeated_sum = 0\n    for num, count in freq.items():\n        if count > 1:\n            repeated_sum += num * count\n    \n    return repeated_sum\n\n# Example usage:\narr = [1, 2, 3, 2, 4, 5, 5, 6]\nresult = find_sum(arr)\nprint(\"Sum of repeated elements:\", result)  # Output: Sum of repeated elements: 12\n```\n\n### Explanation:\n1. **Frequency Counting**: The function uses a dictionary `freq` to count how many times each element appears in the array.\n2. **Sum Calculation**: It then iterates through the dictionary to calculate the sum of elements that appear more than once.\n3. **Return Result**: Finally, it returns the sum of these repeated elements.\n\nThis function efficiently computes the desired sum by leveraging the properties of dictionaries for quick lookups and counting."}
{"task_id": 43, "completion": "Certainly! Below is the `text_match` function that uses regular expressions to find sequences of lowercase letters joined with an underscore:\n\n```python\nimport re\n\ndef text_match(text):\n    pattern = r'^[a-z]+_[a-z]+$'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n```\n\nThis function takes a string `text` as input and checks if it matches the pattern of one or more lowercase letters followed by an underscore and then one or more lowercase letters. If the pattern is found, it returns 'Found a match!'; otherwise, it returns 'Not matched!'.\n\nHere's how you can use this function:\n\n```python\nprint(text_match(\"hello_world\"))  # Output: Found a match!\nprint(text_match(\"Hello_World\"))  # Output: Not matched!\nprint(text_match(\"helloWorld\"))   # Output: Not matched!\nprint(text_match(\"hello_\"))       # Output: Not matched!\nprint(text_match(\"_world\"))       # Output: Not matched!\nprint(text_match(\"hello_world_2\"))# Output: Not matched!\n```"}
{"task_id": 44, "completion": "Certainly! Below is a Python function called `text_match_string` that uses regular expressions to match a word at the beginning of a string:\n\n```python\nimport re\n\ndef text_match_string(text):\n    pattern = r'^\\w+'\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n```\n\n### Explanation:\n- The `^` character in the regular expression pattern `^\\w+` asserts the position at the start of the string.\n- `\\w+` matches one or more word characters (letters, digits, or underscores).\n\n### Example Usage:\n```python\nprint(text_match_string(\"Hello world\"))  # Output: True\nprint(text_match_string(\"hello world\"))  # Output: False\nprint(text_match_string(\"123start\"))     # Output: True\nprint(text_match_string(\"!@#start\"))     # Output: False\n```\n\nThis function will return `True` if the input string starts with one or more word characters, and `False` otherwise."}
{"task_id": 45, "completion": "Certainly! To find the greatest common divisor (GCD) of an array of numbers in Python, you can use the `math.gcd` function from the `math` module. If you need to handle multiple numbers, you can use the `reduce` function from the `functools` module to apply the GCD operation across all elements in the array.\n\nHere's how you can implement the `get_gcd` function:\n\n```python\nimport math\nfrom functools import reduce\n\ndef get_gcd(arr):\n    # Helper function to compute GCD of two numbers\n    def gcd(a, b):\n        return math.gcd(a, b)\n    \n    # Use reduce to apply the gcd function across all elements in the array\n    result = reduce(gcd, arr)\n    return result\n```\n\n### Example Usage:\n```python\narr = [24, 60, 36]\nprint(get_gcd(arr))  # Output will be 12\n```\n\nIn this implementation:\n- The `gcd` helper function takes two arguments and returns their GCD using `math.gcd`.\n- The `reduce` function applies the `gcd` function cumulatively to the items of the array, so as to reduce the array to a single value which is the GCD of all elements."}
{"task_id": 46, "completion": "Certainly! Below is a Python function called `test_distinct` that checks whether all elements in a list are distinct (i.e., no duplicates):\n\n```python\ndef test_distinct(data):\n    if len(data) == len(set(data)):\n        return True\n    else:\n        return False\n```\n\n### Explanation:\n- The function takes a list `data` as input.\n- It converts the list to a set using `set(data)`. A set automatically removes duplicate elements.\n- If the length of the original list (`len(data)`) is equal to the length of the set (`len(set(data))`), it means there were no duplicates, so the function returns `True`.\n- Otherwise, it returns `False`.\n\n### Example Usage:\n```python\n# Test cases\nprint(test_distinct([1, 2, 3, 4, 5]))  # Output: True\nprint(test_distinct([1, 2, 3, 3, 5]))  # Output: False\n```\n\nThis function efficiently determines if all elements in the list are unique by leveraging the properties of sets."}
{"task_id": 47, "completion": "Certainly! To solve this problem, we need to compute the last digit of \\( \\frac{b!}{a!} \\). The key observation here is that if \\( b > a \\), then \\( b! \\) contains all the factors of \\( a! \\) plus additional factors. Therefore, \\( \\frac{b!}{a!} \\) will be an integer.\n\nTo find the last digit of this integer, we can follow these steps:\n1. Compute \\( b! \\mod 10 \\).\n2. Compute \\( a! \\mod 10 \\).\n3. Compute the modular inverse of \\( a! \\mod 10 \\) (if it exists).\n4. Multiply the result from step 1 by the modular inverse from step 3 and take modulo 10.\n\nHere's the Python function to achieve this:\n\n```python\ndef mod_inverse(a, m):\n    m0, x0, x1 = m, 0, 1\n    if m == 1:\n        return 0\n    while a > 1:\n        # q is quotient\n        q = a // m\n        m, a = a % m, m\n        x0, x1 = x1 - q * x0, x0\n    # Make x1 positive\n    if x1 < 0:\n        x1 += m0\n    return x1\n\ndef factorial_mod(n, mod):\n    if n >= mod:\n        return 0\n    fact = 1\n    for i in range(1, n + 1):\n        fact = (fact * i) % mod\n    return fact\n\ndef compute_last_digit(a, b):\n    MOD = 10\n    if a == b:\n        return 1\n    if a > b:\n        return 0\n    \n    # Compute b! % 10\n    fact_b = factorial_mod(b, MOD)\n    \n    # Compute a! % 10\n    fact_a = factorial_mod(a, MOD)\n    \n    # Compute the modular inverse of a! % 10\n    inv_fact_a = mod_inverse(fact_a, MOD)\n    \n    # Compute the last digit of (b! / a!)\n    last_digit = (fact_b * inv_fact_a) % MOD\n    return last_digit\n\n# Example usage:\nprint(compute_last_digit(5, 8))  # Output should be 2\n```\n\n### Explanation:\n1. **Modular Inverse**: The `mod_inverse` function computes the modular inverse using the Extended Euclidean Algorithm.\n2. **Factorial Modulo 10**: The `factorial_mod` function computes the factorial of a number modulo 10.\n3. **Compute Last Digit**: The `compute_last_digit` function uses the above helper functions to compute the last digit of \\( \\frac{b!}{a!} \\).\n\nThis approach ensures that we handle large numbers efficiently by working with modulo 10 at each step."}
{"task_id": 48, "completion": "Certainly! Below is the Python function `odd_bit_set_number` that sets all odd bits of a given number:\n\n```python\ndef odd_bit_set_number(n):\n    # Initialize a mask with all odd bits set to 1\n    mask = 0xAAAAAAAA  # This is a hexadecimal representation where all even bits are 0 and all odd bits are 1\n    \n    # Use bitwise OR to set all odd bits of n to 1\n    result = n | mask\n    \n    return result\n\n# Example usage:\nnumber = 10  # Binary: 1010\nresult = odd_bit_set_number(number)\nprint(f\"Original number: {number} (binary: {bin(number)[2:].zfill(8)})\"\n      f\"\\nResult after setting odd bits: {result} (binary: {bin(result)[2:].zfill(8)})\"\n```\n\n### Explanation:\n- The `mask` variable is initialized with the value `0xAAAAAAAA`, which is a hexadecimal representation where all even bits are 0 and all odd bits are 1.\n- The `|` operator (bitwise OR) is used to set all odd bits of the input number `n` to 1. If an odd bit in `n` is already 1, it remains unchanged; if it is 0, it becomes 1 due to the OR operation.\n\n### Example:\nFor `n = 10` (binary `1010`):\n- Applying the mask `0xAAAAAAAA` results in `1010 | 1010 = 1010`.\n- Therefore, the output will be `10` (binary `1010`).\n\nThis function ensures that all odd bits of the input number are set to 1."}
{"task_id": 49, "completion": "Certainly! Below is the `specified_element` function that extracts every first or specified element from a given two-dimensional list:\n\n```python\ndef specified_element(list1, index=0):\n    result = [row[index] for row in list1]\n    return result\n\n# Example usage:\nlist1 = [[1, 2], [3, 4], [5, 6]]\nprint(specified_element(list1))  # Output: [1, 3, 5]\n\n# Extracting the second element (index 1)\nprint(specified_element(list1, 1))  # Output: [2, 4, 6]\n```\n\n### Explanation:\n- The function `specified_element` takes two parameters:\n  - `list1`: The two-dimensional list from which elements will be extracted.\n  - `index`: The index of the element to extract from each sublist. By default, it is set to `0`, which means it will extract the first element from each sublist.\n- Inside the function, a list comprehension is used to iterate over each sublist (`row`) in `list1` and extract the element at the specified `index`.\n- The resulting list of extracted elements is returned.\n\nThis function allows you to easily extract any specified element from each sublist in a two-dimensional list."}
{"task_id": 50, "completion": "Certainly! Below is a Python function `min_length_list` that finds the list with the minimum length using a lambda function:\n\n```python\ndef min_length_list(lists):\n    # Use the min function with a key argument to find the list with the minimum length\n    return min(lists, key=lambda x: len(x))\n\n# Example usage:\nlists = [[1, 2, 3], [4, 5], [6, 7, 8, 9], [10]]\nresult = min_length_list(lists)\nprint(result)  # Output: [4, 5]\n```\n\nIn this function:\n- The `min` function is used to determine the list with the smallest length.\n- The `key` argument of the `min` function is set to a lambda function `lambda x: len(x)`, which returns the length of each list.\n- The `min` function then compares these lengths and returns the list with the smallest one."}
{"task_id": 51, "completion": "Certainly! Below is a Python function named `check_equilateral` that takes three side lengths as input and prints whether the triangle is equilateral or not.\n\n```python\ndef check_equilateral(a, b, c):\n    \"\"\"\n    Check if a triangle with sides a, b, and c is equilateral.\n    \n    Parameters:\n    a (float): Length of the first side.\n    b (float): Length of the second side.\n    c (float): Length of the third side.\n    \"\"\"\n    if a == b == c:\n        print(\"The triangle is equilateral.\")\n    else:\n        print(\"The triangle is not equilateral.\")\n\n# Example usage:\n# check_equilateral(3, 3, 3)  # Output: The triangle is equilateral.\n# check_equilateral(3, 4, 5)  # Output: The triangle is not equilateral.\n```\n\nThis function compares the lengths of the three sides. If all three sides are equal, it prints \"The triangle is equilateral.\" Otherwise, it prints \"The triangle is not equilateral.\""}
{"task_id": 52, "completion": "Certainly! The area of a parallelogram can be calculated using the formula:\n\n\\[ \\text{Area} = \\text{base} \\times \\text{height} \\]\n\nHere's a Python function that calculates the area of a parallelogram given its base and height:\n\n```python\ndef parallelogram_area(base, height):\n    \"\"\"\n    Calculate the area of a parallelogram.\n\n    Parameters:\n    base (float): The length of the base of the parallelogram.\n    height (float): The height of the parallelogram.\n\n    Returns:\n    float: The area of the parallelogram.\n    \"\"\"\n    if base < 0 or height < 0:\n        raise ValueError(\"Base and height must be non-negative numbers.\")\n    \n    area = base * height\n    return area\n```\n\n### Example Usage:\n```python\n# Calculate the area of a parallelogram with base 10 and height 5\narea = parallelogram_area(10, 5)\nprint(f\"The area of the parallelogram is: {area}\")\n```\n\nThis function takes two parameters, `base` and `height`, and returns the area of the parallelogram. It also includes a check to ensure that both the base and height are non-negative, raising a `ValueError` if they are not."}
{"task_id": 53, "completion": "Certainly! Below is a Python function named `check_equality` that checks whether the first and last characters of a given string are equal:\n\n```python\ndef check_equality(s):\n    if len(s) == 0:\n        return False\n    return s[0] == s[-1]\n```\n\n### Explanation:\n- The function takes a single argument `s`, which is the input string.\n- It first checks if the length of the string is zero. If it is, the function returns `False` because there are no characters to compare.\n- If the string is not empty, it compares the first character (`s[0]`) with the last character (`s[-1]`) and returns `True` if they are equal, otherwise `False`.\n\n### Example Usage:\n```python\nprint(check_equality(\"radar\"))  # Output: True\nprint(check_equality(\"hello\"))  # Output: False\nprint(check_equality(\"\"))       # Output: False\nprint(check_equality(\"a\"))      # Output: True\n```\n\nThis function handles edge cases such as empty strings and ensures accurate comparison of the first and last characters."}
{"task_id": 54, "completion": "Certainly! Counting Sort is a non-comparison-based sorting algorithm that works well when the range of input data (i.e., the maximum value minus the minimum value) is not significantly greater than the number of elements to be sorted.\n\nHere's a Python implementation of the Counting Sort algorithm:\n\n```python\ndef counting_sort(arr):\n    if not arr:\n        return []\n\n    # Find the maximum and minimum values in the array\n    max_val = max(arr)\n    min_val = min(arr)\n\n    # Initialize the count array with zeros\n    count_range = max_val - min_val + 1\n    count_arr = [0] * count_range\n\n    # Store the count of each element in the count array\n    for num in arr:\n        count_arr[num - min_val] += 1\n\n    # Reconstruct the sorted array\n    sorted_index = 0\n    for i in range(count_range):\n        while count_arr[i] > 0:\n            arr[sorted_index] = i + min_val\n            sorted_index += 1\n            count_arr[i] -= 1\n\n    return arr\n\n# Example usage:\narr = [4, 2, 2, 8, 3, 3, 1]\nsorted_arr = counting_sort(arr)\nprint(sorted_arr)  # Output: [1, 2, 2, 3, 3, 4, 8]\n```\n\n### Explanation:\n1. **Find the Range**: Determine the range of the input array (`max_val - min_val + 1`).\n2. **Count Array Initialization**: Create a count array initialized with zeros, where the size of this array is equal to the range.\n3. **Count Elements**: Iterate through the input array and increment the corresponding index in the count array.\n4. **Reconstruct Sorted Array**: Iterate through the count array and reconstruct the sorted array by placing elements back into their correct positions.\n\nThis implementation assumes that the input array contains integers within a known range. If the range is large or unknown, other sorting algorithms might be more appropriate."}
{"task_id": 55, "completion": "Certainly! The \\( n \\)-th term of a geometric series can be found using the formula:\n\n\\[ a_n = a \\times r^{(n-1)} \\]\n\nwhere:\n- \\( a \\) is the first term of the series,\n- \\( r \\) is the common ratio,\n- \\( n \\) is the term number.\n\nHere's a Python function `tn_gp` that calculates the \\( n \\)-th term of a geometric series:\n\n```python\ndef tn_gp(a, r, n):\n    \"\"\"\n    Calculate the n-th term of a geometric series.\n\n    Parameters:\n    a (float): The first term of the series.\n    r (float): The common ratio of the series.\n    n (int): The term number to find.\n\n    Returns:\n    float: The n-th term of the geometric series.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"The term number must be a positive integer.\")\n    \n    return a * (r ** (n - 1))\n```\n\n### Example Usage\n\n```python\n# Example usage:\na = 2  # First term\nr = 3  # Common ratio\nn = 5  # Term number\n\nnth_term = tn_gp(a, r, n)\nprint(f\"The {n}-th term of the geometric series is: {nth_term}\")\n```\n\nThis function will output:\n\n```\nThe 5-th term of the geometric series is: 162\n```\n\nExplanation:\n- For \\( a = 2 \\), \\( r = 3 \\), and \\( n = 5 \\):\n  \\[ a_5 = 2 \\times 3^{(5-1)} = 2 \\times 3^4 = 2 \\times 81 = 162 \\]"}
{"task_id": 56, "completion": "Certainly! Below is the Python function `check` that checks if a given number is one less than twice its reverse:\n\n```python\ndef reverse_number(n):\n    reversed_n = 0\n    while n > 0:\n        reversed_n = reversed_n * 10 + n % 10\n        n //= 10\n    return reversed_n\n\ndef check(n):\n    reversed_n = reverse_number(n)\n    return n == 2 * reversed_n - 1\n\n# Example usage:\nnumber = 32\nif check(number):\n    print(f\"{number} is one less than twice its reverse.\")\nelse:\n    print(f\"{number} is not one less than twice its reverse.\")\n```\n\n### Explanation:\n1. **reverse_number Function**:\n   - This helper function takes an integer `n` and returns its reverse.\n   - It initializes `reversed_n` to 0.\n   - In each iteration of the loop, it extracts the last digit of `n` using `n % 10`, adds it to `reversed_n`, and then removes the last digit from `n` using integer division `n //= 10`.\n\n2. **check Function**:\n   - This function takes an integer `n` and uses the `reverse_number` function to get the reverse of `n`.\n   - It then checks if `n` is equal to twice its reverse minus 1 (`2 * reversed_n - 1`).\n   - If the condition is true, it returns `True`; otherwise, it returns `False`.\n\n### Example Usage:\n- The example usage demonstrates how to use the `check` function with the number 32. Since 32 is indeed one less than twice its reverse (64), the output will be \"32 is one less than twice its reverse.\""}
{"task_id": 57, "completion": "Certainly! Below is a Python function `find_max_num` that takes a list of digits and returns the largest number that can be formed using those digits.\n\n```python\ndef find_max_num(digits):\n    # Sort the digits in descending order\n    digits.sort(reverse=True)\n    \n    # Convert each digit to string for concatenation\n    digits = [str(digit) for digit in digits]\n    \n    # Concatenate the sorted digits to form the largest number\n    max_num = int(''.join(digits))\n    \n    return max_num\n\n# Example usage:\ndigits = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]\nprint(find_max_num(digits))  # Output: 96555433211\n```\n\n### Explanation:\n1. **Sorting**: The digits are sorted in descending order to ensure that the largest possible number is formed.\n2. **Conversion**: Each digit is converted to a string so that they can be concatenated easily.\n3. **Concatenation**: The sorted digits are joined together to form a single large number.\n4. **Conversion to Integer**: The concatenated string is converted back to an integer before returning it.\n\nThis function will correctly form the largest possible number from the given list of digits."}
{"task_id": 58, "completion": "Certainly! Below is a Python function called `opposite_signs` that checks whether two given integers have opposite signs:\n\n```python\ndef opposite_signs(x, y):\n    return (x ^ y) < 0\n```\n\n### Explanation:\n- The XOR operation (`^`) between two numbers will result in a negative number if the two numbers have opposite signs.\n- If both numbers are positive, their XOR will be positive.\n- If both numbers are negative, their XOR will also be positive.\n- Therefore, `(x ^ y) < 0` will be `True` if `x` and `y` have opposite signs, and `False` otherwise.\n\n### Example Usage:\n```python\nprint(opposite_signs(10, -20))  # Output: True\nprint(opposite_signs(-15, 30))   # Output: True\nprint(opposite_signs(5, 10))     # Output: False\nprint(opposite_signs(-7, -14))   # Output: False\n```\n\nThis function is efficient with a constant time complexity of O(1)."}
{"task_id": 59, "completion": "Certainly! An octagonal number is a figurate number that represents an octagon. The nth octagonal number can be calculated using the formula:\n\n\\[ O_n = n \\times (3n - 2) \\]\n\nHere's a Python function to calculate the nth octagonal number:\n\n```python\ndef is_octagonal(n):\n    if n < 1:\n        raise ValueError(\"The input must be a positive integer.\")\n    return n * (3 * n - 2)\n```\n\nThis function takes a single argument `n`, which is the position of the octagonal number in the sequence, and returns the nth octagonal number. If `n` is less than 1, it raises a `ValueError` because there are no negative or zeroth octagonal numbers.\n\nHere are a few examples of how you can use this function:\n\n```python\nprint(is_octagonal(1))  # Output: 1\nprint(is_octagonal(2))  # Output: 5\nprint(is_octagonal(3))  # Output: 12\nprint(is_octagonal(4))  # Output: 22\nprint(is_octagonal(5))  # Output: 35\n```\n\nFeel free to ask if you need any further assistance!"}
{"task_id": 60, "completion": "Certainly! Below is a Python function `max_len_sub` that finds the maximum length of the subsequence with a difference between adjacent elements:\n\n```python\ndef max_len_sub(arr):\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\n# Example usage:\narr = [1, 2, 3, 4, 5]\nprint(max_len_sub(arr))  # Output: 5\n```\n\n### Explanation:\n1. **Initialization**: We initialize a list `dp` where each element is set to 1. This list will store the maximum length of the subsequence ending at each index.\n2. **Nested Loops**:\n   - The outer loop iterates through each element of the array starting from the second element.\n   - The inner loop checks all previous elements to see if they can form a valid subsequence with the current element (i.e., the absolute difference between them is 1).\n3. **Updating DP Array**: If a valid subsequence is found, we update the `dp` value for the current index to be the maximum of its current value or the `dp` value of the previous element plus one.\n4. **Result**: Finally, we return the maximum value in the `dp` array, which represents the length of the longest subsequence with the required property.\n\nThis approach ensures that we consider all possible subsequences and find the longest one efficiently."}
