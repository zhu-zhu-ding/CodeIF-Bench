{"task_id": 11, "completion": "def remove_occ(text, char):\n    if len(char) != 1:\n        raise ValueError('Second parameter must be a single character.')\n    first_index = text.find(char)\n    last_index = text.rfind(char)\n    if first_index == -1 or last_index == -1:\n        return text\n    return text[:first_index] + text[first_index + 1:last_index] + text[last_index + 1:]\n", "requirement": "Exception Handling"}
{"task_id": 11, "completion": "def remove_occ(string, char):\n    if char not in string:\n        return string\n    first_index = string.index(char)\n    last_index = string.rindex(char)\n    return string[:first_index] + string[first_index + 1:] + string[last_index + 1:]\n", "requirement": "Edge Case Handling"}
{"task_id": 11, "completion": "def remove_occ(s, ch, all=False):\n    if all:\n        s = s.replace(ch, '')\n    else:\n        s = s.replace(ch, '', 1)\n        s = s[:-1] if s[-1] == ch else s\n    return s\n", "requirement": "Functionality Extension"}
{"task_id": 11, "completion": "def remove_occ(s: str, ch: str) -> str:\n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n    if first_index != -1 and last_index != -1:\n        s = s[:first_index] + s[first_index + 1:]\n        s = s[:last_index] + s[last_index + 1:]\n    return s\n", "requirement": "Annotation Coverage"}
{"task_id": 11, "completion": "def remove_occ(s, c):\n    first_index = s.find(c)\n    last_index = s.rfind(c)\n    if first_index != -1 and last_index != -1:\n        s = s[:first_index] + s[first_index + 1:]\n        s = s[:last_index] + s[last_index + 1:]\n    return s\n", "requirement": "Code Complexity"}
{"task_id": 11, "completion": "def remove_occ(string, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n\n    Parameters:\n    string (str): The input string.\n    char (str): The character to be removed.\n\n    Returns:\n    str: The modified string with the first and last occurrence of the character removed.\n    \"\"\"\n    first_index = string.find(char)\n    last_index = string.rfind(char)\n\n    if first_index != -1 and last_index != -1:\n        return string[:first_index] + string[first_index + 1 : last_index] + string[last_index + 1 :]\n    else:\n        return string\n", "requirement": "Code Standard"}
{"task_id": 12, "completion": "def sort_matrix(matrix):\n    if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix):\n        raise TypeError('Input must be a list of lists.')\n    if not all(isinstance(num, int) for row in matrix for num in row):\n        raise TypeError('All elements in the matrix must be integers.')\n    return sorted(matrix, key=sum)\n", "requirement": "Exception Handling"}
{"task_id": 12, "completion": "def sort_matrix(matrix):\n    if not matrix:\n        return []\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix\n", "requirement": "Edge Case Handling"}
{"task_id": 12, "completion": "Here is a Python function that meets the requirements:\n\n```python\ndef sort_matrix(matrix):\n    # Extend the function to handle matrices with rows of varying lengths\n    # by treating missing values as zeros.\n    matrix = [list(row) + [0] * (max(len(row) for row in matrix) - len(row)) for row in matrix]\n\n    # Calculate the sum of each row and sort the matrix based on these sums\n    sorted_matrix = sorted(matrix, key=sum)\n\n    return sorted_matrix\n```\n\nThis function first ensures that all rows in the matrix are of the same length by padding any missing values with zeros. Then, it sorts the matrix based on the sum of each row's elements.\n", "requirement": "Functionality Extension"}
{"task_id": 12, "completion": "def sort_matrix(matrix: list[list[int]]) -> list[list[int]]:\n    matrix.sort(key=sum)\n    return matrix\n", "requirement": "Annotation Coverage"}
{"task_id": 12, "completion": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): The matrix to be sorted.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    # Calculate the sum of each row and store it as a tuple (sum, row)\n    row_sums = [(sum(row), row) for row in matrix]\n\n    # Sort the list of tuples by the sum in ascending order\n    sorted_row_sums = sorted(row_sums, key=lambda x: x[0])\n\n    # Extract the sorted rows from the sorted list of tuples\n    sorted_matrix = [row for _, row in sorted_row_sums]\n\n    return sorted_matrix\n", "requirement": "Code Standard"}
{"task_id": 13, "completion": "def count_common(words):\n    if not isinstance(words, list) or not all(isinstance(word, str) for word in words):\n        raise TypeError('Input must be a list of strings.')\n    word_counts = {}\n    for word in words:\n        if word in word_counts:\n            word_counts[word] += 1\n        else:\n            word_counts[word] = 1\n    most_common_word = max(word_counts, key=word_counts.get)\n    return most_common_word\n", "requirement": "Exception Handling"}
{"task_id": 13, "completion": "def count_common(words):\n    if not words:\n        return []\n    word_counts = {}\n    for word in words:\n        if word in word_counts:\n            word_counts[word] += 1\n        else:\n            word_counts[word] = 1\n    most_common = sorted(word_counts.items(), key=lambda x: x[1], reverse=True)\n    return most_common[0][0]\n", "requirement": "Edge Case Handling"}
{"task_id": 13, "completion": "Here is a Python function that counts the most common words in a dictionary. The function uses the `Counter` class from the `collections` module to count the frequency of each word, and then returns the top `n` most common words.\n\n```python\nfrom collections import Counter\n\ndef count_common(word_dict, n=1):\n    counter = Counter(word_dict)\n    return counter.most_common(n)\n```\n\nThis function takes a dictionary `word_dict` as input, where the keys are words and the values are their frequencies. The `Counter` class automatically sorts the words by their frequencies in descending order. The `most_common(n)` method returns the `n` most common words and their frequencies as a list of tuples.\n\nFor example, if you have a dictionary `word_dict` with the following entries:\n\n```python\nword_dict = {'apple': 5, 'banana': 3, 'cherry': 2, 'date': 1}\n```\n\nYou can call `count_common(word_dict, 2)` to get the two most common words:\n\n```python\nprint(count_common(word_dict, 2))\n# Output: [('apple', 5), ('banana', 3)]\n```\n\nIf you don't specify the number of top frequent words to return, the function defaults to returning the most common word only:\n\n```python\nprint(count_common(word_dict))\n# Output: [('apple', 5)]\n```\n", "requirement": "Functionality Extension"}
{"task_id": 13, "completion": "def count_common(words: list) -> list:\n    \"\"\"\n    Counts the most common words in a list.\n\n    Parameters:\n    words (list): A list of words.\n\n    Returns:\n    list: A list of tuples, where each tuple contains a word and its count.\n    \"\"\"\n    word_counts = {}\n    for word in words:\n        if word in word_counts:\n            word_counts[word] += 1\n        else:\n            word_counts[word] = 1\n\n    common_words = sorted(word_counts.items(), key=lambda x: x[1], reverse=True)\n    return common_words\n", "requirement": "Annotation Coverage"}
{"task_id": 14, "completion": "def find_volume(base_area, height, length):\n    if base_area <= 0 or height <= 0 or length <= 0:\n        raise ValueError(\"All inputs must be positive numbers.\")\n    volume = base_area * height * length\n    return volume\n", "requirement": "Input-Output Conditions"}
{"task_id": 14, "completion": "def find_volume(base, height, length):\n    if not all(isinstance(x, (int, float)) for x in (base, height, length)):\n        raise ValueError('All dimensions must be positive numbers.')\n    if not all(x > 0 for x in (base, height, length)):\n        raise ValueError('All dimensions must be positive numbers.')\n    return (base * height * length) / 2\n", "requirement": "Exception Handling"}
{"task_id": 14, "completion": "Sure, here is a Python function that calculates the volume of a triangular prism:\n\n```python\ndef find_volume(base, height, length):\n    if base <= 0 or height <= 0 or length <= 0:\n        return \"Error: Dimensions must be positive values.\"\n    else:\n        return (base * height * length) / 2\n```\n\nThis function takes three arguments: the base, height, and length of the triangular prism. It first checks if any of these values are less than or equal to zero, in which case it returns an error message. If all values are positive, it calculates the volume as (base * height * length) / 2, which is the formula for the volume of a triangular prism.\n", "requirement": "Edge Case Handling"}
{"task_id": 14, "completion": "def find_volume(base_area, height, length):\n    if isinstance(base_area, (list, tuple)) and len(base_area) == 3:\n        base_area, height, length = base_area\n    return base_area * height * length\n", "requirement": "Functionality Extension"}
{"task_id": 14, "completion": "def find_volume(base_area: float, height: float, length: float) -> float:\n    \"\"\"\n    Calculate the volume of a triangular prism.\n\n    Parameters:\n    base_area (float): The area of the base of the triangular prism.\n    height (float): The height of the triangular prism.\n    length (float): The length of the prism.\n\n    Returns:\n    float: The volume of the triangular prism.\n    \"\"\"\n    return base_area * height * length\n", "requirement": "Annotation Coverage"}
{"task_id": 14, "completion": "In Python, the cyclomatic complexity of a function is determined by the number of linearly independent paths through the function's source code. A function with a cyclomatic complexity of 1 has only one path through the code, which is a straightforward calculation without any branching.\n\nHere's a Python function named `find_volume` that calculates the volume of a triangular prism using the formula `base * height * length / 2`:\n\n```python\ndef find_volume(base, height, length):\n    return (base * height * length) / 2\n```\n\nThis function maintains a cyclomatic complexity of 1 because it performs a single calculation without any conditional statements or loops.\n", "requirement": "Code Complexity"}
{"task_id": 14, "completion": "Sure, here is a Python function that calculates the volume of a triangular prism:\n\n```python\ndef find_volume(base, height, length):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n\n    Parameters:\n    base (float): The base of the triangular face.\n    height (float): The height of the triangular face.\n    length (float): The length of the prism.\n\n    Returns:\n    float: The volume of the triangular prism.\n    \"\"\"\n    area = 0.5 * base * height\n    volume = area * length\n    return volume\n```\n\nThis function takes the base, height, and length of the triangular face and the prism as parameters and returns the volume of the triangular prism. The area of the triangular face is calculated first using the formula for the area of a triangle (0.5 * base * height), and then the volume is calculated by multiplying the area by the length of the prism.\n", "requirement": "Code Standard"}
{"task_id": 15, "completion": "def split_lowerstring(s):\n    return ''.join(s.split(s.lower())).split()\n", "requirement": "Input-Output Conditions"}
{"task_id": 15, "completion": "def split_lowerstring(s):\n    if not isinstance(s, str):\n        raise TypeError('Input must be a string.')\n    return [word for word in s.split() if word.islower()]\n", "requirement": "Exception Handling"}
{"task_id": 15, "completion": "def split_lowerstring(s):\n    if not any(char.islower() for char in s):\n        return []\n    return [word for word in s.split(' ') if any(char.islower() for char in word)]\n", "requirement": "Edge Case Handling"}
{"task_id": 15, "completion": "def split_lowerstring(s, include_lower=False):\n    if include_lower:\n        return [''.join(group) for group in itertools.groupby(s, str.islower) if group[0]]\n    else:\n        return [''.join(group) for group in itertools.groupby(s, str.islower) if group[0] and group[0] is False]\n", "requirement": "Functionality Extension"}
{"task_id": 15, "completion": "def split_lowerstring(text: str) -> list:\n    \"\"\"\n    Splits a string at lowercase letters.\n\n    Parameters:\n    text (str): The input string to be split.\n\n    Returns:\n    list: A list of substrings split at lowercase letters.\n    \"\"\"\n    return re.split('(?=[a-z])', text)\n", "requirement": "Annotation Coverage"}
{"task_id": 15, "completion": "To achieve a cyclomatic complexity of 1, we can use a simple approach where we iterate through the string and check if each character is a lowercase letter. If it is, we split the string at that point. Here's the function:\n\n```python\ndef split_lowerstring(s):\n    for i, char in enumerate(s):\n        if char.islower():\n            return s[:i], s[i:]\n    return s, ''\n```\n\nThis function will return a tuple where the first element is the part of the string before the first lowercase letter and the second element is the part of the string after the first lowercase letter. If there are no lowercase letters, it will return the original string and an empty string.\n", "requirement": "Code Complexity"}
{"task_id": 15, "completion": "def split_lowerstring(s):\n    \"\"\"\n    Splits a string at lowercase letters.\n\n    Args:\n        s (str): The input string to be split.\n\n    Returns:\n        list: A list of substrings split at lowercase letters.\n    \"\"\"\n    return ''.join(c for c in s if c.isupper())\n", "requirement": "Code Standard"}
{"task_id": 16, "completion": "def text_lowercase_underscore(text):\n    import re\n    pattern = r'[a-z]+_[a-z]+'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n", "requirement": "Input-Output Conditions"}
{"task_id": 16, "completion": "def text_lowercase_underscore(text):\n    if not isinstance(text, str):\n        raise TypeError('Input must be a string.')\n    import re\n    pattern = r'[a-z]+_[a-z]+'\n    matches = re.findall(pattern, text)\n    return matches\n", "requirement": "Exception Handling"}
{"task_id": 16, "completion": "def text_lowercase_underscore(text):\n    if not text:\n        return 'Not matched!'\n    import re\n    pattern = r'[a-z]+_[a-z]+'\n    if re.search(pattern, text):\n        return 'Matched!'\n    else:\n        return 'Not matched!'\n", "requirement": "Edge Case Handling"}
{"task_id": 16, "completion": "def text_lowercase_underscore(text):\n    import re\n    pattern = r'[a-z]+_[a-z]+'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'No match found.'\n", "requirement": "Functionality Extension"}
{"task_id": 16, "completion": "def text_lowercase_underscore(text: str) -> str:\n    import re\n    pattern = r'\\b[a-z]+_[a-z]+\\b'\n    matches = re.findall(pattern, text)\n    return ' '.join(matches)\n", "requirement": "Annotation Coverage"}
{"task_id": 16, "completion": "def text_lowercase_underscore(text):\n    return re.findall(r'[a-z]+_[a-z]+', text)\n", "requirement": "Code Complexity"}
{"task_id": 16, "completion": "def text_lowercase_underscore(text):\n    import re\n    pattern = r'[a-z]+_[a-z]+'\n    result = re.findall(pattern, text)\n    return result\n", "requirement": "Code Standard"}
{"task_id": 17, "completion": "def square_perimeter(side_length):\n    if not isinstance(side_length, int) or side_length < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    return 4 * side_length\n", "requirement": "Input-Output Conditions"}
{"task_id": 17, "completion": "def square_perimeter(side_length):\n    if side_length < 0:\n        raise ValueError(\"Side length cannot be negative.\")\n    return 4 * side_length\n", "requirement": "Exception Handling"}
{"task_id": 17, "completion": "def square_perimeter(side_length):\n    if side_length < 0:\n        raise ValueError(\"Side length cannot be negative.\")\n    return 4 * side_length\n", "requirement": "Edge Case Handling"}
{"task_id": 17, "completion": "def square_perimeter(side):\n    import math\n    side = round(side)\n    perimeter = 4 * side\n    return perimeter\n", "requirement": "Functionality Extension"}
{"task_id": 17, "completion": "def square_perimeter(a: int) -> int:\n    \"\"\"\n    Calculate the perimeter of a square.\n\n    Parameters:\n    a (int): The side length of the square.\n\n    Returns:\n    int: The perimeter of the square.\n    \"\"\"\n    return 4 * a\n", "requirement": "Annotation Coverage"}
{"task_id": 17, "completion": "def square_perimeter(side_length):\n    return 4 * side_length\n", "requirement": "Code Complexity"}
{"task_id": 17, "completion": "def square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square.\n\n    Parameters:\n    side_length (float): The length of a side of the square.\n\n    Returns:\n    float: The perimeter of the square.\n    \"\"\"\n    return 4 * side_length\n", "requirement": "Code Standard"}
{"task_id": 18, "completion": "def remove_dirty_chars(s1, s2):\n    if not (s1.isalpha() and s2.isalpha()):\n        raise ValueError('Input strings must only contain alphabetic characters.')\n    return ''.join(c for c in s1 if c not in s2)\n", "requirement": "Input-Output Conditions"}
{"task_id": 18, "completion": "def remove_dirty_chars(str1, str2):\n    if not isinstance(str1, str) or not isinstance(str2, str):\n        raise TypeError('Both inputs must be strings.')\n    return ''.join(c for c in str1 if c not in str2)\n", "requirement": "Exception Handling"}
{"task_id": 18, "completion": "def remove_dirty_chars(str1, str2):\n    if not str2:\n        return str1\n    return ''.join(char for char in str1 if char not in str2)\n", "requirement": "Edge Case Handling"}
{"task_id": 18, "completion": "def remove_dirty_chars(s1, s2):\n    s1 = s1.lower()\n    s2 = s2.lower()\n    result = [char for char in s1 if char not in s2]\n    return ''.join(result)\n", "requirement": "Functionality Extension"}
{"task_id": 18, "completion": "def remove_dirty_chars(string: str, second_string: str) -> str:\n    \"\"\"\n    Remove characters from the first string which are present in the second string.\n\n    Args:\n        string (str): The string from which characters will be removed.\n        second_string (str): The string containing characters to be removed.\n\n    Returns:\n        str: The modified string with characters removed.\n    \"\"\"\n    for char in second_string:\n        string = string.replace(char, '')\n    return string\n", "requirement": "Annotation Coverage"}
{"task_id": 18, "completion": "def remove_dirty_chars(s1, s2):\n    \"\"\"\n    Remove characters from the first string which are present in the second string.\n\n    Parameters:\n    s1 (str): The first string from which characters will be removed.\n    s2 (str): The second string containing characters to be removed from s1.\n\n    Returns:\n    str: The modified string with characters removed.\n    \"\"\"\n    for char in s2:\n        s1 = s1.replace(char, '')\n    return s1\n", "requirement": "Code Standard"}
{"task_id": 19, "completion": "def test_duplicate(arr):\n    if not isinstance(arr, list):\n        raise TypeError('Input must be a list of integers.')\n    if len(arr) != len(set(arr)):\n        return True\n    return False\n", "requirement": "Input-Output Conditions"}
{"task_id": 19, "completion": "def test_duplicate(arr):\n    if not isinstance(arr, list):\n        raise ValueError('Input must be a list of integers')\n    for i in arr:\n        if not isinstance(i, int):\n            raise ValueError('Input must be a list of integers')\n    return len(arr) != len(set(arr))\n", "requirement": "Exception Handling"}
{"task_id": 19, "completion": "def test_duplicate(arr):\n    if not arr:\n        return False\n    if len(arr) == 1:\n        return False\n    return len(arr) != len(set(arr))\n", "requirement": "Edge Case Handling"}
{"task_id": 19, "completion": "def test_duplicate(arr):\n    seen = set()\n    duplicates = []\n    for num in arr:\n        if num in seen:\n            duplicates.append(num)\n        else:\n            seen.add(num)\n    return duplicates\n", "requirement": "Functionality Extension"}
{"task_id": 19, "completion": "def test_duplicate(arraynums: list) -> bool:\n    if len(arraynums) == len(set(arraynums)):\n        return False\n    else:\n        return True\n", "requirement": "Annotation Coverage"}
{"task_id": 19, "completion": "def test_duplicate(arr):\n    \"\"\"\n    Check if the given array of integers contains any duplicate element.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    bool: True if there are duplicates, False otherwise.\n    \"\"\"\n    if len(arr) == len(set(arr)):\n        return False\n    else:\n        return True\n", "requirement": "Code Standard"}
{"task_id": 20, "completion": "A Woodall number is a number of the form n * 2^n - 1, where n is a non-negative integer. Here is a Python function that checks if a given number is a Woodall number:\n\n```python\ndef is_woodall(n):\n    if n < 0:\n        return False\n    x = 2**n - 1\n    return x == n\n```\n\nThis function works by first checking if the input number is non-negative. If it is, it calculates the value of 2^n - 1 and checks if this value is equal to the input number. If they are equal, the function returns True, indicating that the number is a Woodall number. Otherwise, it returns False.\n", "requirement": "Input-Output Conditions"}
{"task_id": 20, "completion": "Sure, here is a Python function that checks if a given number is a Woodall number or not. A Woodall number is a number of the form n * 2^n - 1, where n is a non-negative integer.\n\n```python\ndef is_woodall(n):\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    if n < 0:\n        return False\n    return (n * 2**n - 1) % n == 0\n```\n\nThis function first checks if the input is an integer. If not, it raises a TypeError. Then, it checks if the input is non-negative. If not, it returns False. Finally, it checks if the number is a Woodall number by checking if the expression n * 2^n - 1 is divisible by n. If it is, the function returns True; otherwise, it returns False.\n", "requirement": "Exception Handling"}
{"task_id": 20, "completion": "In number theory, a Woodall number is a positive integer of the form n * 2^n - 1, where n is a positive integer. The function 'is_woodall' will check if the given number is a Woodall number or not.\n\nHere is the Python function:\n\n```python\ndef is_woodall(n):\n    if n <= 0:\n        return False\n    x = 1\n    while x <= n:\n        if x * 2**x - 1 == n:\n            return True\n        x += 1\n    return False\n```\n\nThis function works by iterating through all positive integers x until it finds one such that x * 2^x - 1 equals the input number n. If such an x is found, the function returns True, indicating that n is a Woodall number. If no such x is found, the function returns False, indicating that n is not a Woodall number.\n\nThe function handles edge cases such as very large integers and zero by checking if n is less than or equal to zero and returning False in such cases.\n", "requirement": "Edge Case Handling"}
{"task_id": 20, "completion": "Sure, I can help with that. A Woodall number is a number of the form n * 2^n - 1. Here is a Python function that checks if a number is a Woodall number and returns a list of all Woodall numbers up to a given number:\n\n```python\ndef is_woodall(n):\n    if isinstance(n, int) and n >= 0:\n        woodall_numbers = []\n        i = 0\n        while True:\n            woodall_number = i * 2**i - 1\n            if woodall_number > n:\n                break\n            woodall_numbers.append(woodall_number)\n            i += 1\n        if n in woodall_numbers:\n            return True, woodall_numbers\n        else:\n            return False, woodall_numbers\n    else:\n        raise ValueError('Input must be a non-negative integer.')\n```\n\nThis function first checks if the input is a non-negative integer. If it is, it then generates Woodall numbers and checks if the input is one of them. If the input is a Woodall number, it returns True along with the list of Woodall numbers. Otherwise, it returns False along with the list of Woodall numbers up to the input. If the input is not a non-negative integer, the function raises a ValueError.\n", "requirement": "Functionality Extension"}
{"task_id": 20, "completion": "def is_woodall(x: int) -> bool:\n    \"\"\"\n    Check if the given number is a Woodall number.\n\n    A Woodall number is an integer of the form 2^n * (2^n - 1) for some n >= 0.\n\n    Args:\n        x (int): The number to check.\n\n    Returns:\n        bool: True if the number is a Woodall number, False otherwise.\n    \"\"\"\n    n = 0\n    while True:\n        woodall_number = 2**n * (2**n - 1)\n        if woodall_number == x:\n            return True\n        if woodall_number > x:\n            return False\n        n += 1\n", "requirement": "Annotation Coverage"}
{"task_id": 20, "completion": "In number theory, a Woodall number is a positive integer of the form n * 2^n - 1. To check if a number is a Woodall number, we can use the formula n * 2^n - 1 and compare it with the input number. If they are equal, the number is a Woodall number.\n\nHere is the Python function that meets the requirements:\n\n```python\ndef is_woodall(n):\n    return n == (n * 2**n - 1)\n```\n\nThis function has a cyclomatic complexity of 1, as it is a simple, linear function that performs a single comparison.\n", "requirement": "Code Complexity"}
{"task_id": 20, "completion": "Sure, I can help with that. A Woodall number is a number of the form n * 2^n - 1. Here is a function that checks if a number is a Woodall number:\n\n```python\ndef is_woodall(n):\n    \"\"\"\n    Check if the given number is a Woodall number.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is a Woodall number, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False\n    x = 0\n    while (1 << x) - 1 < n:\n        if (1 << x) - 1 == n:\n            return True\n        x += 1\n    return False\n```\n\nThis function uses a while loop to check each power of 2 until it finds a power that, when subtracted by 1, equals the given number. If it finds such a power, it returns True, indicating that the number is a Woodall number. If it doesn't find such a power, it returns False.\n", "requirement": "Code Standard"}
{"task_id": 21, "completion": "def multiples_of_num(m, n):\n    if m < 0 or n < 0:\n        raise ValueError(\"Both m and n must be non-negative.\")\n    return [i * n for i in range(1, m + 1)]\n", "requirement": "Exception Handling"}
{"task_id": 21, "completion": "def multiples_of_num(n, m):\n    if m == 0:\n        return []\n    else:\n        return [n * i for i in range(1, m + 1)]\n", "requirement": "Edge Case Handling"}
{"task_id": 21, "completion": "def multiples_of_num(n, m):\n    if not isinstance(n, (int, float)) or not isinstance(m, int):\n        raise ValueError('Both n and m must be numbers.')\n    if m <= 0:\n        raise ValueError('m must be a positive integer.')\n    return [n * i for i in range(1, m + 1)]\n", "requirement": "Functionality Extension"}
{"task_id": 21, "completion": "def multiples_of_num(m: int, n: int) -> list:\n    \"\"\"\n    Returns a list of the first m multiples of n.\n\n    Args:\n        m (int): The number of multiples to generate.\n        n (int): The number to find multiples of.\n\n    Returns:\n        list: A list of the first m multiples of n.\n    \"\"\"\n    return [i * n for i in range(1, m + 1)]\n", "requirement": "Annotation Coverage"}
{"task_id": 21, "completion": "def multiples_of_num(n, m):\n    return [i * n for i in range(1, m + 1)]\n", "requirement": "Code Complexity"}
{"task_id": 21, "completion": "def multiples_of_num(n, m):\n    \"\"\"\n    Returns the first m multiples of n.\n\n    Parameters:\n    n (int): The number to find multiples of.\n    m (int): The number of multiples to return.\n\n    Returns:\n    list: A list of the first m multiples of n.\n    \"\"\"\n    return [n * i for i in range(1, m + 1)]\n", "requirement": "Code Standard"}
{"task_id": 22, "completion": "def find_first_duplicate(nums):\n    if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums):\n        raise TypeError('Input must be a list of integers.')\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n", "requirement": "Exception Handling"}
{"task_id": 22, "completion": "def find_first_duplicate(nums):\n    if not nums:\n        return -1\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return -1\n", "requirement": "Edge Case Handling"}
{"task_id": 22, "completion": "def find_first_duplicate(nums):\n    duplicates = []\n    seen = set()\n    for num in nums:\n        if num in seen:\n            if num not in duplicates:\n                duplicates.append(num)\n        else:\n            seen.add(num)\n    return duplicates\n", "requirement": "Functionality Extension"}
{"task_id": 22, "completion": "def find_first_duplicate(nums: list) -> int:\n    num_set = set()\n    for num in nums:\n        if num in num_set:\n            return num\n        num_set.add(num)\n    return -1\n", "requirement": "Annotation Coverage"}
{"task_id": 22, "completion": "def find_first_duplicate(nums):\n    \"\"\"\n    Find the first duplicate element in a given array of integers.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        int: The first duplicate element, or -1 if no duplicates are found.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return -1\n", "requirement": "Code Standard"}
{"task_id": 23, "completion": "def maximum_sum(list_of_lists):\n    max_sum = 0\n    for sublist in list_of_lists:\n        sublist_sum = sum(sublist)\n        if sublist_sum > max_sum:\n            max_sum = sublist_sum\n    return max_sum\n", "requirement": "Input-Output Conditions"}
{"task_id": 23, "completion": "def maximum_sum(list_of_lists):\n    if not isinstance(list_of_lists, list):\n        raise TypeError('Input must be a list of lists.')\n    for sublist in list_of_lists:\n        if not isinstance(sublist, list):\n            raise TypeError('All elements in the input list must be lists.')\n        for element in sublist:\n            if not isinstance(element, int):\n                raise TypeError('All elements in the sublists must be integers.')\n    return max(map(sum, list_of_lists))\n", "requirement": "Exception Handling"}
{"task_id": 23, "completion": "def maximum_sum(list_of_lists):\n    if not list_of_lists or all(not sublist for sublist in list_of_lists):\n        return 0\n    return max(sum(sublist) for sublist in list_of_lists)\n", "requirement": "Edge Case Handling"}
{"task_id": 23, "completion": "def maximum_sum(list_of_lists):\n    max_sum = float('-inf')\n    for sublist in list_of_lists:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n    return max_sum\n", "requirement": "Functionality Extension"}
{"task_id": 23, "completion": "def maximum_sum(list1: list[list[int]]) -> int:\n    max_sum = 0\n    for sublist in list1:\n        if sum(sublist) > max_sum:\n            max_sum = sum(sublist)\n    return max_sum\n", "requirement": "Annotation Coverage"}
{"task_id": 23, "completion": "def maximum_sum(list_of_lists):\n    \"\"\"\n    Find the maximum sum of elements in a list of lists.\n\n    Parameters:\n    list_of_lists (list): A list of lists, where each sublist contains integers.\n\n    Returns:\n    int: The maximum sum of elements across all sublists.\n    \"\"\"\n    return max(sum(sublist) for sublist in list_of_lists)\n", "requirement": "Code Standard"}
{"task_id": 24, "completion": "def binary_to_decimal(binary_num):\n    if not isinstance(binary_num, str):\n        raise ValueError('Invalid binary number: Input must be a string.')\n    if not all(digit in '01' for digit in binary_num):\n        raise ValueError('Invalid binary number: Input must be a valid binary string.')\n    decimal_num = 0\n    for digit in binary_num:\n        decimal_num = decimal_num * 2 + int(digit)\n    return decimal_num\n", "requirement": "Exception Handling"}
{"task_id": 24, "completion": "def binary_to_decimal(binary_string):\n    if not binary_string:\n        return 0\n    return int(binary_string, 2)\n", "requirement": "Edge Case Handling"}
{"task_id": 24, "completion": "def binary_to_decimal(binary_num):\n    binary_num = str(binary_num)\n    decimal_num = 0\n    for digit in binary_num:\n        decimal_num = decimal_num * 2 + int(digit)\n    return decimal_num\n", "requirement": "Functionality Extension"}
{"task_id": 24, "completion": "def binary_to_decimal(binary: str) -> int:\n    return int(binary, 2)\n", "requirement": "Annotation Coverage"}
{"task_id": 24, "completion": "def binary_to_decimal(binary_num):\n    binary_num = str(binary_num)\n    decimal_num = 0\n    for digit in binary_num:\n        decimal_num = decimal_num * 2 + int(digit)\n    return decimal_num\n", "requirement": "Code Complexity"}
{"task_id": 24, "completion": "def binary_to_decimal(binary_num):\n    \"\"\"\n    Converts a binary number to its decimal equivalent.\n\n    Args:\n        binary_num (str): A string representing the binary number.\n\n    Returns:\n        int: The decimal equivalent of the binary number.\n    \"\"\"\n    binary_num = str(binary_num)\n    decimal_num = 0\n    for digit in binary_num:\n        decimal_num = decimal_num * 2 + int(digit)\n    return decimal_num\n", "requirement": "Code Standard"}
{"task_id": 25, "completion": "def find_product(arr):\n    count_dict = {}\n    for num in arr:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    product = 1\n    for num, count in count_dict.items():\n        if count == 1:\n            product *= num\n    return product\n", "requirement": "Input-Output Conditions"}
{"task_id": 25, "completion": "def find_product(arr):\n    if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr):\n        raise TypeError('Input must be a list of integers.')\n    count_dict = {}\n    for num in arr:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    product = 1\n    for num, count in count_dict.items():\n        if count == 1:\n            product *= num\n    return product\n", "requirement": "Exception Handling"}
{"task_id": 25, "completion": "def find_product(arr):\n    if not arr:\n        return 1\n    product = 1\n    for num in arr:\n        if arr.count(num) == 1:\n            product *= num\n    return product\n", "requirement": "Edge Case Handling"}
{"task_id": 25, "completion": "def find_product(arr):\n    count_dict = {}\n    for num in arr:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    product = 1\n    for num, count in count_dict.items():\n        if count == 1:\n            product *= num\n    return product\n\n# Test the function\narr = [10, 20, 30, 40, 10, 20]\nprint(find_product(arr))  # Output: 120\n\n# Test the function with negative numbers\narr = [-10, 20, -30, 40, -10, 20]\nprint(find_product(arr))  # Output: -120\n", "requirement": "Functionality Extension"}
{"task_id": 25, "completion": "def find_product(arr: list, n: int) -> int:\n    res = 1\n    for i in range(0, n):\n        flag = 0\n        for j in range(0, n):\n            if (arr[i] == arr[j] and i != j):\n                flag = 1\n        if (flag == 0):\n            res = res * arr[i]\n    return res\n", "requirement": "Annotation Coverage"}
{"task_id": 25, "completion": "def find_product(arr):\n    \"\"\"\n    Find the product of non-repeated elements in a given array.\n\n    Args:\n        arr (list): A list of integers.\n\n    Returns:\n        int: The product of non-repeated elements.\n    \"\"\"\n    # Create a dictionary to store the count of each element\n    count_dict = {}\n    for num in arr:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    # Initialize the product to 1\n    product = 1\n\n    # Multiply the product by each element that occurs only once\n    for num, count in count_dict.items():\n        if count == 1:\n            product *= num\n\n    return product\n", "requirement": "Code Standard"}
{"task_id": 26, "completion": "def check_k_elements(list_of_tuples, k):\n    for tup in list_of_tuples:\n        if len(tup) != k:\n            return False\n    return True\n", "requirement": "Input-Output Conditions"}
{"task_id": 26, "completion": "def check_k_elements(list_of_tuples, k):\n    if not isinstance(list_of_tuples, list) or not all(isinstance(t, tuple) for t in list_of_tuples):\n        raise TypeError('Input must be a list of tuples.')\n    if not isinstance(k, int):\n        raise TypeError('k must be an integer.')\n    for t in list_of_tuples:\n        if len(t) != k:\n            return False\n    return True\n", "requirement": "Exception Handling"}
{"task_id": 26, "completion": "def check_k_elements(list_of_tuples, k):\n    if not list_of_tuples:\n        return False\n    for tup in list_of_tuples:\n        if len(tup) != k:\n            return False\n    return True\n", "requirement": "Edge Case Handling"}
{"task_id": 26, "completion": "def check_k_elements(tuples, k):\n    count = 0\n    for tup in tuples:\n        if len(tup) == k:\n            count += 1\n    return count\n", "requirement": "Functionality Extension"}
{"task_id": 26, "completion": "def check_k_elements(test_list: list[tuple], K: int) -> bool:\n    for sub in test_list:\n        if len(sub) != K:\n            return False\n    return True\n", "requirement": "Annotation Coverage"}
{"task_id": 26, "completion": "def check_k_elements(list_of_tuples, k):\n    \"\"\"\n    Check if the given list of tuples contains all k elements.\n\n    Parameters:\n    list_of_tuples (list): A list of tuples.\n    k (int): The number of elements to check for.\n\n    Returns:\n    bool: True if all tuples contain k elements, False otherwise.\n    \"\"\"\n    for tup in list_of_tuples:\n        if len(tup) != k:\n            return False\n    return True\n", "requirement": "Code Standard"}
{"task_id": 27, "completion": "def remove(input_list):\n    if not isinstance(input_list, list):\n        raise TypeError('Input must be a list.')\n    for element in input_list:\n        if not isinstance(element, str):\n            raise TypeError('All elements in the list must be strings.')\n    return [''.join(filter(lambda x: not x.isdigit(), s)) for s in input_list]\n", "requirement": "Exception Handling"}
{"task_id": 27, "completion": "def remove(list_of_strings):\n    if not list_of_strings:\n        return []\n    return [''.join(filter(lambda x: not x.isdigit(), s)) for s in list_of_strings]\n", "requirement": "Edge Case Handling"}
{"task_id": 27, "completion": "def remove(input_list, chars_to_remove='0123456789'):\n    result = [''.join(ch for ch in s if ch not in chars_to_remove) for s in input_list]\n    return result\n", "requirement": "Functionality Extension"}
{"task_id": 27, "completion": "def remove(input_list: list[str]) -> list[str]:\n    return [''.join(filter(lambda x: not x.isdigit(), s)) for s in input_list]\n", "requirement": "Annotation Coverage"}
{"task_id": 27, "completion": "def remove(input_list):\n    \"\"\"\n    Remove all digits from a list of strings.\n\n    Parameters:\n    input_list (list): A list of strings.\n\n    Returns:\n    list: A list of strings with all digits removed.\n    \"\"\"\n    return [''.join(filter(lambda x: not x.isdigit(), s)) for s in input_list]\n", "requirement": "Code Standard"}
{"task_id": 28, "completion": "def binomial_coeff(n, k):\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return binomial_coeff(n - 1, k - 1) + binomial_coeff(n - 1, k)\n", "requirement": "Input-Output Conditions"}
{"task_id": 28, "completion": "def binomial_coeff(n, k):\n    if n < 0 or k < 0:\n        raise ValueError('Inputs must be non-negative.')\n    if k > n:\n        raise ValueError('k must not be greater than n.')\n    res = 1\n    if (k > n - k):\n        k = n - k\n    for x in range(0 , k):\n        res = res * (n - x)\n        res = res // (x + 1)\n    return res\n", "requirement": "Exception Handling"}
{"task_id": 28, "completion": "def binomial_coeff(n, k):\n    if k == 0 or k == n:\n        return 1\n    if k > n:\n        return 0\n    return binomial_coeff(n - 1, k - 1) + binomial_coeff(n - 1, k)\n", "requirement": "Edge Case Handling"}
{"task_id": 28, "completion": "In Python, you can use memoization to efficiently calculate binomial coefficients for large values of n and k. Memoization is a technique where you store the results of expensive function calls and re-use them when the same inputs occur again.\n\nHere's a Python function that uses memoization to calculate binomial coefficients:\n\n```python\ndef binomial_coeff(n, k, memo={}):\n    if k == 0 or n == k:\n        return 1\n    if (n, k) in memo:\n        return memo[(n, k)]\n    result = binomial_coeff(n - 1, k - 1, memo) + binomial_coeff(n - 1, k, memo)\n    memo[(n, k)] = result\n    return result\n\n# Example usage:\nprint(binomial_coeff(5, 2))  # Output: 10\n```\n\nIn this function, we use a dictionary `memo` to store the results of previous calculations. If the function is called with the same `(n, k)` pair, it returns the stored result instead of recalculating it. This significantly speeds up the function for large values of `n` and `k`.\n\nThe function works by recursively calculating the binomial coefficient using the formula:\n\nC(n, k) = C(n-1, k-1) + C(n-1, k)\n\nThis formula is based on the principle that the binomial coefficient is the sum of the coefficients of the two smaller sub-problems: choosing `k-1` items from `n-1` items and choosing `k` items from `n-1` items.\n\nThe base cases are when `k` is 0 or when `n` is equal to `k`, in which case the binomial coefficient is 1.\n", "requirement": "Functionality Extension"}
{"task_id": 28, "completion": "def binomial_coeff(n: int, k: int) -> int:\n    \"\"\"\n    Calculate the binomial coefficient \"n choose k\".\n\n    Args:\n        n (int): The total number of items.\n        k (int): The number of items to choose.\n\n    Returns:\n        int: The binomial coefficient.\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    if k > n - k:\n        k = n - k\n    result = 1\n    for i in range(1, k + 1):\n        result = result * (n - i + 1) // i\n    return result\n", "requirement": "Annotation Coverage"}
{"task_id": 28, "completion": "Sure, here is a Python function that calculates the binomial coefficient using dynamic programming:\n\n```python\ndef binomial_coeff(n, k):\n    \"\"\"\n    Calculate the binomial coefficient \"n choose k\".\n\n    Args:\n    n (int): The total number of items.\n    k (int): The number of items to choose.\n\n    Returns:\n    int: The binomial coefficient \"n choose k\".\n    \"\"\"\n    C = [[0 for x in range(k+1)] for x in range(n+1)]\n\n    for i in range(n+1):\n        for j in range(min(i, k)+1):\n            if j == 0 or j == i:\n                C[i][j] = 1\n            else:\n                C[i][j] = C[i-1][j-1] + C[i-1][j]\n\n    return C[n][k]\n```\n\nThis function uses a 2D array `C` to store the results of subproblems. The `C[i][j]` stores the binomial coefficient for `i` and `j`. The function iterates over `i` and `j` and fills the array in a bottom-up manner. The base cases are `C[i][0] = 1` and `C[i][i] = 1`. For other values of `j`, it uses the recurrence relation `C[i][j] = C[i-1][j-1] + C[i-1][j]`.\n", "requirement": "Code Standard"}
{"task_id": 29, "completion": "def get_odd_occurrence(arr):\n    if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr):\n        raise TypeError('Input must be a list of integers.')\n    res = 0\n    for element in arr:\n        res ^= element\n    return res\n", "requirement": "Exception Handling"}
{"task_id": 29, "completion": "def get_odd_occurrence(arr):\n    if not arr:\n        return None\n    res = 0\n    for element in arr:\n        res ^= element\n    return res\n", "requirement": "Edge Case Handling"}
{"task_id": 29, "completion": "def get_odd_occurrence(arr: list, arr_size: int) -> int:\n    res = 0\n    for i in range(arr_size):\n        res ^= arr[i]\n    return res\n", "requirement": "Functionality Extension"}
{"task_id": 29, "completion": "def get_odd_occurrence(arr: list, arr_size: int) -> int:\n    res = 0\n    for element in arr:\n        res ^= element\n    return res\n", "requirement": "Annotation Coverage"}
{"task_id": 29, "completion": "def get_odd_occurrence(arr):\n    \"\"\"\n    Find the element occurring odd number of times in a list.\n\n    Args:\n        arr (list): A list of integers.\n\n    Returns:\n        int: The element that occurs an odd number of times.\n    \"\"\"\n    res = 0\n    for element in arr:\n        res ^= element\n    return res\n", "requirement": "Code Standard"}
{"task_id": 30, "completion": "def count_substring_with_equal_ends(s):\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                count += 1\n    return count\n", "requirement": "Input-Output Conditions"}
{"task_id": 30, "completion": "def count_substring_with_equal_ends(s):\n    if not isinstance(s, str):\n        raise TypeError('Input must be a string.')\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                count += 1\n    return count\n", "requirement": "Exception Handling"}
{"task_id": 30, "completion": "def count_substring_with_equal_ends(s):\n    if not s:\n        return 0\n    count = 0\n    n = len(s)\n    for i in range(n):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                count += 1\n    return count\n", "requirement": "Edge Case Handling"}
{"task_id": 30, "completion": "def count_substring_with_equal_ends(s):\n    count = 0\n    n = len(s)\n    for i in range(n):\n        for j in range(i+1, n):\n            if s[i] == s[j]:\n                count += 1\n    return count\n\n# Test the function\ns = \"abcab\"\nprint(count_substring_with_equal_ends(s))  # Output: 4\n\n# Extend the function to handle strings with special characters and spaces, but only count alphabetic characters.\ndef count_substring_with_equal_ends_extended(s):\n    count = 0\n    n = len(s)\n    for i in range(n):\n        for j in range(i+1, n):\n            if s[i].isalpha() and s[j].isalpha() and s[i] == s[j]:\n                count += 1\n    return count\n\n# Test the extended function\ns = \"a!b@c#a$b%a^b&a*b(a)b_a+b-a=b+a<b>a?b/a:b;a[b]a{b}a|b\\\\a`b'a\\\"b\\\"a\"\nprint(count_substring_with_equal_ends_extended(s))  # Output: 4\n", "requirement": "Functionality Extension"}
{"task_id": 30, "completion": "def count_substring_with_equal_ends(s: str) -> int:\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                count += 1\n    return count\n", "requirement": "Annotation Coverage"}
{"task_id": 30, "completion": "def count_substring_with_equal_ends(s):\n    \"\"\"\n    Counts all the substrings starting and ending with the same characters.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The count of substrings with equal ends.\n    \"\"\"\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                count += 1\n    return count\n", "requirement": "Code Standard"}
{"task_id": 31, "completion": "Here is a Python function that meets the requirements:\n\n```python\nimport heapq\n\ndef func(lists, k):\n    if k > sum(len(l) for l in lists):\n        raise ValueError('k cannot be greater than the number of distinct integers')\n    counter = {}\n    for l in lists:\n        for num in l:\n            counter[num] = counter.get(num, 0) + 1\n    heap = [(v, k) for k, v in counter.items()]\n    heapq.heapify(heap)\n    return [heapq.heappop(heap)[1] for _ in range(k)]\n```\n\nThis function first checks if `k` is greater than the total number of distinct integers across all lists. If it is, it raises a `ValueError`. Then, it creates a counter dictionary to count the occurrences of each integer. After that, it converts the counter dictionary into a heap, where the smallest element is at the top. Finally, it pops the top `k` elements from the heap and returns them.\n", "requirement": "Exception Handling"}
{"task_id": 31, "completion": "Here is a Python function that uses the heap queue algorithm to find the top k integers that occur most frequently from given lists of sorted and distinct integers. The function returns an empty list if all input lists are empty.\n\n```python\nimport heapq\n\ndef func(lists, k):\n    if not any(lists):\n        return []\n\n    # Create a list of tuples (frequency, number) for each list\n    lists = [[(num, i) for num in l] for i, l in enumerate(lists)]\n    # Flatten the list of lists into a single list\n    flat_list = [item for sublist in lists for item in sublist]\n\n    # Use a heap to find the top k frequent numbers\n    heap = []\n    for num, i in flat_list:\n        if len(heap) < k:\n            heapq.heappush(heap, (num, i))\n        else:\n            heapq.heappushpop(heap, (num, i))\n\n    # Extract the top k frequent numbers\n    top_k = [heapq.heappop(heap) for _ in range(len(heap))]\n    top_k.sort(key=lambda x: x[1])  # Sort by the original index\n    return [num for num, _ in top_k]\n\n# Example usage:\nlists = [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\nk = 2\nprint(func(lists, k))  # Output: [3, 2]\n```\n\nThis function works by first flattening the list of lists into a single list of tuples, where each tuple contains a number and its original index. It then uses a heap to keep track of the top k frequent numbers. The heap is updated with each number from the flat list, ensuring that it always contains the top k frequent numbers. Finally, the function sorts the top k numbers by their original index and returns the list of numbers.\n", "requirement": "Edge Case Handling"}
{"task_id": 31, "completion": "Here is a Python function that uses the heapq module to find the top k integers that occur most frequently from a list of sorted and distinct integers. The function handles the case where k is zero by returning an empty list.\n\n```python\nimport heapq\n\ndef func(nums, k):\n    if k == 0:\n        return []\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n    return heapq.nlargest(k, count.keys(), key=count.get)\n```\n\nThis function works by first creating a dictionary `count` that maps each number in `nums` to its frequency. Then, it uses `heapq.nlargest` to find the top `k` keys in `count` based on their values. If `k` is zero, the function returns an empty list as requested.\n", "requirement": "Functionality Extension"}
{"task_id": 31, "completion": "def func(nums: List[List[int]], k: int) -> List[int]:\n    from heapq import nlargest\n    from collections import Counter\n    counter = Counter(x for sublist in nums for x in sublist)\n    return nlargest(k, counter.keys(), key=counter.get)\n", "requirement": "Annotation Coverage"}
{"task_id": 31, "completion": "def func(nums, k):\n    \"\"\"\n    Find the top k integers that occur most frequently from a list of sorted and distinct integers.\n\n    Args:\n        nums (list): A list of sorted and distinct integers.\n        k (int): The number of top integers to find.\n\n    Returns:\n        list: A list of the top k integers with the highest frequency.\n    \"\"\"\n    import heapq\n\n    # Use a dictionary to count the frequency of each number\n    count = {}\n    for num in nums:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n\n    # Use a heap to keep track of the top k frequent numbers\n    heap = []\n    for num, freq in count.items():\n        if len(heap) < k:\n            heapq.heappush(heap, (freq, num))\n        else:\n            heapq.heappushpop(heap, (freq, num))\n\n    # Extract the top k frequent numbers from the heap\n    top_k = [num for _, num in heap]\n    return top_k\n", "requirement": "Code Standard"}
{"task_id": 32, "completion": "def max_prime_factors(n):\n    max_prime = -1\n    while n % 2 == 0:\n        max_prime = 2\n        n >>= 1\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            max_prime = i\n            n = n / i\n    if n > 2:\n        max_prime = n\n    return int(max_prime)\n", "requirement": "Input-Output Conditions"}
{"task_id": 32, "completion": "def max_prime_factors(n):\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError('Input must be a positive integer')\n\n    max_prime = -1\n\n    while n % 2 == 0:\n        max_prime = 2\n        n >>= 1\n\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            max_prime = i\n            n = n / i\n\n    if n > 2:\n        max_prime = n\n\n    return int(max_prime)\n", "requirement": "Exception Handling"}
{"task_id": 32, "completion": "def max_prime_factors(n):\n    max_prime = -1\n    while n % 2 == 0:\n        max_prime = 2\n        n >>= 1  # equivalent to n /= 2\n\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            max_prime = i\n            n = n / i\n\n    if n > 2:\n        max_prime = n\n\n    return int(max_prime)\n", "requirement": "Edge Case Handling"}
{"task_id": 32, "completion": "def max_prime_factors(n, return_all=False):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n\n    if return_all:\n        return factors\n    else:\n        return max(factors)\n", "requirement": "Functionality Extension"}
{"task_id": 32, "completion": "def max_prime_factors(n: int) -> int:\n    max_prime = -1\n    while n % 2 == 0:\n        max_prime = 2\n        n >>= 1\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            max_prime = i\n            n = n / i\n    if n > 2:\n        max_prime = n\n    return int(max_prime)\n", "requirement": "Annotation Coverage"}
{"task_id": 32, "completion": "def max_prime_factors(n):\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n\n", "requirement": "Code Complexity"}
{"task_id": 32, "completion": "def max_prime_factors(n):\n    \"\"\"\n    Find the largest prime factor of a given number.\n\n    Parameters:\n    n (int): The number to find the largest prime factor of.\n\n    Returns:\n    int: The largest prime factor of the given number.\n    \"\"\"\n    max_prime = -1\n\n    while n % 2 == 0:\n        max_prime = 2\n        n >>= 1  # equivalent to n /= 2\n\n    while n % 3 == 0:\n        max_prime = 3\n        n = n / 3\n\n    i = 5\n    while i * i <= n:\n        while n % i == 0:\n            max_prime = i\n            n = n / i\n        while n % (i + 2) == 0:\n            max_prime = i + 2\n            n = n / (i + 2)\n        i += 6\n\n    if n > 1:\n        max_prime = n\n\n    return int(max_prime)\n", "requirement": "Code Standard"}
{"task_id": 33, "completion": "def decimal_to_binary(n):\n    if not isinstance(n, int) or n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary\n", "requirement": "Exception Handling"}
{"task_id": 33, "completion": "def decimal_to_binary(n):\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary\n", "requirement": "Edge Case Handling"}
{"task_id": 33, "completion": "def decimal_to_binary(decimal_list):\n    binary_list = []\n    for decimal in decimal_list:\n        binary = bin(decimal).replace(\"0b\", \"\")\n        binary_list.append(binary)\n    return binary_list\n", "requirement": "Functionality Extension"}
{"task_id": 33, "completion": "def decimal_to_binary(N: int) -> str:\n    if N == 0:\n        return '0'\n    binary = ''\n    while N > 0:\n        binary = str(N % 2) + binary\n        N = N // 2\n    return binary\n", "requirement": "Annotation Coverage"}
{"task_id": 33, "completion": "def decimal_to_binary(n):\n    if n == 0:\n        return 0\n    else:\n        return n % 2 + 10 * decimal_to_binary(int(n / 2))\n", "requirement": "Code Complexity"}
{"task_id": 33, "completion": "def decimal_to_binary(n):\n    \"\"\"\n    Convert a decimal number to a binary number.\n\n    Args:\n        n (int): The decimal number to convert.\n\n    Returns:\n        str: The binary representation of the decimal number.\n    \"\"\"\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary\n", "requirement": "Code Standard"}
{"task_id": 34, "completion": "def find_missing(arr):\n    if not all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)):\n        raise ValueError('Input list must be sorted.')\n    n = len(arr) + 1\n    total = n * (n + 1) // 2\n    return total - sum(arr)\n", "requirement": "Exception Handling"}
{"task_id": 34, "completion": "def find_missing(arr):\n    if not arr:\n        return 1\n    if arr[0] != 1:\n        return 1\n    for i in range(1, len(arr)):\n        if arr[i] - arr[i - 1] > 1:\n            return arr[i] - 1\n    return arr[-1] + 1\n", "requirement": "Edge Case Handling"}
{"task_id": 34, "completion": "def find_missing(arr):\n    missing_numbers = []\n    for i in range(1, len(arr)):\n        if arr[i] - arr[i-1] > 1:\n            for j in range(arr[i-1] + 1, arr[i]):\n                missing_numbers.append(j)\n    return missing_numbers\n", "requirement": "Functionality Extension"}
{"task_id": 34, "completion": "def find_missing(ar: list, N: int) -> int:\n    total = (N + 1) * (N + 2) // 2\n    return total - sum(ar)\n", "requirement": "Annotation Coverage"}
{"task_id": 34, "completion": "def find_missing(arr):\n    \"\"\"\n    Find the missing number in a sorted array.\n\n    Parameters:\n    arr (list): A sorted list of integers with one number missing.\n\n    Returns:\n    int: The missing number.\n    \"\"\"\n    n = len(arr) + 1\n    total_sum = n * (n + 1) // 2\n    current_sum = sum(arr)\n    return total_sum - current_sum\n", "requirement": "Code Standard"}
{"task_id": 35, "completion": "Sure, here is a simple function in Python that calculates the n-th rectangular number:\n\n```python\ndef find_rect_num(n):\n    return n * (n + 1) // 2\n```\n\nThis function works by using the formula for the n-th triangular number, but since rectangles are two-dimensional, we need to double the result. The formula for the n-th triangular number is `n * (n + 1) / 2`. By doubling this result, we get the n-th rectangular number.\n", "requirement": "Input-Output Conditions"}
{"task_id": 35, "completion": "def find_rect_num(n):\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    return n * (n + 1) // 2\n", "requirement": "Exception Handling"}
{"task_id": 35, "completion": "def find_rect_num(n):\n    if n == 1:\n        return 2\n    else:\n        return n * (n + 1)\n", "requirement": "Edge Case Handling"}
{"task_id": 35, "completion": "Sure, here is a Python function that calculates the n-th rectangular number and extends it to handle a list of integers:\n\n```python\ndef find_rect_num(n):\n    if isinstance(n, list):\n        return [find_rect_num(i) for i in n]\n    else:\n        return n * (n + 1) // 2\n```\n\nThis function works by checking if the input is a list. If it is, it applies the function recursively to each element in the list. If it's not a list, it calculates the n-th rectangular number using the formula `n * (n + 1) // 2`.\n", "requirement": "Functionality Extension"}
{"task_id": 35, "completion": "def find_rect_num(n: int) -> int:\n    \"\"\"\n    Find the n-th rectangular number.\n\n    Args:\n        n (int): The position of the rectangular number in the sequence.\n\n    Returns:\n        int: The n-th rectangular number.\n    \"\"\"\n    return n * (n + 1) // 2\n", "requirement": "Annotation Coverage"}
{"task_id": 35, "completion": "def find_rect_num(n):\n    return n * (n + 1) // 2\n", "requirement": "Code Complexity"}
{"task_id": 35, "completion": "Sure, here is a Python function that meets the requirements:\n\n```python\ndef find_rect_num(n):\n    \"\"\"\n    Returns the n-th rectangular number.\n\n    Args:\n        n (int): The position of the rectangular number in the sequence.\n\n    Returns:\n        int: The n-th rectangular number.\n    \"\"\"\n    return n * (n + 1) // 2\n```\n\nThis function uses the formula for the n-th triangular number and adjusts it to calculate the n-th rectangular number. The function is named `find_rect_num` and takes an integer `n` as input, returning the n-th rectangular number.\n", "requirement": "Code Standard"}
{"task_id": 36, "completion": "def find_nth_digit(num1, num2, n):\n    fraction = num1 / num2\n    fraction_str = str(fraction)\n    nth_digit = fraction_str[n]\n    return int(nth_digit)\n", "requirement": "Input-Output Conditions"}
{"task_id": 36, "completion": "def find_nth_digit(n, m):\n    if m == 0:\n        raise ValueError('Denominator cannot be zero')\n    return n // m\n", "requirement": "Exception Handling"}
{"task_id": 36, "completion": "def find_nth_digit(num1, num2, n):\n    if num1 == 0:\n        return 0\n    if n == 0:\n        return 0\n    if n < 0:\n        return -1\n    if num2 == 0:\n        return -1\n    if num1 < num2:\n        return -1\n    if num1 % num2 == 0:\n        return 0\n    remainder = num1 % num2\n    while remainder != 0 and n > 0:\n        remainder *= 10\n        digit = remainder // num2\n        remainder %= num2\n        n -= 1\n    if n == 0:\n        return digit\n    else:\n        return -1\n", "requirement": "Edge Case Handling"}
{"task_id": 36, "completion": "def find_nth_digit(numerator, denominator, n):\n    if numerator < 0:\n        numerator = -numerator\n    if denominator < 0:\n        denominator = -denominator\n    fraction = str(numerator / denominator)\n    fraction = fraction.replace('.', '')\n    if n < 0 or n >= len(fraction):\n        return None\n    return int(fraction[n])\n", "requirement": "Functionality Extension"}
{"task_id": 36, "completion": "def find_nth_digit(p: int, q: int, N: int) -> int:\n    \"\"\"\n    Find the Nth digit in the proper fraction of two given numbers.\n\n    Parameters:\n    p (int): The numerator of the fraction.\n    q (int): The denominator of the fraction.\n    N (int): The position of the digit to find.\n\n    Returns:\n    int: The Nth digit in the proper fraction.\n    \"\"\"\n    if p == 0:\n        return 0\n    if N == 1:\n        return p % 10\n    p = p * 10\n    while N > 1:\n        while p < q:\n            p = p * 10\n        p = p % q\n        N -= 1\n    return p // q\n", "requirement": "Annotation Coverage"}
{"task_id": 36, "completion": "def find_nth_digit(num1, num2, n):\n    \"\"\"\n    Find the nth digit in the proper fraction of two given numbers.\n\n    Args:\n    num1 (int): The numerator of the fraction.\n    num2 (int): The denominator of the fraction.\n    n (int): The position of the digit to find.\n\n    Returns:\n    int: The nth digit in the proper fraction.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer.\")\n\n    # Calculate the nth digit\n    result = (num1 * (10 ** n)) // num2\n\n    # Return the nth digit\n    return result\n", "requirement": "Code Complexity"}
{"task_id": 36, "completion": "def find_nth_digit(num1, num2, n):\n    \"\"\"\n    Find the nth digit in the proper fraction of two given numbers.\n\n    Parameters:\n    num1 (int): The numerator of the fraction.\n    num2 (int): The denominator of the fraction.\n    n (int): The position of the digit to find.\n\n    Returns:\n    int: The nth digit in the proper fraction.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer.\")\n\n    # Convert the numbers to strings to work with digits\n    num1_str = str(num1)\n    num2_str = str(num2)\n\n    # Find the length of the proper fraction\n    frac_len = len(num2_str)\n\n    # Check if n is within the length of the proper fraction\n    if n > frac_len:\n        raise ValueError(\"n is out of range for the given fraction.\")\n\n    # Find the nth digit by indexing the proper fraction\n    nth_digit = int(num1_str[0])\n\n    return nth_digit\n", "requirement": "Code Standard"}
{"task_id": 37, "completion": "def sort_mixed_list(mixed_list):\n    if not isinstance(mixed_list, list):\n        raise TypeError('Input must be a list.')\n    for item in mixed_list:\n        if not isinstance(item, (int, str)):\n            raise TypeError('List must contain only integers and strings.')\n    return sorted(mixed_list, key=lambda x: (isinstance(x, str), x))\n", "requirement": "Exception Handling"}
{"task_id": 37, "completion": "def sort_mixed_list(mixed_list):\n    if not mixed_list:\n        return []\n    else:\n        return sorted(mixed_list, key=lambda x: (isinstance(x, int), x))\n", "requirement": "Edge Case Handling"}
{"task_id": 37, "completion": "def sort_mixed_list(mixed_list, reverse_strings=False):\n    def sort_key(item):\n        if isinstance(item, str):\n            return (True, item[::-1] if reverse_strings else item)\n        return (False, item)\n\n    return sorted(mixed_list, key=sort_key)\n", "requirement": "Functionality Extension"}
{"task_id": 37, "completion": "def sort_mixed_list(mixed_list: list[Union[int, str]]) -> list[Union[int, str]]:\n    \"\"\"\n    Sorts a mixed list of integers and strings.\n\n    Parameters:\n    mixed_list (list[Union[int, str]]): The list to be sorted.\n\n    Returns:\n    list[Union[int, str]]: The sorted list.\n    \"\"\"\n    return sorted(mixed_list, key=lambda x: (isinstance(x, str), x))\n", "requirement": "Annotation Coverage"}
{"task_id": 37, "completion": "def sort_mixed_list(mixed_list):\n    \"\"\"\n    Sorts a mixed list of integers and strings.\n\n    Args:\n        mixed_list (list): A list containing integers and strings.\n\n    Returns:\n        list: A sorted list of integers and strings.\n    \"\"\"\n    # Separate integers and strings\n    int_list = [x for x in mixed_list if isinstance(x, int)]\n    str_list = [x for x in mixed_list if isinstance(x, str)]\n\n    # Sort both lists\n    int_list.sort()\n    str_list.sort()\n\n    # Combine and return the sorted list\n    return int_list + str_list\n", "requirement": "Code Standard"}
{"task_id": 38, "completion": "def div_even_odd(nums):\n    even = [x for x in nums if x % 2 == 0]\n    odd = [x for x in nums if x % 2 != 0]\n    if even and odd:\n        return even[0] / odd[0]\n    else:\n        return None\n", "requirement": "Input-Output Conditions"}
{"task_id": 38, "completion": "def div_even_odd(nums):\n    even = [x for x in nums if x % 2 == 0]\n    odd = [x for x in nums if x % 2 != 0]\n    if not even or not odd:\n        raise ValueError('List must contain at least one even and one odd number.')\n    return even[0] / odd[0]\n", "requirement": "Exception Handling"}
{"task_id": 38, "completion": "def div_even_odd(nums):\n    even_num = next((num for num in nums if num % 2 == 0), None)\n    odd_num = next((num for num in nums if num % 2 != 0), None)\n\n    if even_num is None or odd_num is None:\n        return None\n    if even_num == 0:\n        return 0\n    return even_num / odd_num\n", "requirement": "Edge Case Handling"}
{"task_id": 38, "completion": "def div_even_odd(nums):\n    even_num = None\n    odd_num = None\n    for num in nums:\n        if num % 2 == 0:\n            if even_num is None:\n                even_num = num\n            else:\n                even_num = even_num / num\n        else:\n            if odd_num is None:\n                odd_num = num\n            else:\n                odd_num = odd_num / num\n    if even_num is None or odd_num is None:\n        return \"No even or odd number found\"\n    return even_num / odd_num\n", "requirement": "Functionality Extension"}
{"task_id": 38, "completion": "def div_even_odd(list1: list) -> tuple[int, float]:\n    even_num = None\n    odd_num = None\n    for num in list1:\n        if num % 2 == 0 and even_num is None:\n            even_num = num\n        elif num % 2 != 0 and odd_num is None:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            break\n    if even_num is None or odd_num is None:\n        raise ValueError(\"List must contain at least one even and one odd number.\")\n    return even_num, odd_num / even_num\n", "requirement": "Annotation Coverage"}
{"task_id": 38, "completion": "def div_even_odd(nums):\n    even = [x for x in nums if x % 2 == 0]\n    odd = [x for x in nums if x % 2 != 0]\n    if even and odd:\n        return even[0] / odd[0]\n    else:\n        return None\n", "requirement": "Code Complexity"}
{"task_id": 38, "completion": "def div_even_odd(nums):\n    \"\"\"\n    Find the division of the first even and the first odd number in a given list.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        float: The division of the first even and the first odd number.\n\n    Raises:\n        ValueError: If the list does not contain at least one even and one odd number.\n    \"\"\"\n    even = [x for x in nums if x % 2 == 0]\n    odd = [x for x in nums if x % 2 != 0]\n\n    if not even or not odd:\n        raise ValueError(\"The list must contain at least one even and one odd number.\")\n\n    return even[0] / odd[0]\n", "requirement": "Code Standard"}
{"task_id": 39, "completion": "def rearrange_string(s):\n    # Sort the string\n    sorted_s = ''.join(sorted(s))\n    # Initialize the result string\n    result = ''\n    # Iterate over the sorted string\n    for i in range(len(sorted_s)):\n        # If the current character is not the same as the previous one, append it to the result\n        if i == 0 or sorted_s[i] != sorted_s[i - 1]:\n            result += sorted_s[i]\n    # Return the result string\n    return result\n", "requirement": "Input-Output Conditions"}
{"task_id": 39, "completion": "def rearrange_string(s):\n    if not isinstance(s, str):\n        raise ValueError('Input must be a string.')\n    if not s.islower():\n        raise ValueError('Input string must contain only lowercase letters.')\n    s = list(s)\n    s.sort()\n    for i in range(len(s) - 1):\n        if s[i] == s[i + 1]:\n            return False\n    return True\n", "requirement": "Exception Handling"}
{"task_id": 39, "completion": "def rearrange_string(s):\n    if not s:\n        return ''\n    if len(set(s)) == 1:\n        return ''\n    s = sorted(s)\n    result = ''\n    for i in range(len(s) - 1):\n        if s[i] == s[i + 1]:\n            continue\n        result += s[i]\n    result += s[-1]\n    return result\n", "requirement": "Edge Case Handling"}
{"task_id": 39, "completion": "To solve this problem, we can use a recursive approach to generate all possible permutations of the string and then check if each permutation satisfies the condition that adjacent characters are different. Here's a Python function that accomplishes this:\n\n```python\nfrom itertools import permutations\n\ndef rearrange_string(s):\n    # Generate all permutations of the string\n    perms = [''.join(p) for p in permutations(s)]\n    \n    # Filter permutations where adjacent characters are different\n    valid_perms = [p for p in perms if all(p[i] != p[i + 1] for i in range(len(p) - 1))]\n    \n    return valid_perms\n\n# Example usage:\nprint(rearrange_string('abc'))\n```\n\nThis function will return a list of all possible valid rearrangements of the string where adjacent characters are different. If no such rearrangements exist, it will return an empty list.\n", "requirement": "Functionality Extension"}
{"task_id": 39, "completion": "def rearrange_string(S: str) -> str:\n    \"\"\"\n    Check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.\n\n    Args:\n        S (str): The input string.\n\n    Returns:\n        str: The rearranged string if possible, otherwise 'No'.\n    \"\"\"\n    S = sorted(S)\n    for i in range(len(S) - 1):\n        if S[i] == S[i + 1]:\n            return 'No'\n    return ''.join(S)\n", "requirement": "Annotation Coverage"}
{"task_id": 39, "completion": "def rearrange_string(s):\n    \"\"\"\n    Check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: True if the string can be rearranged, False otherwise.\n    \"\"\"\n    s = list(s)\n    s.sort()\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            return False\n    return True\n", "requirement": "Code Standard"}
{"task_id": 40, "completion": "Here is a Python function that meets your requirements:\n\n```python\nimport collections\n\ndef freq_element(list_of_lists):\n    if not isinstance(list_of_lists, list) or not all(isinstance(sub_list, list) for sub_list in list_of_lists):\n        raise TypeError('Input must be a list of lists.')\n    flat_list = [item for sublist in list_of_lists for item in sublist]\n    freq_dict = collections.Counter(flat_list)\n    return freq_dict\n```\n\nThis function first checks if the input is a list of lists. If not, it raises a `TypeError`. Then, it flattens the list of lists into a single list using a list comprehension. Finally, it uses the `Counter` class from the `collections` module to count the frequency of each element in the flattened list and returns the resulting dictionary.\n", "requirement": "Exception Handling"}
{"task_id": 40, "completion": "Here is a Python function that meets the requirements:\n\n```python\nimport collections\n\ndef freq_element(list_of_lists):\n    if not list_of_lists:\n        return {}\n    flat_list = [item for sublist in list_of_lists for item in sublist]\n    freq_dict = collections.Counter(flat_list)\n    return freq_dict\n```\n\nThis function first checks if the input list is empty. If it is, it returns an empty dictionary. Otherwise, it flattens the list of lists into a single list using list comprehension, and then uses the `Counter` class from the `collections` module to count the frequency of each element in the list. The resulting dictionary is then returned.\n", "requirement": "Edge Case Handling"}
{"task_id": 40, "completion": "To solve this problem, we can use recursion to handle nested lists of arbitrary depth. We will use the `collections.Counter` class to count the frequency of each integer. Here is the function:\n\n```python\nimport collections\n\ndef freq_element(nested_list):\n    counter = collections.Counter()\n    for element in nested_list:\n        if isinstance(element, list):\n            counter.update(freq_element(element))\n        elif isinstance(element, int):\n            counter[element] += 1\n    return counter\n```\n\nThis function works by iterating over each element in the input list. If the element is a list, it calls itself recursively to handle the nested list. If the element is an integer, it increments the corresponding count in the `Counter` object.\n\nHere's an example usage:\n\n```python\nnested_list = [1, 2, [1, 2, 3, [1, 2, 3]], 4, 5, [4, 5, [4, 5, 6]]]\nprint(freq_element(nested_list))\n```\n\nOutput:\n\n```\nCounter({1: 3, 2: 3, 3: 2, 4: 3, 5: 2, 6: 1})\n```\n\nThis output shows that the integer `1` appears 3 times, `2` appears 3 times, `3` appears 2 times, and so on.\n", "requirement": "Functionality Extension"}
{"task_id": 40, "completion": "To find the frequency of elements in a given list of lists using the `collections` module, you can use the `Counter` class. Here's a function that meets the requirements you've specified:\n\n```python\nfrom collections import Counter\nfrom typing import List, Dict\n\ndef freq_element(nums: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Find the frequency of elements in a given list of lists.\n\n    Parameters:\n    nums (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    Dict[int, int]: A dictionary where keys are integers and values are their frequencies.\n    \"\"\"\n    flat_list = [item for sublist in nums for item in sublist]\n    return dict(Counter(flat_list))\n\n# Example usage:\n# nums = [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\n# print(freq_element(nums))\n# Output: {1: 1, 2: 2, 3: 3, 4: 2, 5: 1}\n```\n\nThis function first flattens the list of lists into a single list using a list comprehension, then uses `Counter` to count the frequency of each element and returns the result as a dictionary.\n", "requirement": "Annotation Coverage"}
{"task_id": 40, "completion": "To meet the requirement of cyclomatic complexity of 1, we can use the `Counter` class from the `collections` module to count the frequency of elements in a list of lists. Here's the function:\n\n```python\nfrom collections import Counter\n\ndef freq_element(list_of_lists):\n    # Flatten the list of lists into a single list\n    flat_list = [item for sublist in list_of_lists for item in sublist]\n    # Use Counter to count frequencies\n    frequency = Counter(flat_list)\n    return frequency\n```\n\nThis function first flattens the list of lists into a single list using a list comprehension, then uses `Counter` to count the frequency of each element. The `Counter` class is a part of the `collections` module and is designed to count hashable objects, which is exactly what we need for this task.\n", "requirement": "Code Complexity"}
{"task_id": 40, "completion": "Here is a Python function that meets the requirements:\n\n```python\nimport collections\n\ndef freq_element(list_of_lists):\n    \"\"\"\n    Find the frequency of elements in a given list of lists using collections module.\n\n    Args:\n        list_of_lists (list): A list of lists.\n\n    Returns:\n        dict: A dictionary where keys are elements and values are their frequencies.\n    \"\"\"\n    # Flatten the list of lists\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n\n    # Use collections.Counter to count the frequency of each element\n    frequency = collections.Counter(flattened_list)\n\n    return frequency\n```\n\nThis function first flattens the list of lists into a single list using list comprehension. Then, it uses `collections.Counter` to count the frequency of each element in the flattened list. The result is a dictionary where keys are the elements and values are their corresponding frequencies.\n", "requirement": "Code Standard"}
{"task_id": 41, "completion": "def filter_evennumbers(numbers):\n    if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers):\n        raise TypeError('Input must be a list of integers.')\n    return list(filter(lambda x: x % 2 == 0, numbers))\n", "requirement": "Exception Handling"}
{"task_id": 41, "completion": "def filter_evennumbers(nums):\n    if not nums:\n        return []\n    return list(filter(lambda x: x % 2 == 0, nums))\n", "requirement": "Edge Case Handling"}
{"task_id": 41, "completion": "def filter_evennumbers(numbers):\n    # Filter out non-integer types\n    numbers = [num for num in numbers if isinstance(num, int)]\n    # Use a lambda function to filter even numbers\n    even_numbers = list(filter(lambda x: x % 2 == 0, numbers))\n    return even_numbers\n", "requirement": "Functionality Extension"}
{"task_id": 41, "completion": "def filter_evennumbers(nums: list) -> list:\n    \"\"\"\n    Filters out even numbers from a list using a lambda function.\n\n    Parameters:\n    nums (list): A list of integers.\n\n    Returns:\n    list: A list of integers that are not even.\n    \"\"\"\n    return list(filter(lambda x: x % 2 != 0, nums))\n", "requirement": "Annotation Coverage"}
{"task_id": 41, "completion": "def filter_evennumbers(numbers):\n    \"\"\"\n    Filters even numbers from a list using a lambda function.\n\n    Args:\n        numbers (list): A list of integers.\n\n    Returns:\n        list: A list of even numbers from the input list.\n    \"\"\"\n    return list(filter(lambda x: x % 2 == 0, numbers))\n", "requirement": "Code Standard"}
{"task_id": 42, "completion": "def find_sum(arr):\n    unique_elements = set(arr)\n    repeated_elements = [x for x in arr if arr.count(x) > 1]\n    if not repeated_elements:\n        return 0\n    return sum(repeated_elements)\n", "requirement": "Input-Output Conditions"}
{"task_id": 42, "completion": "def find_sum(arr):\n    if not isinstance(arr, list):\n        raise TypeError('Input must be a list.')\n    res = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] == arr[j]:\n                res += arr[i]\n    return res\n", "requirement": "Exception Handling"}
{"task_id": 42, "completion": "def find_sum(arr):\n    if not arr:\n        return 0\n    count_dict = {}\n    for num in arr:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    return sum(key * value for key, value in count_dict.items() if value > 1)\n", "requirement": "Edge Case Handling"}
{"task_id": 42, "completion": "def find_sum(arr):\n    # Create an empty dictionary to store the frequency of each element\n    freq = {}\n    # Iterate over the array\n    for num in arr:\n        # If the number is already in the dictionary, increment its count\n        if num in freq:\n            freq[num] += 1\n        # If the number is not in the dictionary, add it with a count of 1\n        else:\n            freq[num] = 1\n    # Initialize the sum to 0\n    total_sum = 0\n    # Iterate over the dictionary\n    for key, value in freq.items():\n        # If the count of an element is greater than 1, add it to the sum\n        if value > 1:\n            total_sum += key * value\n    # Return the total sum\n    return total_sum\n", "requirement": "Functionality Extension"}
{"task_id": 42, "completion": "def find_sum(arr: list, n: int) -> int:\n    res = 0\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            if (arr[i] == arr[j]):\n                res = res + arr[i]\n    return res\n", "requirement": "Annotation Coverage"}
{"task_id": 42, "completion": "def find_sum(arr):\n    from collections import Counter\n    count = Counter(arr)\n    return sum(key for key, value in count.items() if value > 1)\n", "requirement": "Code Complexity"}
{"task_id": 42, "completion": "def find_sum(arr):\n    \"\"\"\n    Find the sum of repeated elements in a given array.\n\n    Parameters:\n    arr (list): The input array.\n\n    Returns:\n    int: The sum of repeated elements.\n    \"\"\"\n    # Create a dictionary to store the count of each element\n    count_dict = {}\n    for num in arr:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    # Calculate the sum of elements that appear more than once\n    sum_repeated = sum(key for key, value in count_dict.items() if value > 1)\n\n    return sum_repeated\n", "requirement": "Code Standard"}
{"task_id": 43, "completion": "Here is a Python function that uses regex to match sequences of lowercase letters joined by an underscore:\n\n```python\nimport re\n\ndef text_match(text):\n    patterns = '[_]+'\n    if re.search(patterns, text):\n        return 'Matched!'\n    else:\n        return 'Not matched!'\n```\n\nThis function uses the `re.search` method to search for the pattern `[_]+` in the input text. The pattern `[_]+` matches one or more underscores. If a match is found, the function returns 'Matched!'; otherwise, it returns 'Not matched!'.\n", "requirement": "Input-Output Conditions"}
{"task_id": 43, "completion": "Here is a Python function that meets your requirements:\n\n```python\nimport re\n\ndef text_match(text):\n    if not isinstance(text, str):\n        raise TypeError('Input must be a string.')\n    patterns = '[_]+'\n    if re.search(patterns, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n```\n\nThis function uses the `re` module to search for sequences of one or more underscores in the input string. If a match is found, it returns 'Found a match!'; otherwise, it returns 'Not matched!'. If the input is not a string, it raises a `TypeError`.\n", "requirement": "Exception Handling"}
{"task_id": 43, "completion": "Here is a Python function that uses regex to find sequences of lowercase letters joined with an underscore:\n\n```python\nimport re\n\ndef text_match(text):\n    if not text:\n        return 'Not matched!'\n    patterns = '[_]+'\n    if re.search(patterns, text):\n        return 'Matched!'\n    else:\n        return 'Not matched!'\n```\n\nThis function checks if the input string is empty and returns 'Not matched!' if it is. Otherwise, it uses the regex pattern `[_]+` to search for one or more underscores in the text. If a match is found, it returns 'Matched!'; otherwise, it returns 'Not matched!'.\n", "requirement": "Edge Case Handling"}
{"task_id": 43, "completion": "To extend the function to handle sequences of lowercase letters joined by multiple underscores, you can use the `re` module in Python, which provides support for regular expressions. The regular expression pattern `r'\\b[a-z]+(_[a-z]+)*\\b'` will match sequences of lowercase letters joined by one or more underscores.\n\nHere's the updated function:\n\n```python\nimport re\n\ndef text_match(text):\n    patterns = 'r\\b[a-z]+(_[a-z]+)*\\b'\n    if re.search(patterns, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n```\n\nThis function will return 'Found a match!' if the input text contains a sequence of lowercase letters joined by underscores, and 'Not matched!' otherwise.\n", "requirement": "Functionality Extension"}
{"task_id": 43, "completion": "Here is a Python function that meets the requirements:\n\n```python\nimport re\nfrom typing import List, Tuple\n\ndef text_match(text: str) -> str:\n    patterns: List[Tuple[str, str]] = [\n        ('lower_case', r'([a-z]+_)'),\n        ('lower_case_2', r'([a-z]+_[a-z]+)'),\n        ('lower_case_3', r'([a-z]+_[a-z]+_[a-z]+)')\n    ]\n    text_match: str = ' '.join(re.findall(patterns[0][1], text))\n    return text_match\n```\n\nThis function uses regular expressions to find sequences of lowercase letters joined with an underscore. The `patterns` list contains tuples of pattern names and their corresponding regex patterns. The function uses the first pattern in the list (`lower_case`) to find matches in the input text. The matches are joined with a space and returned as the result.\n", "requirement": "Annotation Coverage"}
{"task_id": 43, "completion": "To meet the requirement of a cyclomatic complexity of 1, we can use a simple regex pattern to match sequences of lowercase letters joined with an underscore. Here's a function that accomplishes this:\n\n```python\nimport re\n\ndef text_match(text):\n    patterns = '[_]+'\n    if re.search(patterns, text):\n        return True\n    else:\n        return False\n```\n\nThis function uses a regex pattern `'[_]+'` to find one or more underscores in the input `text`. If a match is found, the function returns `True`; otherwise, it returns `False`. The function has a cyclomatic complexity of 1 because there is only one path through the code.\n", "requirement": "Code Complexity"}
{"task_id": 43, "completion": "Here is a function that meets the requirements:\n\n```python\nimport re\n\ndef text_match(text):\n    patterns = '[_]+'\n    if re.search(patterns, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n```\n\nThis function uses the `re` module to search for sequences of one or more underscores in the input text. If such a sequence is found, it returns 'Found a match!'; otherwise, it returns 'Not matched!'.\n", "requirement": "Code Standard"}
{"task_id": 44, "completion": "def text_match_string(text):\n    if not isinstance(text, str):\n        raise TypeError('Input must be a string.')\n    patterns = ['hackerrank', 'hackerearth']\n    for pattern in patterns:\n        if re.match(pattern, text):\n            return True\n    return False\n", "requirement": "Exception Handling"}
{"task_id": 44, "completion": "def text_match_string(text, pattern):\n    \"\"\"\n    Matches a word at the beginning of a string.\n\n    Parameters:\n    text (str): The input string to be matched.\n    pattern (str): The word pattern to be matched at the beginning of the string.\n\n    Returns:\n    bool: True if the pattern matches at the beginning of the string, False otherwise.\n    \"\"\"\n    if not text or not pattern:\n        return False\n    return text.startswith(pattern)\n", "requirement": "Edge Case Handling"}
{"task_id": 44, "completion": "def text_match_string(text: str) -> str:\n    patterns = ['hack', 'hax']\n    text = text.lower()\n    for pattern in patterns:\n        if pattern in text:\n            return 'found a match!'\n    return 'not found a match!'\n", "requirement": "Annotation Coverage"}
{"task_id": 44, "completion": "def text_match_string(text):\n    patterns = ['python', 'java', 'c#', 'c++']\n    for pattern in patterns:\n        if re.match(pattern, text):\n            return True\n    return False\n", "requirement": "Code Standard"}
{"task_id": 45, "completion": "def get_gcd(arr):\n    if not arr:\n        raise ValueError('Input list cannot be empty.')\n    def gcd(a, b):\n        while b != 0:\n            a, b = b, a % b\n        return a\n\n    num1 = arr[0]\n    num2 = arr[1]\n    result = gcd(num1, num2)\n\n    for i in range(2, len(arr)):\n        result = gcd(result, arr[i])\n\n    return result\n", "requirement": "Exception Handling"}
{"task_id": 45, "completion": "def get_gcd(arr):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    non_zero_elements = [x for x in arr if x != 0]\n    if not non_zero_elements:\n        return 0\n\n    result = non_zero_elements[0]\n    for i in range(1, len(non_zero_elements)):\n        result = gcd(result, non_zero_elements[i])\n\n    return result\n", "requirement": "Functionality Extension"}
{"task_id": 45, "completion": "def get_gcd(numbers: list) -> int:\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    num1 = numbers[0]\n    num2 = numbers[1]\n    result = gcd(num1, num2)\n\n    for i in range(2, len(numbers)):\n        result = gcd(result, numbers[i])\n\n    return result\n", "requirement": "Annotation Coverage"}
{"task_id": 45, "completion": "def get_gcd(arr):\n    from math import gcd\n    result = arr[0]\n    for i in arr[1:]:\n        result = gcd(result, i)\n    return result\n", "requirement": "Code Complexity"}
{"task_id": 45, "completion": "def get_gcd(arr):\n    \"\"\"\n    Find the greatest common divisor (GCD) of the given array elements.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    int: The GCD of the array elements.\n    \"\"\"\n    def gcd(a, b):\n        \"\"\"\n        Helper function to find the GCD of two numbers.\n\n        Parameters:\n        a (int): The first number.\n        b (int): The second number.\n\n        Returns:\n        int: The GCD of a and b.\n        \"\"\"\n        while b:\n            a, b = b, a % b\n        return a\n\n    num1 = arr[0]\n    num2 = arr[1]\n    result = gcd(num1, num2)\n\n    for i in range(2, len(arr)):\n        result = gcd(result, arr[i])\n\n    return result\n", "requirement": "Code Standard"}
{"task_id": 46, "completion": "def test_distinct(numbers):\n    return len(numbers) == len(set(numbers))\n", "requirement": "Input-Output Conditions"}
{"task_id": 46, "completion": "def test_distinct(nums):\n    if not isinstance(nums, list):\n        raise TypeError('Input must be a list.')\n    for num in nums:\n        if not isinstance(num, int):\n            raise TypeError('All elements in the list must be integers.')\n    return len(nums) == len(set(nums))\n", "requirement": "Exception Handling"}
{"task_id": 46, "completion": "def test_distinct(nums):\n    if not nums:\n        return True\n    return len(nums) == len(set(nums))\n", "requirement": "Edge Case Handling"}
{"task_id": 46, "completion": "def test_distinct(nums):\n    return len(nums) == len(set(nums))\n", "requirement": "Functionality Extension"}
{"task_id": 46, "completion": "def test_distinct(numbers: list) -> bool:\n    return len(numbers) == len(set(numbers))\n", "requirement": "Annotation Coverage"}
{"task_id": 46, "completion": "def test_distinct(nums):\n    \"\"\"\n    Determine if all numbers in the list are distinct.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        bool: True if all numbers are distinct, False otherwise.\n    \"\"\"\n    return len(nums) == len(set(nums))\n", "requirement": "Code Standard"}
{"task_id": 47, "completion": "def compute_last_digit(a, b):\n    if a > b:\n        raise ValueError('a should not be greater than b')\n    a %= 10\n    b %= 10\n    if a == 0:\n        return 0\n    if b == 0:\n        return 1\n    if a == 1:\n        return 1\n    if a == 5 or a == 6:\n        return a\n    if a == 2 or a == 3 or a == 7 or a == 8:\n        if b < 4:\n            return a\n        if b < 9:\n            return a * a % 10\n        if b % 4 == 0:\n            return 6\n        if b % 4 == 1:\n            return a\n        if b % 4 == 2:\n            return a * a % 10\n        if b % 4 == 3:\n            return a * a * a % 10\n    return -1\n", "requirement": "Exception Handling"}
{"task_id": 47, "completion": "def compute_last_digit(a, b):\n    if a == b:\n        return 1\n    a %= 10\n    b %= 10\n    if a == 0 or b == 0:\n        return 0\n    if a == 1 or b == 1:\n        return 1\n    if a == 5 or b == 5:\n        return 5\n    if a == 6 or b == 6:\n        return 6\n    if a == 2 or b == 2:\n        return 2\n    if a == 4 or b == 4:\n        return 4\n    if a == 3 or b == 3:\n        return 3\n    if a == 7 or b == 7:\n        return 7\n    if a == 8 or b == 8:\n        return 8\n    return -1\n", "requirement": "Edge Case Handling"}
{"task_id": 47, "completion": "def compute_last_digit(a, b):\n    if a == 0:\n        return 1\n    if b == 0:\n        return 0\n    a %= 10\n    b %= 10\n    if a == 0:\n        return 0\n    if b == 0:\n        return 1\n    if a == 1 or b == 1:\n        return 1\n    if a == 5 or b == 5:\n        return 5\n    if a == 6 or b == 6:\n        return 6\n    if a == 2 or b == 2:\n        return 2\n    if a == 4 or b == 4:\n        return 4\n    if a == 3 or b == 3:\n        return 3\n    if a == 7 or b == 7:\n        return 7\n    if a == 8 or b == 8:\n        return 8\n    if a == 9 or b == 9:\n        return 9\n    return 0\n", "requirement": "Functionality Extension"}
{"task_id": 47, "completion": "def compute_last_digit(a: int, b: int) -> int:\n    \"\"\"\n    Compute the last digit of (factorial(a) / factorial(b))\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n\n    Returns:\n    int: The last digit of (factorial(a) / factorial(b)).\n    \"\"\"\n    if a == 0 or b == 0:\n        return 1\n    a %= 10\n    b %= 10\n    if a < b:\n        return 0\n    if b == 0:\n        return 1\n    if (a - b) < 10:\n        return (a - b)\n    return 0\n", "requirement": "Annotation Coverage"}
{"task_id": 47, "completion": "def compute_last_digit(a, b):\n    \"\"\"\n    Compute the last digit of (factorial(a) % factorial(b))\n    \"\"\"\n    if a == 0:\n        return 1\n    if a < b:\n        return 0\n    if a == b:\n        return a + 1\n    if a > b:\n        return (a + 1) % 10\n", "requirement": "Code Complexity"}
{"task_id": 48, "completion": "def odd_bit_set_number(n):\n    # Create a mask with all odd bits set\n    mask = 0xAAAAAAAA\n    # Use bitwise OR to set all odd bits in n\n    result = n | mask\n    return result\n", "requirement": "Input-Output Conditions"}
{"task_id": 48, "completion": "def odd_bit_set_number(n):\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    x = 0xAAAAAAAA\n    return (n | x)\n", "requirement": "Exception Handling"}
{"task_id": 48, "completion": "def odd_bit_set_number(n):\n    if n == 0:\n        return 1\n    result = 0\n    while n > 0:\n        result |= (n & 1)\n        n >>= 1\n        if n > 0:\n            result |= (n & 1)\n            n >>= 1\n    return result\n", "requirement": "Edge Case Handling"}
{"task_id": 48, "completion": "def odd_bit_set_number(n):\n    if n < 0:\n        n = abs(n)\n    mask = 0xAAAAAAAA\n    return (n | mask)\n\n# Test the function\nprint(odd_bit_set_number(10))  # Output: 14\nprint(odd_bit_set_number(-10))  # Output: 14\n", "requirement": "Functionality Extension"}
{"task_id": 48, "completion": "def odd_bit_set_number(n: int) -> int:\n    \"\"\"\n    Set all odd bits of a given number.\n\n    Parameters:\n    n (int): The input number.\n\n    Returns:\n    int: The number with all odd bits set.\n    \"\"\"\n    # Create a mask with all odd bits set\n    mask = 0xAAAAAAAA\n    # Use bitwise OR to set all odd bits in 'n'\n    return n | mask\n", "requirement": "Annotation Coverage"}
{"task_id": 48, "completion": "def odd_bit_set_number(n):\n    \"\"\"\n    Set all odd bits of a given number.\n\n    Parameters:\n    n (int): The input number.\n\n    Returns:\n    int: The number with all odd bits set.\n    \"\"\"\n    # Create a mask with all odd bits set\n    mask = 0xAAAAAAAA\n    # Use bitwise OR to set the odd bits in the number\n    result = n | mask\n    return result\n", "requirement": "Code Standard"}
{"task_id": 49, "completion": "def specified_element(list_2d, index):\n    if not list_2d:\n        return []\n    return [sublist[index] for sublist in list_2d]\n", "requirement": "Input-Output Conditions"}
{"task_id": 49, "completion": "def specified_element(list1, index):\n    result = []\n    for sublist in list1:\n        try:\n            result.append(sublist[index])\n        except IndexError:\n            raise IndexError('Index out of range for sublist')\n    return result\n", "requirement": "Exception Handling"}
{"task_id": 49, "completion": "def specified_element(list1, index):\n    result = []\n    for sublist in list1:\n        if index < len(sublist):\n            result.append(sublist[index])\n    return result\n", "requirement": "Edge Case Handling"}
{"task_id": 49, "completion": "Here is a Python function that meets the requirements:\n\n```python\ndef specified_element(list_2d, index):\n    if index >= 0:\n        return [sublist[index] for sublist in list_2d]\n    else:\n        return [sublist[-index] for sublist in list_2d]\n```\n\nThis function takes a two-dimensional list and an index as input. If the index is a non-negative integer, it extracts the element at that index from each sublist. If the index is a negative integer, it extracts the element from the end of each sublist.\n\nFor example, if you have a two-dimensional list like this:\n\n```python\nlist_2d = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n```\n\nAnd you want to extract the first element (index 0), you would call the function like this:\n\n```python\nresult = specified_element(list_2d, 0)\nprint(result)  # Output: [1, 4, 7]\n```\n\nAnd if you want to extract the last element (index -1), you would call the function like this:\n\n```python\nresult = specified_element(list_2d, -1)\nprint(result)  # Output: [3, 6, 9]\n```\n", "requirement": "Functionality Extension"}
{"task_id": 49, "completion": "def specified_element(list1, index):\n    \"\"\"\n    Extracts every first or specified element from a given two-dimensional list.\n\n    Parameters:\n    list1 (list): The two-dimensional list from which to extract elements.\n    index (int): The index of the element to extract. If index is 0, the first element of each sublist is returned.\n\n    Returns:\n    list: A list containing the specified elements.\n    \"\"\"\n    result = [sublist[index] for sublist in list1]\n    return result\n", "requirement": "Code Standard"}
{"task_id": 50, "completion": "def min_length_list(list_of_lists):\n    min_length = min(map(len, list_of_lists))\n    shortest_list = min(list_of_lists, key=lambda x: len(x))\n    return (min_length, shortest_list)\n", "requirement": "Input-Output Conditions"}
{"task_id": 50, "completion": "def min_length_list(list_of_lists):\n    if not isinstance(list_of_lists, list) or not all(isinstance(sub_list, list) for sub_list in list_of_lists):\n        raise ValueError('Input must be a list of lists.')\n    return min(list_of_lists, key=lambda x: len(x))\n", "requirement": "Exception Handling"}
{"task_id": 50, "completion": "def min_length_list(lists):\n    if not lists:\n        return None\n    return min(lists, key=lambda x: (len(x), x))\n", "requirement": "Edge Case Handling"}
{"task_id": 50, "completion": "def min_length_list(lists: list[list]) -> tuple[int, list]:\n    return min(enumerate(lists), key=lambda x: len(x[1]))\n", "requirement": "Annotation Coverage"}
{"task_id": 51, "completion": "def check_equilateral(a, b, c):\n    if not all(isinstance(i, int) and i > 0 for i in [a, b, c]):\n        raise ValueError('All inputs must be positive integers.')\n    if a == b == c:\n        return 'The triangle is equilateral.'\n    else:\n        return 'The triangle is not equilateral.'\n", "requirement": "Exception Handling"}
{"task_id": 51, "completion": "def check_equilateral(a, b, c):\n    if a == 0 and b == 0 and c == 0:\n        return False\n    if a == b == c:\n        return True\n    else:\n        return False\n", "requirement": "Edge Case Handling"}
{"task_id": 51, "completion": "Sure, here is a Python function that checks if a triangle is equilateral or isosceles:\n\n```python\ndef check_equilateral(a, b, c):\n    if a == b == c:\n        return 'equilateral'\n    elif a == b or b == c or c == a:\n        return 'isosceles'\n    else:\n        return 'scalene'\n```\n\nThis function takes three arguments, `a`, `b`, and `c`, which represent the lengths of the sides of the triangle. It returns 'equilateral' if all sides are equal, 'isosceles' if at least two sides are equal, and 'scalene' if no sides are equal.\n", "requirement": "Functionality Extension"}
{"task_id": 51, "completion": "def check_equilateral(a: int, b: int, c: int) -> bool:\n    if a == b == c:\n        return True\n    else:\n        return False\n", "requirement": "Annotation Coverage"}
{"task_id": 51, "completion": "def check_equilateral(a, b, c):\n    if a == b == c:\n        return True\n    else:\n        return False\n", "requirement": "Code Complexity"}
{"task_id": 51, "completion": "def check_equilateral(a, b, c):\n    \"\"\"\n    Check if the triangle is equilateral.\n\n    Parameters:\n    a (int): The length of side a.\n    b (int): The length of side b.\n    c (int): The length of side c.\n\n    Returns:\n    str: A message indicating whether the triangle is equilateral or not.\n    \"\"\"\n    if a == b == c:\n        return \"The triangle is equilateral.\"\n    else:\n        return \"The triangle is not equilateral.\"\n", "requirement": "Code Standard"}
{"task_id": 52, "completion": "def parallelogram_area(base, height):\n    if base <= 0 or height <= 0:\n        raise ValueError(\"Base and height must be positive numbers.\")\n    return base * height\n", "requirement": "Input-Output Conditions"}
{"task_id": 52, "completion": "Sure, here is a Python function that calculates the area of a parallelogram and raises a TypeError if the inputs are not numerical:\n\n```python\ndef parallelogram_area(base, height):\n    if not (isinstance(base, (int, float)) and isinstance(height, (int, float))):\n        raise TypeError('Both base and height must be numerical.')\n    return base * height\n```\n\nThis function takes two arguments, `base` and `height`, and returns their product. If either `base` or `height` is not a numerical value (an integer or a float), the function raises a TypeError.\n", "requirement": "Exception Handling"}
{"task_id": 52, "completion": "def parallelogram_area(base, height):\n    if base <= 0 or height <= 0:\n        return 0\n    return base * height\n", "requirement": "Edge Case Handling"}
{"task_id": 52, "completion": "def parallelogram_area(dimensions):\n    areas = []\n    for base, height in dimensions:\n        area = base * height\n        areas.append(area)\n    return areas\n", "requirement": "Functionality Extension"}
{"task_id": 52, "completion": "def parallelogram_area(base: float, height: float) -> float:\n    \"\"\"\n    Calculate the area of a parallelogram.\n\n    Parameters:\n    base (float): The base of the parallelogram.\n    height (float): The height of the parallelogram.\n\n    Returns:\n    float: The area of the parallelogram.\n    \"\"\"\n    return base * height\n", "requirement": "Annotation Coverage"}
{"task_id": 52, "completion": "Certainly! To calculate the area of a parallelogram, you can use the formula `base * height`. Here's a Python function that meets the specified requirements:\n\n```python\ndef parallelogram_area(base, height):\n    \"\"\"Calculate the area of a parallelogram.\"\"\"\n    return base * height\n```\n\nThis function has a cyclomatic complexity of 1, as it is a simple, linear function that performs a single operation.\n", "requirement": "Code Complexity"}
{"task_id": 52, "completion": "def parallelogram_area(base, height):\n    \"\"\"\n    Calculate the area of a parallelogram.\n\n    Parameters:\n    base (float): The base of the parallelogram.\n    height (float): The height of the parallelogram.\n\n    Returns:\n    float: The area of the parallelogram.\n    \"\"\"\n    return base * height\n", "requirement": "Code Standard"}
{"task_id": 53, "completion": "def check_equality(input_string):\n    if not isinstance(input_string, str):\n        raise TypeError('Input must be a string.')\n    if input_string[0] == input_string[-1]:\n        return 'Equal'\n    else:\n        return 'Not Equal'\n", "requirement": "Input-Output Conditions"}
{"task_id": 53, "completion": "def check_equality(input_string):\n    if not isinstance(input_string, str):\n        raise TypeError('Input must be a string')\n    return input_string[0] == input_string[-1]\n", "requirement": "Exception Handling"}
{"task_id": 53, "completion": "def check_equality(str1):\n    if str1 == '':\n        return 'Equal'\n    elif str1[0] == str1[-1]:\n        return 'Equal'\n    else:\n        return 'Not Equal'\n", "requirement": "Edge Case Handling"}
{"task_id": 53, "completion": "def check_equality(str1):\n    if str1[0].lower() == str1[-1].lower():\n        return True\n    else:\n        return False\n", "requirement": "Functionality Extension"}
{"task_id": 53, "completion": "def check_equality(s: str) -> str:\n    if s[0] == s[-1]:\n        return 'Equal'\n    else:\n        return 'Not Equal'\n", "requirement": "Annotation Coverage"}
{"task_id": 53, "completion": "def check_equality(text):\n    return text[0] == text[-1]\n", "requirement": "Code Complexity"}
{"task_id": 53, "completion": "def check_equality(str1):\n    \"\"\"\n    Check if the first and last characters of a given string are equal.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    bool: True if the first and last characters are equal, False otherwise.\n    \"\"\"\n    if str1[0] == str1[-1]:\n        return True\n    else:\n        return False\n", "requirement": "Code Standard"}
{"task_id": 54, "completion": "def counting_sort(arr):\n    if not all(isinstance(x, int) and x >= 0 for x in arr):\n        raise ValueError('Input list must contain only non-negative integers.')\n    \n    max_val = max(arr)\n    count = [0] * (max_val + 1)\n    \n    for num in arr:\n        count[num] += 1\n    \n    sorted_arr = []\n    for i, freq in enumerate(count):\n        sorted_arr.extend([i] * freq)\n    \n    return sorted_arr\n", "requirement": "Input-Output Conditions"}
{"task_id": 54, "completion": "def counting_sort(arr):\n    if not isinstance(arr, list):\n        raise TypeError('Input must be a list.')\n    for i in arr:\n        if not isinstance(i, int):\n            raise TypeError('All elements in the list must be integers.')\n    max_val = max(arr)\n    count = [0] * (max_val + 1)\n    for num in arr:\n        count[num] += 1\n    sorted_arr = []\n    for i, freq in enumerate(count):\n        sorted_arr.extend([i] * freq)\n    return sorted_arr\n", "requirement": "Exception Handling"}
{"task_id": 54, "completion": "def counting_sort(arr):\n    if not arr:\n        return []\n    if len(arr) == 1:\n        return arr\n\n    max_val = max(arr)\n    count = [0] * (max_val + 1)\n    output = [0] * len(arr)\n\n    for num in arr:\n        count[num] += 1\n\n    for i in range(1, len(count)):\n        count[i] += count[i - 1]\n\n    for i in range(len(arr) - 1, -1, -1):\n        output[count[arr[i]] - 1] = arr[i]\n        count[arr[i]] -= 1\n\n    return output\n", "requirement": "Edge Case Handling"}
{"task_id": 54, "completion": "def counting_sort(arr):\n    # Find the maximum and minimum values in the array\n    max_val = max(arr)\n    min_val = min(arr)\n    \n    # Create a count array to store the count of each unique element\n    count = [0] * (max_val - min_val + 1)\n    \n    # Populate the count array based on the frequency of each element\n    for num in arr:\n        count[num - min_val] += 1\n    \n    # Reconstruct the sorted array using the count array\n    sorted_arr = []\n    for i, freq in enumerate(count):\n        sorted_arr.extend([i + min_val] * freq)\n    \n    return sorted_arr\n\n# Example usage:\narr = [4, -2, 2, 8, -3, 3, 1]\nsorted_arr = counting_sort(arr)\nprint(sorted_arr)\n", "requirement": "Functionality Extension"}
{"task_id": 54, "completion": "def counting_sort(arr: list) -> list:\n    max_val = max(arr)\n    count = [0] * (max_val + 1)\n    output = [0] * len(arr)\n\n    for num in arr:\n        count[num] += 1\n\n    for i in range(1, len(count)):\n        count[i] += count[i - 1]\n\n    for i in range(len(arr) - 1, -1, -1):\n        output[count[arr[i]] - 1] = arr[i]\n        count[arr[i]] -= 1\n\n    return output\n", "requirement": "Annotation Coverage"}
{"task_id": 54, "completion": "def counting_sort(arr):\n    \"\"\"\n    Sorts the given array using counting sort.\n\n    Args:\n        arr (list): The array to be sorted.\n\n    Returns:\n        list: The sorted array.\n    \"\"\"\n    max_val = max(arr)\n    count = [0] * (max_val + 1)\n    output = [0] * len(arr)\n\n    for num in arr:\n        count[num] += 1\n\n    for i in range(1, len(count)):\n        count[i] += count[i - 1]\n\n    for num in reversed(arr):\n        output[count[num] - 1] = num\n        count[num] -= 1\n\n    return output\n", "requirement": "Code Standard"}
{"task_id": 55, "completion": "def tn_gp(a, r, n):\n    if n < 1:\n        raise ValueError('Term number must be greater than 0')\n    tn = a * (r ** (n - 1))\n    return tn\n", "requirement": "Exception Handling"}
{"task_id": 55, "completion": "def tn_gp(a, r, n):\n    if r == 0:\n        return 0 if n > 1 else a\n    else:\n        return a * (r ** (n - 1))\n", "requirement": "Edge Case Handling"}
{"task_id": 55, "completion": "def tn_gp(a, r, n):\n    \"\"\"\n    Calculate the n-th term of a geometric series.\n\n    Parameters:\n    a (float): The first term of the geometric series.\n    r (float): The common ratio of the geometric series.\n    n (int): The position of the term in the series.\n\n    Returns:\n    float: The n-th term of the geometric series.\n    \"\"\"\n    if not isinstance(a, (int, float)) or not isinstance(r, (int, float)) or not isinstance(n, int):\n        raise TypeError(\"All arguments must be numbers (int or float).\")\n    if r == 0:\n        raise ValueError(\"The common ratio cannot be zero.\")\n    return a * (r ** (n - 1))\n", "requirement": "Functionality Extension"}
{"task_id": 55, "completion": "def tn_gp(a: int, r: int, n: int) -> int:\n    \"\"\"\n    Calculate the nth term of a geometric series.\n\n    Parameters:\n    a (int): The first term of the geometric series.\n    r (int): The common ratio of the geometric series.\n    n (int): The position of the term in the series.\n\n    Returns:\n    int: The nth term of the geometric series.\n    \"\"\"\n    return a * (r ** (n - 1))\n", "requirement": "Annotation Coverage"}
{"task_id": 55, "completion": "def tn_gp(a, r, n):\n    \"\"\"\n    Calculate the nth term of a geometric series.\n\n    Parameters:\n    a (float): The first term of the geometric series.\n    r (float): The common ratio of the geometric series.\n    n (int): The position of the term in the series.\n\n    Returns:\n    float: The nth term of the geometric series.\n    \"\"\"\n    tn = a * (r ** (n - 1))\n    return tn\n", "requirement": "Code Standard"}
{"task_id": 56, "completion": "def check(n):\n    if not isinstance(n, int):\n        raise TypeError('Input must be an integer.')\n    n_str = str(n)\n    reversed_n = int(n_str[::-1])\n    return n == reversed_n - 1\n", "requirement": "Exception Handling"}
{"task_id": 56, "completion": "def check(n):\n    n = str(n)\n    rev = n[::-1]\n    if int(n) == 2 * int(rev) - 1:\n        return True\n    else:\n        return False\n", "requirement": "Edge Case Handling"}
{"task_id": 56, "completion": "def check(n):\n    if n < 0:\n        n = -n\n        reversed_n = int(str(n)[::-1])\n        return n == 2 * reversed_n - 1\n    else:\n        reversed_n = int(str(n)[::-1])\n        return n == 2 * reversed_n - 1\n", "requirement": "Functionality Extension"}
{"task_id": 56, "completion": "def check(n: int) -> bool:\n    n_str = str(n)\n    reversed_n = int(n_str[::-1])\n    return n == reversed_n - 1\n", "requirement": "Annotation Coverage"}
{"task_id": 56, "completion": "def check(n):\n    return n + 1 == int(str(n)[::-1]) * 2\n", "requirement": "Code Complexity"}
{"task_id": 56, "completion": "def check(n):\n    \"\"\"\n    Check if a given number is one less than twice its reverse.\n\n    Parameters:\n    n (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is one less than twice its reverse, False otherwise.\n    \"\"\"\n    n = str(n)\n    n_rev = n[::-1]\n    return int(n) == 2 * int(n_rev) - 1\n", "requirement": "Code Standard"}
{"task_id": 57, "completion": "def find_max_num(nums, n):\n    nums.sort(reverse=True)\n    max_num = 0\n    for i in range(n):\n        max_num = max_num * 10 + nums[i]\n    return max_num\n", "requirement": "Input-Output Conditions"}
{"task_id": 57, "completion": "def find_max_num(digits, num_digits):\n    if num_digits > len(digits):\n        raise ValueError('Number of digits exceeds the length of the list.')\n    digits.sort(reverse=True)\n    max_num = int(''.join(map(str, digits[:num_digits])))\n    return max_num\n", "requirement": "Exception Handling"}
{"task_id": 57, "completion": "def find_max_num(digits):\n    if not digits:\n        return 0\n    digits.sort(reverse=True)\n    return int(''.join(map(str, digits)))\n", "requirement": "Edge Case Handling"}
{"task_id": 57, "completion": "def find_max_num(nums):\n    nums.sort(reverse=True)\n    return int(''.join(map(str, nums)))\n", "requirement": "Functionality Extension"}
{"task_id": 57, "completion": "def find_max_num(digits: list, n: int) -> int:\n    digits.sort(reverse=True)\n    max_num = 0\n    for i in range(n):\n        max_num = max_num * 10 + digits[i]\n    return max_num\n", "requirement": "Annotation Coverage"}
{"task_id": 57, "completion": "def find_max_num(nums):\n    \"\"\"\n    Find the largest number that can be formed with the given digits.\n\n    Parameters:\n    nums (list): A list of integers representing the digits.\n\n    Returns:\n    int: The largest number that can be formed.\n    \"\"\"\n    nums.sort(reverse=True)\n    return int(''.join(map(str, nums)))\n", "requirement": "Code Standard"}
{"task_id": 58, "completion": "def opposite_signs(x, y):\n    if not isinstance(x, int) or not isinstance(y, int):\n        raise ValueError('Both inputs must be integers.')\n    return (x ^ y) < 0\n", "requirement": "Input-Output Conditions"}
{"task_id": 58, "completion": "def opposite_signs(x, y):\n    if not all(isinstance(i, int) for i in [x, y]):\n        raise TypeError('Both inputs must be integers.')\n    return (x < 0) != (y < 0)\n", "requirement": "Exception Handling"}
{"task_id": 58, "completion": "def opposite_signs(x, y):\n    if (x > 0 and y < 0) or (x < 0 and y > 0):\n        return True\n    else:\n        return False\n", "requirement": "Edge Case Handling"}
{"task_id": 58, "completion": "def opposite_signs(num1, num2):\n    return (num1 < 0) != (num2 < 0)\n\ndef opposite_signs_list(num_pairs):\n    return [opposite_signs(num1, num2) for num1, num2 in num_pairs]\n", "requirement": "Functionality Extension"}
{"task_id": 58, "completion": "def opposite_signs(a: int, b: int) -> bool:\n    return (a ^ b) < 0\n", "requirement": "Annotation Coverage"}
{"task_id": 58, "completion": "def opposite_signs(x, y):\n    return (x ^ y) < 0\n", "requirement": "Code Complexity"}
{"task_id": 58, "completion": "def opposite_signs(num1, num2):\n    \"\"\"\n    Check if the given two integers have opposite signs.\n\n    Args:\n        num1 (int): The first integer.\n        num2 (int): The second integer.\n\n    Returns:\n        bool: True if the signs are opposite, False otherwise.\n    \"\"\"\n    return (num1 < 0) != (num2 < 0)\n", "requirement": "Code Standard"}
{"task_id": 59, "completion": "def is_octagonal(n):\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError('Input must be a positive integer.')\n    return n * (4 * n - 3)\n", "requirement": "Exception Handling"}
{"task_id": 59, "completion": "def is_octagonal(n):\n    if n == 1:\n        return 1\n    else:\n        return n * (5 * n - 3) // 2\n", "requirement": "Edge Case Handling"}
{"task_id": 59, "completion": "def is_octagonal(n):\n    if isinstance(n, list):\n        return [is_octagonal(i) for i in n]\n    else:\n        return n * (4 * n - 3)\n", "requirement": "Functionality Extension"}
{"task_id": 59, "completion": "def is_octagonal(n: int) -> int:\n    \"\"\"\n    Calculate the nth octagonal number.\n\n    Args:\n        n (int): The position of the octagonal number to calculate.\n\n    Returns:\n        int: The nth octagonal number.\n    \"\"\"\n    return n * (4 * n - 3)\n", "requirement": "Annotation Coverage"}
{"task_id": 59, "completion": "def is_octagonal(n):\n    \"\"\"\n    Returns the nth octagonal number.\n\n    Parameters:\n    n (int): The position of the octagonal number in the sequence.\n\n    Returns:\n    int: The nth octagonal number.\n    \"\"\"\n    return n * (4 * n - 3)\n", "requirement": "Code Standard"}
{"task_id": 60, "completion": "def max_len_sub(arr, n):\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n", "requirement": "Input-Output Conditions"}
{"task_id": 60, "completion": "def max_len_sub(arr, k):\n    if not isinstance(arr, list):\n        raise TypeError('The first parameter must be a list.')\n    if not isinstance(k, int):\n        raise TypeError('The second parameter must be an integer.')\n    n = len(arr)\n    dp = [0] * n\n    dp[0] = 1\n    max_len = 1\n    for i in range(1, n):\n        dp[i] = 1\n        for j in range(i):\n            if abs(arr[i] - arr[j]) <= k:\n                dp[i] = max(dp[i], dp[j] + 1)\n        max_len = max(max_len, dp[i])\n    return max_len\n", "requirement": "Exception Handling"}
{"task_id": 60, "completion": "def max_len_sub(arr):\n    if not arr:\n        return 0\n    n = len(arr)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n", "requirement": "Edge Case Handling"}
{"task_id": 60, "completion": "def max_len_sub(arr):\n    n = len(arr)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] - arr[j] >= 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n# Example usage:\narr = [1, 2, 3, 4, 5]\nprint(max_len_sub(arr))  # Output: 5\n", "requirement": "Functionality Extension"}
{"task_id": 60, "completion": "def max_len_sub(arr: list[int], n: int) -> int:\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n", "requirement": "Annotation Coverage"}
{"task_id": 60, "completion": "def max_len_sub(arr):\n    \"\"\"\n    Find the maximum length of the subsequence with difference between\n    adjacent elements for the given array.\n\n    Args:\n        arr (list): A list of integers.\n\n    Returns:\n        int: The maximum length of the subsequence.\n    \"\"\"\n    n = len(arr)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == i - j:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n", "requirement": "Code Standard"}
