{"task_id": 11, "completion": "def remove_occ(input_string, char, all=False):\n    if not input_string or not char:\n        return input_string\n        \n    if all:\n        # Remove all occurrences of the character\n        return input_string.replace(char, '')\n    else:\n        # Find first and last occurrence\n        first_index = input_string.find(char)\n        last_index = input_string.rfind(char)\n        \n        if first_index == -1:  # Character not found\n            return input_string\n            \n        # If only one occurrence, remove it\n        if first_index == last_index:\n            return input_string[:first_index] + input_string[first_index + 1:]\n            \n        # Remove first and last occurrence\n        return (input_string[:first_index] + \n                input_string[first_index + 1:last_index] + \n                input_string[last_index + 1:])\n", "requirement": "Functionality Extension", "result": "passed", "passed": true}
{"task_id": 12, "completion": "def sort_matrix(matrix):\n    # Find the maximum length among all rows\n    max_length = max(len(row) for row in matrix)\n    \n    # Create a list of tuples: (row_sum, original_row)\n    # Pad shorter rows with zeros for sum calculation\n    row_sums = [(sum(row + [0] * (max_length - len(row))), row) for row in matrix]\n    \n    # Sort based on row sums and extract only the rows\n    sorted_matrix = [row for _, row in sorted(row_sums)]\n    \n    return sorted_matrix\n", "requirement": "Functionality Extension", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp25up6cuo.py\", line 10, in <module>\n    assert sort_matrix([[1, 2, 3], [4, 5], [6]]) == [[6], [4, 5], [1, 2, 3]]\nAssertionError", "passed": false}
{"task_id": 13, "completion": "def count_common(word_dict, top_n=None):\n    # Create a dictionary to store word frequencies\n    frequency = {}\n    \n    # Count occurrences of each word\n    for word_list in word_dict.values():\n        for word in word_list:\n            frequency[word] = frequency.get(word, 0) + 1\n    \n    # Sort words by frequency in descending order\n    sorted_words = sorted(frequency.items(), key=lambda x: x[1], reverse=True)\n    \n    # Return all items if top_n is None, otherwise return top N items\n    return sorted_words[:top_n] if top_n else sorted_words\n", "requirement": "Functionality Extension", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpj92t4ecs.py\", line 12, in <module>\n    assert count_common(['apple', 'banana', 'apple', 'orange', 'banana', 'banana'], 2) == [('banana', 3), ('apple', 2)]\n  File \"/tmp/tmpj92t4ecs.py\", line 5, in count_common\n    for word_list in word_dict.values():\nAttributeError: 'list' object has no attribute 'values'", "passed": false}
{"task_id": 14, "completion": "def find_volume(base, height, length):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Args:\n        base: Base of the triangle (float/int or sequence)\n        height: Height of the triangle (float/int or sequence)\n        length: Length of the prism (float/int or sequence)\n    \n    Returns:\n        float: Volume of the triangular prism\n    \"\"\"\n    # Check if input is a sequence (list or tuple)\n    if isinstance(base, (list, tuple)):\n        if len(base) != 3:\n            raise ValueError(\"Sequence must contain exactly 3 elements\")\n        base, height, length = base\n    \n    # Calculate the volume: V = (1/2 * base * height) * length\n    try:\n        volume = 0.5 * float(base) * float(height) * float(length)\n        return volume\n    except (ValueError, TypeError):\n        raise ValueError(\"All inputs must be valid numbers\")\n", "requirement": "Functionality Extension", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpa2pnix22.py\", line 13, in <module>\n    assert find_volume([10, 8, 6]) == 240\nTypeError: find_volume() missing 2 required positional arguments: 'height' and 'length'", "passed": false}
{"task_id": 15, "completion": "def split_lowerstring(text: str, include_upper: bool = False) -> list:\n    if not text:\n        return []\n    \n    result = []\n    current_segment = text[0]\n    \n    for char in text[1:]:\n        if char.islower():\n            # Add current segment to result and start a new one\n            if current_segment:\n                if not include_upper and current_segment.isupper():\n                    # Skip segments that are only uppercase when include_upper is False\n                    pass\n                else:\n                    result.append(current_segment)\n            current_segment = char\n        else:\n            current_segment += char\n    \n    # Add the last segment\n    if current_segment and (include_upper or not current_segment.isupper()):\n        result.append(current_segment)\n    \n    return result\n", "requirement": "Functionality Extension", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpbv5mxir1.py\", line 22, in <module>\n    assert split_lowerstring('AbCd', include_lower=True) == ['Ab', 'Cd']\nTypeError: split_lowerstring() got an unexpected keyword argument 'include_lower'", "passed": false}
{"task_id": 16, "completion": "import re\n\ndef text_lowercase_underscore(text):\n    # Pattern matches one or more sequences of lowercase letters joined by underscores\n    pattern = r'[a-z]+(_[a-z]+)+'\n    \n    if re.search(pattern, text):\n        return \"Found a match!\"\n    return \"No match found\"\n", "requirement": "Functionality Extension", "result": "passed", "passed": true}
{"task_id": 17, "completion": "def square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square, rounding floating-point inputs to nearest integer.\n    \n    Args:\n        side_length (int or float): Length of one side of the square\n        \n    Returns:\n        int: Perimeter of the square\n        \n    Raises:\n        ValueError: If side_length is negative or zero\n    \"\"\"\n    if not isinstance(side_length, (int, float)):\n        raise ValueError(\"Side length must be a number\")\n        \n    if side_length <= 0:\n        raise ValueError(\"Side length must be positive\")\n    \n    # Round the side length to nearest integer\n    rounded_side = round(side_length)\n    \n    # Calculate perimeter (4 * side)\n    return 4 * rounded_side\n", "requirement": "Functionality Extension", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp5m08cljq.py\", line 10, in <module>\n    assert square_perimeter(4.5) == 20\nAssertionError", "passed": false}
{"task_id": 18, "completion": "def remove_dirty_chars(main_string: str, chars_to_remove: str) -> str:\n    \"\"\"\n    Remove characters from main_string that are present in chars_to_remove (case-insensitive).\n    \n    Args:\n        main_string (str): The string to clean\n        chars_to_remove (str): String containing characters to remove\n        \n    Returns:\n        str: Cleaned string with specified characters removed\n    \"\"\"\n    # Convert both strings to lowercase for case-insensitive comparison\n    chars_to_remove_lower = chars_to_remove.lower()\n    \n    # Use list comprehension to keep only characters that aren't in chars_to_remove\n    result = ''.join(char for char in main_string \n                    if char.lower() not in chars_to_remove_lower)\n    \n    return result\n", "requirement": "Functionality Extension", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpzjwu1uee.py\", line 8, in <module>\n    assert remove_dirty_chars('HelloWorld', 'hELLO') == 'World', 'Function should handle case-insensitive character removal.'\nAssertionError: Function should handle case-insensitive character removal.", "passed": false}
{"task_id": 19, "completion": "def test_duplicate(numbers):\n    seen = set()\n    duplicates = set()\n    \n    for num in numbers:\n        if num in seen:\n            duplicates.add(num)\n        else:\n            seen.add(num)\n            \n    return list(duplicates)\n", "requirement": "Functionality Extension", "result": "passed", "passed": true}
{"task_id": 20, "completion": "def is_woodall(num):\n    \"\"\"\n    Check if a number is a Woodall number and optionally return all Woodall numbers up to the input.\n    \n    Args:\n        num (int): Input number to check or upper limit\n    \n    Returns:\n        If num is negative: False\n        If num is positive: List of all Woodall numbers up to num\n        If num is a Woodall number: True\n    \"\"\"\n    if not isinstance(num, int):\n        return False\n    \n    if num < 0:\n        return False\n        \n    # If num is positive, find all Woodall numbers up to num\n    if num > 0:\n        woodall_numbers = []\n        n = 1\n        while True:\n            woodall = n * (2**n) - 1\n            if woodall > num:\n                break\n            woodall_numbers.append(woodall)\n            n += 1\n        return woodall_numbers\n    \n    # Check if num itself is a Woodall number\n    n = 1\n    while True:\n        woodall = n * (2**n) - 1\n        if woodall == num:\n            return True\n        if woodall > num:\n            return False\n        n += 1\n", "requirement": "Functionality Extension", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmptgt_4mce.py\", line 27, in <module>\n    assert is_woodall(15) == [1, 7, 15]\nAssertionError", "passed": false}
{"task_id": 21, "completion": "def multiples_of_num(n: float, m: int) -> list:\n    \"\"\"\n    Find m multiples of number n.\n    \n    Args:\n        n (float): The number to find multiples of\n        m (int): The number of multiples to find\n        \n    Returns:\n        list: A list containing m multiples of n\n    \"\"\"\n    return [n * i for i in range(1, m + 1)]\n", "requirement": "Functionality Extension", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp4llvcfis.py\", line 3, in <module>\n    assert multiples_of_num(3, 2.5) == [2.5, 5.0, 7.5]\n  File \"/tmp/tmp4llvcfis.py\", line 2, in multiples_of_num\n    return [n * i for i in range(1, m + 1)]\nTypeError: 'float' object cannot be interpreted as an integer", "passed": false}
{"task_id": 22, "completion": "def find_first_duplicate(arr):\n    seen = set()\n    all_duplicates = []\n    first_duplicate = None\n    \n    for num in arr:\n        if num in seen:\n            if first_duplicate is None:\n                first_duplicate = num\n            if num not in all_duplicates:\n                all_duplicates.append(num)\n        else:\n            seen.add(num)\n    \n    return first_duplicate, all_duplicates\n", "requirement": "Functionality Extension", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpxpi53p62.py\", line 14, in <module>\n    assert find_first_duplicate([1, 2, 3, 2, 4, 5, 4]) == [2, 4]\nAssertionError", "passed": false}
{"task_id": 23, "completion": "def maximum_sum(list_of_lists):\n    if not list_of_lists:\n        return 0\n    \n    # Use max() with a generator expression to sum each sublist\n    # and find the maximum sum among all sublists\n    max_sum = max(sum(sublist) for sublist in list_of_lists)\n    \n    return max_sum\n", "requirement": "Functionality Extension", "result": "passed", "passed": true}
{"task_id": 24, "completion": "def binary_to_decimal(binary_str):\n    # Validate input is a valid binary string\n    if not all(bit in '01' for bit in binary_str):\n        raise ValueError(\"Input must be a binary number (containing only 0s and 1s)\")\n    \n    # Remove leading zeros but handle case of \"0\"\n    binary_str = binary_str.lstrip('0') or '0'\n    \n    decimal = 0\n    power = 0\n    \n    # Iterate through binary digits from right to left\n    for digit in reversed(binary_str):\n        decimal += int(digit) * (2 ** power)\n        power += 1\n        \n    return decimal\n", "requirement": "Functionality Extension", "result": "passed", "passed": true}
{"task_id": 25, "completion": "def find_product(arr):\n    # Convert array to set to remove duplicates\n    unique_elements = set(arr)\n    \n    # Initialize product as 1\n    product = 1\n    \n    # Multiply all unique elements\n    for num in unique_elements:\n        product *= num\n        \n    return product\n", "requirement": "Functionality Extension", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpjw_mvfqn.py\", line 10, in <module>\n    assert find_product([-1, -2, 3, 3], 4) == 2\nTypeError: find_product() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 26, "completion": "def check_k_elements(tuple_list, k):\n    \"\"\"\n    Check if tuples in the list have k elements and count how many match.\n    \n    Args:\n        tuple_list (list): List of tuples to check\n        k (int): Expected number of elements in each tuple\n    \n    Returns:\n        int: Count of tuples that have exactly k elements\n    \"\"\"\n    if not tuple_list:\n        return 0\n    \n    count = sum(1 for tup in tuple_list if len(tup) == k)\n    return count\n", "requirement": "Functionality Extension", "result": "passed", "passed": true}
{"task_id": 27, "completion": "def remove(string_list, additional_chars=''):\n    \"\"\"\n    Remove all digits and specified additional characters from a list of strings.\n    \n    Args:\n        string_list (list): List of strings to process\n        additional_chars (str): Optional string containing additional characters to remove\n        \n    Returns:\n        list: New list with digits and specified characters removed from each string\n    \"\"\"\n    # Combine digits 0-9 with any additional characters to remove\n    chars_to_remove = '0123456789' + additional_chars\n    \n    # Create a new list using list comprehension\n    # For each string, keep only characters that aren't in chars_to_remove\n    return [''.join(char for char in s if char not in chars_to_remove) \n            for s in string_list]\n", "requirement": "Functionality Extension", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpqb78zme0.py\", line 8, in <module>\n    assert remove_extended(['abcd123', '456defg'], 'abcdef') == ['d', 'g']\nNameError: name 'remove_extended' is not defined", "passed": false}
{"task_id": 28, "completion": "from functools import lru_cache\n\n# Memoized recursive solution\n@lru_cache(maxsize=None)\ndef binomial_coeff_memo(n: int, k: int) -> int:\n    \"\"\"\n    Calculate binomial coefficient C(n,k) using memoization.\n    Args:\n        n: Total number of items\n        k: Number of items to choose\n    Returns:\n        Integer value of the binomial coefficient\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return binomial_coeff_memo(n - 1, k - 1) + binomial_coeff_memo(n - 1, k)\n\n# Iterative solution (more space-efficient)\ndef binomial_coeff(n: int, k: int) -> int:\n    \"\"\"\n    Calculate binomial coefficient C(n,k) using iterative approach.\n    Args:\n        n: Total number of items\n        k: Number of items to choose\n    Returns:\n        Integer value of the binomial coefficient\n    \"\"\"\n    if k > n:\n        return 0\n    if k > n - k:  # Optimize by using the smaller k\n        k = n - k\n    \n    result = 1\n    # Calculate value using the multiplicative formula\n    for i in range(k):\n        result *= (n - i)\n        result //= (i + 1)\n    \n    return result\n", "requirement": "Functionality Extension", "result": "passed", "passed": true}
{"task_id": 29, "completion": "def get_odd_occurrence(arr: list, arr_size: int) -> list:\n    # Create a dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Count occurrences of each element\n    for num in arr:\n        frequency[num] = frequency.get(num, 0) + 1\n    \n    # Find elements with odd frequency\n    odd_elements = [num for num, count in frequency.items() if count % 2 != 0]\n    \n    return odd_elements\n", "requirement": "Functionality Extension", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmphp8ozve0.py\", line 10, in <module>\n    assert get_odd_occurrence([1, 2, 3, 1, 2, 3, 1, 3]) == [1, 3]\nTypeError: get_odd_occurrence() missing 1 required positional argument: 'arr_size'", "passed": false}
{"task_id": 30, "completion": "def count_substring_with_equal_ends(s):\n    # Convert to lowercase to handle case-insensitivity\n    s = ''.join(c for c in s.lower() if c.isalpha())\n    \n    count = 0\n    n = len(s)\n    \n    # Iterate through all possible starting positions\n    for i in range(n):\n        # Iterate through all possible ending positions\n        for j in range(i, n):\n            # Check if characters at start and end positions are same\n            if s[i] == s[j]:\n                count += 1\n    \n    return count\n", "requirement": "Functionality Extension", "result": "passed", "passed": true}
{"task_id": 31, "completion": "from collections import Counter\nimport heapq\n\ndef func(nums, k):\n    # Handle edge cases\n    if not nums or k == 0:\n        return []\n    \n    # Count frequency of each number\n    freq_counter = Counter(nums)\n    \n    # Use heapq to get k most common elements\n    # We use negative frequency because heapq implements min heap\n    # and we want max frequency elements\n    heap = [(-freq, num) for num, freq in freq_counter.items()]\n    heapq.heapify(heap)\n    \n    # Extract k most frequent elements\n    result = []\n    for _ in range(min(k, len(heap))):\n        freq, num = heapq.heappop(heap)\n        result.append(num)\n    \n    return result\n", "requirement": "Functionality Extension", "result": "passed", "passed": true}
{"task_id": 32, "completion": "def max_prime_factors(n, return_all=False):\n    factors = []\n    # Handle 2 separately to optimize for odd numbers\n    while n % 2 == 0:\n        factors.append(2)\n        n = n // 2\n    \n    # Check odd numbers up to sqrt(n)\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n    \n    # If n is still greater than 2, it's prime\n    if n > 2:\n        factors.append(n)\n    \n    return factors if return_all else max(factors)\n", "requirement": "Functionality Extension", "result": "passed", "passed": true}
{"task_id": 33, "completion": "def decimal_to_binary(input_value):\n    # Handle single number\n    if isinstance(input_value, (int, float)):\n        if input_value == 0:\n            return \"0\"\n        \n        # Handle negative numbers\n        is_negative = input_value < 0\n        num = abs(int(input_value))\n        \n        binary = \"\"\n        while num > 0:\n            binary = str(num % 2) + binary\n            num //= 2\n            \n        return f\"-{binary}\" if is_negative else binary\n    \n    # Handle list of numbers\n    elif isinstance(input_value, list):\n        return [decimal_to_binary(num) for num in input_value]\n    \n    else:\n        raise TypeError(\"Input must be a number or list of numbers\")\n", "requirement": "Functionality Extension", "result": "passed", "passed": true}
{"task_id": 34, "completion": "def find_missing(arr):\n    if not arr:  # Handle empty array\n        return []\n    \n    # Create a set of numbers that should exist in the range\n    expected = set(range(arr[0], arr[-1] + 1))\n    \n    # Convert input array to set for O(1) lookup\n    actual = set(arr)\n    \n    # Find missing numbers using set difference\n    missing = sorted(list(expected - actual))\n    \n    return missing\n", "requirement": "Functionality Extension", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp7al88_2h.py\", line 11, in <module>\n    assert find_missing([1,3,6], 3) == [2, 4, 5]\nTypeError: find_missing() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 35, "completion": "def find_rect_num(n):\n    \"\"\"\n    Calculate the nth rectangular number or a list of rectangular numbers.\n    \n    Args:\n        n: Integer or list of integers\n        \n    Returns:\n        Integer or list of integers representing rectangular numbers\n    \"\"\"\n    def calculate_single(x):\n        if not isinstance(x, int) or x < 1:\n            raise ValueError(\"Input must be a positive integer\")\n        return x * (x + 1)\n    \n    # Handle single integer\n    if isinstance(n, int):\n        return calculate_single(n)\n    \n    # Handle list of integers\n    if isinstance(n, (list, tuple)):\n        return [calculate_single(x) for x in n]\n    \n    raise TypeError(\"Input must be an integer or list of integers\")\n", "requirement": "Functionality Extension", "result": "passed", "passed": true}
{"task_id": 36, "completion": "def find_nth_digit(numerator, denominator, n):\n    # Handle negative numbers by working with absolute values\n    is_negative = (numerator < 0) != (denominator < 0)\n    numerator, denominator = abs(numerator), abs(denominator)\n    \n    # Handle special cases\n    if denominator == 0:\n        raise ValueError(\"Denominator cannot be zero\")\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n        \n    # Handle the case where the result is an integer\n    if numerator % denominator == 0:\n        if n > len(str(numerator // denominator)):\n            return 0\n        return int(str(numerator // denominator)[n-1])\n    \n    # Calculate decimal digits using long division\n    quotient = numerator // denominator\n    remainder = numerator % denominator\n    decimal_digits = []\n    remainder_seen = {remainder: 0}\n    \n    # Perform long division until we find a repeating pattern or reach nth digit\n    while remainder and len(decimal_digits) < n:\n        remainder *= 10\n        digit = remainder // denominator\n        decimal_digits.append(digit)\n        remainder = remainder % denominator\n        \n        # Check for repeating decimal\n        if remainder in remainder_seen:\n            # Calculate the length of the repeating part\n            repeat_length = len(decimal_digits) - remainder_seen[remainder]\n            # If n is beyond what we've calculated, we can use the repeating pattern\n            if len(decimal_digits) < n:\n                repeat_start = remainder_seen[remainder]\n                repeat_position = (n - repeat_start - 1) % repeat_length\n                return decimal_digits[repeat_start + repeat_position]\n        remainder_seen[remainder] = len(decimal_digits)\n    \n    # If we've found enough digits, return the nth one\n    if len(decimal_digits) >= n:\n        return decimal_digits[n-1]\n    # If we haven't found a repeating pattern and ran out of digits, return 0\n    return 0\n", "requirement": "Functionality Extension", "result": "passed", "passed": true}
{"task_id": 37, "completion": "def sort_mixed_list(mixed_list, reverse_strings=False):\n    # Separate integers and strings\n    integers = [x for x in mixed_list if isinstance(x, int)]\n    strings = [x for x in mixed_list if isinstance(x, str)]\n    \n    # Sort integers in ascending order\n    integers.sort()\n    \n    # Sort strings based on reverse_strings parameter\n    strings.sort(reverse=reverse_strings)\n    \n    # Combine and return the sorted lists\n    return integers + strings\n", "requirement": "Functionality Extension", "result": "passed", "passed": true}
{"task_id": 38, "completion": "def div_even_odd(numbers):\n    if not numbers:  # Check if list is empty\n        return None\n        \n    first_even = None\n    first_odd = None\n    \n    # Find first even and odd numbers\n    for num in numbers:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    \n    # Check if we found both even and odd numbers\n    if first_even is None or first_odd is None:\n        return None\n    \n    # Avoid division by zero\n    if first_odd == 0:\n        return None\n        \n    return first_even / first_odd\n", "requirement": "Functionality Extension", "result": "passed", "passed": true}
{"task_id": 39, "completion": "from collections import Counter\nfrom heapq import heappush, heappop\nfrom typing import List\n\ndef rearrange_string(s: str) -> List[str]:\n    # Count frequency of each character\n    char_count = Counter(s)\n    \n    # Create a max heap (using negative counts since Python has min heap)\n    heap = []\n    for char, count in char_count.items():\n        heappush(heap, (-count, char))\n    \n    result = []\n    \n    def generate_arrangement() -> str:\n        if not heap:\n            return \"\"\n            \n        arranged = []\n        used_chars = []\n        \n        # Process each character position\n        while heap or used_chars:\n            # If heap is empty but we still have characters to process\n            if not heap:\n                return \"\"\n                \n            # Get most frequent remaining character\n            count, char = heappop(heap)\n            arranged.append(char)\n            \n            # Update count and store for next iteration\n            if count + 1 < 0:\n                used_chars.append((count + 1, char))\n                \n            # Add back characters that were used two positions ago\n            if used_chars:\n                count, char = used_chars.pop(0)\n                heappush(heap, (count, char))\n                \n        return \"\".join(arranged)\n    \n    # Generate first arrangement\n    first_arrangement = generate_arrangement()\n    if not first_arrangement:\n        return []\n    \n    result.append(first_arrangement)\n    \n    # Try to generate more arrangements if possible\n    char_count = Counter(s)\n    def backtrack(current: str, remaining: Counter):\n        if len(current) == len(s):\n            if current not in result and all(current[i] != current[i+1] for i in range(len(current)-1)):\n                result.append(current)\n            return\n            \n        for char in remaining:\n            if remaining[char] > 0 and (not current or current[-1] != char):\n                remaining[char] -= 1\n                backtrack(current + char, remaining)\n                remaining[char] += 1\n    \n    # Generate additional arrangements\n    backtrack(\"\", char_count)\n    \n    return result\n\n# Test the function\ntest_strings = [\"aab\", \"aaab\", \"abc\"]\nfor s in test_strings:\n    print(f\"Input: {s}\")\n    print(f\"Possible arrangements: {rearrange_string(s)}\\n\")\n", "requirement": "Functionality Extension", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpnlrqvit7.py\", line 58, in <module>\n    assert set(rearange_string('aabb')) == {'abab', 'baba'}\nNameError: name 'rearange_string' is not defined", "passed": false}
{"task_id": 40, "completion": "from collections import Counter\nfrom typing import List\n\ndef freq_element(nested_list: List) -> dict:\n    # Flatten the nested list and count integers\n    def flatten(lst):\n        flat_list = []\n        for item in lst:\n            if isinstance(item, (list, tuple)):\n                flat_list.extend(flatten(item))\n            elif isinstance(item, int):\n                flat_list.append(item)\n        return flat_list\n    \n    # Flatten the nested list and count frequencies using Counter\n    flattened = flatten(nested_list)\n    return dict(Counter(flattened))\n", "requirement": "Functionality Extension", "result": "passed", "passed": true}
{"task_id": 41, "completion": "def filter_evennumbers(numbers):\n    # First filter out non-integer values, then filter even numbers\n    return list(filter(lambda x: x % 2 == 0, \n                      filter(lambda x: isinstance(x, int), numbers)))\n", "requirement": "Functionality Extension", "result": "passed", "passed": true}
{"task_id": 42, "completion": "def find_sum(arr):\n    # Create a dictionary to store element frequencies\n    freq = {}\n    \n    # Count frequency of each element\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Calculate sum of repeated elements\n    repeated_sum = sum(num for num, count in freq.items() if count > 1)\n    \n    return repeated_sum\n", "requirement": "Functionality Extension", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp3iv31y7u.py\", line 10, in <module>\n    assert find_sum([-1, -2, -3, -1, -1], 5) == -2\nTypeError: find_sum() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 43, "completion": "import re\n\ndef text_match(text):\n    # Pattern matches lowercase letters joined by one or more underscores\n    pattern = r'[a-z]+(?:_+[a-z]+)*'\n    \n    # Search for matches in the text\n    if re.search(pattern, text):\n        return True\n    return False\n", "requirement": "Functionality Extension", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpb2stqtd8.py\", line 9, in <module>\n    assert text_match('abc_def_ghi') == 'Found a match!'\nAssertionError", "passed": false}
{"task_id": 45, "completion": "from math import gcd\nfrom functools import reduce\n\ndef get_gcd(numbers):\n    # Filter out zeros from the list\n    non_zero_nums = [num for num in numbers if num != 0]\n    \n    # Handle edge cases\n    if not non_zero_nums:  # If all elements were zero\n        return 0\n    if len(non_zero_nums) == 1:  # If only one non-zero number\n        return abs(non_zero_nums[0])\n    \n    # Calculate GCD of all non-zero numbers using reduce and math.gcd\n    return reduce(gcd, map(abs, non_zero_nums))\n", "requirement": "Functionality Extension", "result": "passed", "passed": true}
{"task_id": 46, "completion": "def test_distinct(numbers):\n    \"\"\"\n    Check if all numbers in the given list are distinct/unique.\n    \n    Args:\n        numbers: List of numbers (integers or floats)\n    Returns:\n        bool: True if all numbers are distinct, False otherwise\n    \"\"\"\n    # Handle empty list or single element\n    if len(numbers) <= 1:\n        return True\n    \n    # For floating point comparison, we'll use a set with rounded numbers\n    # to handle potential floating point precision issues\n    rounded_numbers = [round(num, 10) for num in numbers]\n    \n    # Compare length of original list with length of set\n    # If they're equal, all numbers are distinct\n    return len(rounded_numbers) == len(set(rounded_numbers))\n", "requirement": "Functionality Extension", "result": "passed", "passed": true}
{"task_id": 47, "completion": "def compute_last_digit(a, b):\n    # Handle special cases with 0\n    if a == 0 and b == 0:\n        return 1\n    if b < a:\n        return 0\n    \n    # Initialize result as 1\n    result = 1\n    \n    # Only need to multiply numbers from (a+1) to b\n    # Since we only need last digit, we can take modulo 10 at each step\n    for i in range(a + 1, b + 1):\n        result = (result * (i % 10)) % 10\n        \n        # If result becomes 0, all subsequent multiplications will give 0\n        if result == 0:\n            return 0\n            \n    return result\n", "requirement": "Functionality Extension", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpupkbsfnm.py\", line 17, in <module>\n    assert compute_last_digit(0, 5) == 1\nAssertionError", "passed": false}
{"task_id": 48, "completion": "def odd_bit_set_number(n):\n    # Handle negative numbers by taking absolute value\n    num = abs(n)\n    \n    # Create a mask with all odd bits set (1,3,5,...)\n    # In binary: ...0101 0101\n    mask = 0xAAAAAAAA\n    \n    # Set all odd bits using OR operation\n    result = num | mask\n    \n    # Preserve the original sign\n    return -result if n < 0 else result\n", "requirement": "Functionality Extension", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp5c_lx27h.py\", line 11, in <module>\n    assert odd_bit_set_number(-10) == 15\nAssertionError", "passed": false}
{"task_id": 49, "completion": "def specified_element(matrix, index=0):\n    \"\"\"\n    Extract elements at the specified index from each sublist in the matrix.\n    \n    Args:\n        matrix (list): A 2D list containing sublists\n        index (int): The index of elements to extract (default=0)\n    \n    Returns:\n        list: A list containing elements at the specified index from each sublist\n    \"\"\"\n    return [sublist[index] for sublist in matrix if len(sublist) > abs(index)]\n", "requirement": "Functionality Extension", "result": "passed", "passed": true}
{"task_id": 51, "completion": "def check_equilateral(side1, side2, side3):\n    # Check if all sides are equal (equilateral)\n    if side1 == side2 == side3:\n        return \"equilateral\"\n    # Check if any two sides are equal (isosceles)\n    elif side1 == side2 or side2 == side3 or side1 == side3:\n        return \"isosceles\"\n    else:\n        return \"scalene\"\n\n# Example usage:\nprint(check_equilateral(5, 5, 5))  # Output: equilateral\nprint(check_equilateral(5, 5, 6))  # Output: isosceles\nprint(check_equilateral(3, 4, 5))  # Output: scalene\n", "requirement": "Functionality Extension", "result": "passed", "passed": true}
{"task_id": 52, "completion": "def parallelogram_area(base, height):\n    \"\"\"\n    Calculate the area of a parallelogram(s)\n    \n    Args:\n        base: float/int or list of tuples containing (base, height)\n        height: float/int or None if base is a list of tuples\n    \n    Returns:\n        float/int or list of areas depending on input type\n    \"\"\"\n    # Check if input is a list of tuples\n    if isinstance(base, list):\n        return [parallelogram_area(b, h) for b, h in base]\n    \n    # Calculate single parallelogram area\n    return base * height\n", "requirement": "Functionality Extension", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp6_bs8rdh.py\", line 7, in <module>\n    assert parallelogram_area_list([(10, 20), (15, 20), (8, 9)]) == [200, 300, 72]\nNameError: name 'parallelogram_area_list' is not defined", "passed": false}
{"task_id": 53, "completion": "def check_equality(text: str) -> bool:\n    # Check if string is empty or has less than 2 characters\n    if not text or len(text) < 2:\n        return False\n    \n    # Compare first and last characters (case-insensitive)\n    return text[0].lower() == text[-1].lower()\n", "requirement": "Functionality Extension", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpdepht5kf.py\", line 7, in <module>\n    assert check_equality('Abca') == 'Equal'\nAssertionError", "passed": false}
{"task_id": 54, "completion": "def counting_sort(arr):\n    if not arr:\n        return arr\n    \n    # Find the range of input array\n    max_val = max(arr)\n    min_val = min(arr)\n    range_of_elements = max_val - min_val + 1\n    \n    # Create a counting array to store count of each unique element\n    count = [0] * range_of_elements\n    \n    # Store count of each element\n    for i in arr:\n        count[i - min_val] += 1\n    \n    # Modify count array to store actual position of each element\n    for i in range(1, len(count)):\n        count[i] += count[i - 1]\n    \n    # Create output array\n    output = [0] * len(arr)\n    \n    # Build the output array\n    for i in range(len(arr) - 1, -1, -1):\n        output[count[arr[i] - min_val] - 1] = arr[i]\n        count[arr[i] - min_val] -= 1\n    \n    # Copy the output array to arr\n    for i in range(len(arr)):\n        arr[i] = output[i]\n    \n    return arr\n", "requirement": "Functionality Extension", "result": "passed", "passed": true}
{"task_id": 55, "completion": "def tn_gp(a1: float, r: float, n: int) -> float:\n    \"\"\"\n    Calculate the nth term of a geometric progression.\n    \n    Args:\n        a1 (float): First term of the geometric progression\n        r (float): Common ratio\n        n (int): Position of the term to find (n >= 1)\n        \n    Returns:\n        float: The nth term of the geometric progression\n        \n    Raises:\n        ValueError: If n is less than 1\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Term position (n) must be greater than or equal to 1\")\n    \n    # Formula for nth term: a\u208d\u2099\u208e = a\u2081 * r^(n-1)\n    return a1 * (r ** (n - 1))\n", "requirement": "Functionality Extension", "result": "passed", "passed": true}
{"task_id": 56, "completion": "def check(num):\n    # Handle negative numbers\n    is_negative = num < 0\n    # Convert to positive for processing\n    abs_num = abs(num)\n    \n    # Convert number to string, reverse it, then back to integer\n    reversed_num = int(str(abs_num)[::-1])\n    \n    # Apply negative sign if original number was negative\n    if is_negative:\n        reversed_num = -reversed_num\n    \n    # Check if number is one less than twice its reverse\n    return num == (2 * reversed_num - 1)\n", "requirement": "Functionality Extension", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpbj6xq27a.py\", line 14, in <module>\n    assert check(-37) == True\nAssertionError", "passed": false}
{"task_id": 57, "completion": "def find_max_num(digits):\n    # Convert all digits to strings for easier comparison and sorting\n    str_digits = [str(d) for d in digits]\n    \n    # Custom comparison function for sorting\n    def compare(a, b):\n        if a + b > b + a:\n            return -1\n        return 1\n    \n    # Sort digits using the custom comparison\n    from functools import cmp_to_key\n    str_digits.sort(key=cmp_to_key(compare))\n    \n    # Join the sorted digits and convert to integer\n    result = ''.join(str_digits)\n    return int(result)\n", "requirement": "Functionality Extension", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpoefv2xg7.py\", line 15, in <module>\n    assert find_max_num([1, 1, 2, 2], 4) == 2211\nTypeError: find_max_num() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 58, "completion": "def opposite_signs(a: int, b: int) -> bool:\n    \"\"\"\n    Check if two integers have opposite signs.\n    \n    Args:\n        a (int): First integer\n        b (int): Second integer\n    \n    Returns:\n        bool: True if numbers have opposite signs, False otherwise\n    \"\"\"\n    return (a * b) < 0\n\ndef check_pairs(pairs: list[tuple[int, int]]) -> list[bool]:\n    \"\"\"\n    Check multiple pairs of integers for opposite signs.\n    \n    Args:\n        pairs (list[tuple[int, int]]): List of integer pairs\n    \n    Returns:\n        list[bool]: List of boolean values indicating opposite signs for each pair\n    \"\"\"\n    return [opposite_signs(a, b) for a, b in pairs]\n", "requirement": "Functionality Extension", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp4fecywy_.py\", line 5, in <module>\n    assert opposite_signs_list([(1, -2), (3, 2), (-10, -10)]) == [True, False, False]\nNameError: name 'opposite_signs_list' is not defined", "passed": false}
{"task_id": 59, "completion": "def is_octagonal(n):\n    \"\"\"\n    Calculate octagonal numbers.\n    \n    Args:\n        n: Can be either an integer or a list\n           - If integer: returns the nth octagonal number\n           - If list: returns a list of first n octagonal numbers\n    \n    Returns:\n        Integer or list of integers depending on input\n    \"\"\"\n    if isinstance(n, list):\n        return [i * (3 * i - 2) for i in range(1, n[0] + 1)]\n    return n * (3 * n - 2)\n", "requirement": "Functionality Extension", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpa_q6ka3e.py\", line 5, in <module>\n    assert is_octagonal([1, 2, 3]) == [1, 8, 21]\nAssertionError", "passed": false}
{"task_id": 60, "completion": "def max_len_sub(arr):\n    if not arr or len(arr) < 2:\n        return len(arr)\n    \n    max_length = 2  # Minimum subsequence length with difference\n    current_length = 2\n    current_diff = arr[1] - arr[0]\n    \n    for i in range(2, len(arr)):\n        # Check if current difference matches the previous difference\n        if arr[i] - arr[i-1] == current_diff:\n            current_length += 1\n        else:\n            # Reset current length and update difference\n            current_length = 2\n            current_diff = arr[i] - arr[i-1]\n        \n        max_length = max(max_length, current_length)\n    \n    return max_length\n\n# Test cases\ntest_cases = [\n    [1, 2, 3, 4, 5],          # Positive difference\n    [5, 4, 3, 2, 1],          # Negative difference\n    [1, 3, 5, 7, 9],          # Constant difference\n    [1, -1, -3, -5, -7],      # Negative numbers\n    [1, 1, 1, 1],             # Zero difference\n    [1, 3, 2, 4, 5],          # Mixed differences\n    []                         # Empty array\n]\n\nfor arr in test_cases:\n    print(f\"Array: {arr}\")\n    print(f\"Maximum length subsequence: {max_len_sub(arr)}\\n\")\n", "requirement": "Functionality Extension", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp23ct5835.py\", line 30, in <module>\n    assert max_len_sub([10, 7, 4, 1, -2], -3) == 5\nTypeError: max_len_sub() takes 1 positional argument but 2 were given", "passed": false}
