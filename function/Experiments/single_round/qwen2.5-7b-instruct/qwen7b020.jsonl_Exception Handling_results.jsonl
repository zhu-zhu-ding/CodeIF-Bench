{"task_id": 11, "completion": "def remove_occ(string, char):\n    # Check if the second parameter is a single character\n    if len(char) != 1:\n        raise ValueError('Second parameter must be a single character.')\n\n    # Find the indices of the first and last occurrences of the character\n    first_index = string.find(char)\n    last_index = string.rfind(char)\n\n    # If the character is not found in the string, return the original string\n    if first_index == -1 or last_index == -1:\n        return string\n\n    # Remove the first and last occurrences of the character\n    new_string = string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]\n\n    return new_string\n\n# Example usage:\ntry:\n    result = remove_occ(\"hello world\", \"o\")\n    print(result)  # Output: \"hell wrld\"\nexcept ValueError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "passed", "passed": true}
{"task_id": 12, "completion": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order based on the sum of its rows.\n    \n    Parameters:\n    matrix (list of lists): The matrix to be sorted.\n    \n    Returns:\n    list of lists: The sorted matrix.\n    \n    Raises:\n    TypeError: If the input is not a list of lists or contains non-integer elements.\n    \"\"\"\n    \n    # Check if the input is a list of lists\n    if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix):\n        raise TypeError(\"Input must be a list of lists.\")\n    \n    # Check if each element in the matrix is an integer\n    for row in matrix:\n        if not all(isinstance(element, int) for element in row):\n            raise TypeError(\"All elements in the matrix must be integers.\")\n    \n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=sum)\n\n# Example usage:\nmatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [10, 1, 1]\n]\n\ntry:\n    sorted_matrix = sort_matrix(matrix)\n    print(sorted_matrix)\nexcept TypeError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "passed", "passed": true}
{"task_id": 13, "completion": "from collections import Counter\nimport itertools\n\ndef count_common(words):\n    # Check if the input is a list of strings\n    if not isinstance(words, list) or not all(isinstance(word, str) for word in words):\n        raise TypeError(\"Input must be a list of strings\")\n    \n    # Flatten the list of strings into a single string (if it contains nested lists)\n    # This step is optional and depends on how the input data is structured\n    if any(isinstance(word, list) for word in words):\n        words = list(itertools.chain.from_iterable(words))\n    \n    # Count the occurrences of each word\n    word_counts = Counter(words)\n    \n    # Find the most common words\n    most_common_words = word_counts.most_common()\n    \n    return most_common_words\n\n# Example usage:\nwords_list = [\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"banana\"]\nprint(count_common(words_list))  # Output: [('banana', 3), ('apple', 2), ('orange', 1)]\n\nnested_words_list = [[\"apple\", \"banana\"], [\"banana\", \"orange\"], [\"apple\"]]\nprint(count_common(nested_words_list))  # Output: [('banana', 2), ('apple', 2), ('orange', 1)]\n", "requirement": "Exception Handling", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpvt3dy6l9.py\", line 20, in <module>\n    print(count_common(nested_words_list))  # Output: [('banana', 2), ('apple', 2), ('orange', 1)]\n  File \"/tmp/tmpvt3dy6l9.py\", line 6, in count_common\n    raise TypeError(\"Input must be a list of strings\")\nTypeError: Input must be a list of strings", "passed": false}
{"task_id": 14, "completion": "def find_volume(base_length, base_width, height):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n\n    Parameters:\n    base_length (float): The length of the base triangle.\n    base_width (float): The width of the base triangle.\n    height (float): The height of the triangular prism.\n\n    Returns:\n    float: The volume of the triangular prism.\n\n    Raises:\n    ValueError: If any of the inputs are non-positive or non-numeric.\n    \"\"\"\n    # Check if all inputs are positive numbers\n    if not all(isinstance(x, (int, float)) and x > 0 for x in [base_length, base_width, height]):\n        raise ValueError('All dimensions must be positive numbers.')\n\n    # Calculate the area of the triangular base\n    base_area = 0.5 * base_length * base_width\n\n    # Calculate the volume of the triangular prism\n    volume = base_area * height\n\n    return volume\n\n# Example usage:\ntry:\n    volume = find_volume(3, 4, 5)\n    print(f\"The volume of the triangular prism is: {volume}\")\nexcept ValueError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "passed", "passed": true}
{"task_id": 15, "completion": "def split_lowerstring(input_string):\n    \"\"\"\n    Splits a string at lowercase letters.\n    \n    Parameters:\n    input_string (str): The string to be split.\n    \n    Returns:\n    list: A list of substrings split at lowercase letters.\n    \n    Raises:\n    TypeError: If the input is not a string.\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Split the string at lowercase letters\n    result = []\n    current_substring = \"\"\n    for char in input_string:\n        if char.islower():\n            if current_substring:\n                result.append(current_substring)\n                current_substring = \"\"\n        current_substring += char\n    \n    if current_substring:\n        result.append(current_substring)\n    \n    return result\n\n# Example usage:\nprint(split_lowerstring(\"HelloWorld\"))\nprint(split_lowerstring(\"SplitThisStringAtLowercaseLetters\"))\nprint(split_lowerstring(\"NO_LOWERCASE_LETTERS\"))\n", "requirement": "Exception Handling", "result": "failed: File \"/tmp/tmpnxtw04ey.py\", line 23\n    try: split_lowerstring(123); assert False, 'Expected TypeError' except TypeError: pass\n                                                                    ^\nSyntaxError: invalid syntax", "passed": false}
{"task_id": 16, "completion": "import re\n\ndef text_lowercase_underscore(input_text):\n    \"\"\"\n    This function takes a string as input and returns True if it contains sequences of lowercase letters joined with an underscore.\n    It raises a TypeError if the input is not a string.\n\n    :param input_text: The input text to be checked.\n    :return: True if the input contains sequences of lowercase letters joined with an underscore, False otherwise.\n    \"\"\"\n    if not isinstance(input_text, str):\n        raise TypeError(\"Input must be a string\")\n\n    # Regular expression to match sequences of lowercase letters joined with an underscore\n    pattern = r'\\b[a-z]+_[a-z]+\\b'\n\n    return bool(re.search(pattern, input_text))\n\n# Example usage:\ntry:\n    print(text_lowercase_underscore(\"hello_world\"))  # Should return True\n    print(text_lowercase_underscore(\"Hello_World\"))  # Should raise TypeError\n    print(text_lowercase_underscore(\"hello_world_123\"))  # Should return False\n    print(text_lowercase_underscore(12345))  # Should raise TypeError\nexcept TypeError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpxj1pholc.py\", line 16, in <module>\n    assert text_lowercase_underscore(\"aab_cbbbc\")==('Found a match!')\nAssertionError", "passed": false}
{"task_id": 17, "completion": "def square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square.\n\n    Parameters:\n    side_length (float): The length of one side of the square.\n\n    Returns:\n    float: The perimeter of the square.\n\n    Raises:\n    ValueError: If the side_length is negative.\n    \"\"\"\n    if side_length < 0:\n        raise ValueError(\"Side length cannot be negative.\")\n    \n    return 4 * side_length\n\n# Example usage:\ntry:\n    print(square_perimeter(5))  # Expected output: 20\n    print(square_perimeter(-3)) # This will raise a ValueError\nexcept ValueError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "passed", "passed": true}
{"task_id": 18, "completion": "def remove_dirty_chars(str1, str2):\n    # Check if both inputs are strings\n    if not isinstance(str1, str) or not isinstance(str2, str):\n        raise TypeError(\"Both inputs must be strings.\")\n    \n    # Create a set of characters to be removed from str1\n    chars_to_remove = set(str2)\n    \n    # Use a generator expression to filter out unwanted characters\n    cleaned_str1 = ''.join(char for char in str1 if char not in chars_to_remove)\n    \n    return cleaned_str1\n\n# Example usage:\nresult = remove_dirty_chars(\"hello world\", \"ld\")\nprint(result)  # Output: heo wor\n", "requirement": "Exception Handling", "result": "passed", "passed": true}
{"task_id": 19, "completion": "def test_duplicate(arr):\n    # Check if the input is a list\n    if not isinstance(arr, list):\n        raise ValueError('Input must be a list')\n    \n    # Check if all elements in the list are integers\n    if not all(isinstance(x, int) for x in arr):\n        raise ValueError('All elements in the list must be integers')\n    \n    # Use a set to find duplicates\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    \n    return False\n\n# Example usage:\ntry:\n    print(test_duplicate([1, 2, 3, 4, 5]))  # Should return False\n    print(test_duplicate([1, 2, 3, 3, 5]))  # Should return True\n    print(test_duplicate([1, 'a', 3, 4]))   # Should raise ValueError\nexcept ValueError as e:\n    print(e)\n\ntry:\n    print(test_duplicate('not a list'))     # Should raise ValueError\nexcept ValueError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp0arhmxf7.py\", line 30, in <module>\n    test_duplicate(None)\n  File \"/tmp/tmp0arhmxf7.py\", line 4, in test_duplicate\n    raise ValueError('Input must be a list')\nValueError: Input must be a list", "passed": false}
{"task_id": 20, "completion": "def is_woodall(number):\n    # Check if the input is an integer\n    if not isinstance(number, int):\n        raise TypeError(\"Input must be an integer\")\n    \n    # Function to generate Woodall numbers\n    def generate_woodall(n):\n        return n * (2 ** n) - 1\n    \n    # Iterate over a reasonable range to find if the number is a Woodall number\n    for n in range(1, 1000):  # You can adjust the upper limit as needed\n        woodall_number = generate_woodall(n)\n        if woodall_number == number:\n            return True\n        elif woodall_number > number:\n            break  # No need to check further if the Woodall number exceeds the input number\n    \n    return False\n\n# Example usage:\nprint(is_woodall(7))  # True, because 7 = 1 * 2^3 - 1\nprint(is_woodall(23)) # False, 23 is not a Woodall number\n", "requirement": "Exception Handling", "result": "passed", "passed": true}
{"task_id": 21, "completion": "def multiples_of_num(m, n):\n    \"\"\"\n    Returns a list of m multiples of n.\n    \n    Parameters:\n    m (int): The number of multiples to return.\n    n (int): The base number whose multiples are to be found.\n    \n    Returns:\n    list: A list containing the first m multiples of n.\n    \n    Raises:\n    ValueError: If either m or n is negative.\n    \"\"\"\n    if m < 0 or n < 0:\n        raise ValueError(\"Both m and n must be non-negative integers.\")\n    \n    return [i * n for i in range(1, m + 1)]\n\n# Example usage:\ntry:\n    print(multiples_of_num(5, 3))  # Output: [3, 6, 9, 12, 15]\n    print(multiples_of_num(4, -2)) # This will raise a ValueError\nexcept ValueError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "passed", "passed": true}
{"task_id": 22, "completion": "def find_first_duplicate(arr):\n    \"\"\"\n    Finds the first duplicate element in a given list of integers.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    int: The first duplicate integer found in the list.\n    \n    Raises:\n    TypeError: If the input is not a list or contains non-integer elements.\n    \"\"\"\n    # Check if the input is a list\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    # Check if all elements in the list are integers\n    if not all(isinstance(x, int) for x in arr):\n        raise TypeError(\"All elements in the list must be integers.\")\n    \n    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    \n    # If no duplicates are found, return None\n    return None\n\n# Example usage:\ntry:\n    print(find_first_duplicate([1, 2, 3, 4, 5, 6, 2]))  # Output: 2\n    print(find_first_duplicate([10, 20, 30, 40]))       # Output: None\n    print(find_first_duplicate(\"not a list\"))           # Raises TypeError\n    print(find_first_duplicate([1, 2, 3, \"four\"]))      # Raises TypeError\nexcept TypeError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpkq7z5hdm.py\", line 24, in <module>\n    assert find_first_duplicate([1, 2, 3, 4])==-1\nAssertionError", "passed": false}
{"task_id": 23, "completion": "def maximum_sum(lst_of_lsts):\n    # Check if the input is a list\n    if not isinstance(lst_of_lsts, list):\n        raise TypeError(\"Input must be a list of lists.\")\n    \n    max_sum = None\n    \n    for sublist in lst_of_lsts:\n        # Check if the element is a list\n        if not isinstance(sublist, list):\n            raise TypeError(\"Each element of the input must be a list.\")\n        \n        # Check if all elements in the sublist are integers\n        if not all(isinstance(x, int) for x in sublist):\n            raise TypeError(\"All elements in each sublist must be integers.\")\n        \n        # Calculate the sum of the current sublist\n        current_sum = sum(sublist)\n        \n        # Update max_sum if this is the first iteration or if current_sum is greater than max_sum\n        if max_sum is None or current_sum > max_sum:\n            max_sum = current_sum\n    \n    return max_sum\n\n# Example usage:\ntry:\n    print(maximum_sum([[1, 2, 3], [4, 5, 6], [10, 11, 12]]))  # Output: 33\n    print(maximum_sum([[], [1, 2, 3], [4, 5]]))                # Output: 12\n    print(maximum_sum([[1, \"a\", 3], [4, 5, 6]]))               # Raises TypeError\nexcept TypeError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "failed: File \"/tmp/tmp1bfpowxg.py\", line 29\n    try: maximum_sum([[1, 2], [3, 'a']]); assert False, 'Expected TypeError' except TypeError: pass\n                                                                             ^\nSyntaxError: invalid syntax", "passed": false}
{"task_id": 24, "completion": "def binary_to_decimal(binary_str):\n    # Check if the input is a valid binary string\n    if not all(char in '01' for char in binary_str):\n        raise ValueError(\"Invalid binary number\")\n\n    # Convert binary string to decimal\n    decimal = int(binary_str, 2)\n    return decimal\n\n# Example usage:\ntry:\n    print(binary_to_decimal(\"1011\"))  # Should print 11\n    print(binary_to_decimal(\"1102\"))  # Should raise ValueError\nexcept ValueError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "failed: File \"/tmp/tmpql7e6m70.py\", line 17\n    try: binary_to_decimal('102'); assert False, 'Expected ValueError' except ValueError as e: assert str(e) == 'Invalid binary number'\n                                                                       ^\nSyntaxError: invalid syntax", "passed": false}
{"task_id": 25, "completion": "def find_product(arr):\n    # Check if the input is a list\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list\")\n    \n    # Check if all elements in the list are integers\n    if not all(isinstance(x, int) for x in arr):\n        raise TypeError(\"All elements in the list must be integers\")\n    \n    # Create a dictionary to count occurrences of each element\n    element_count = {}\n    for num in arr:\n        if num in element_count:\n            element_count[num] += 1\n        else:\n            element_count[num] = 1\n    \n    # Calculate the product of non-repeated elements\n    product = 1\n    for num, count in element_count.items():\n        if count == 1:\n            product *= num\n    \n    return product\n\n# Example usage:\ntry:\n    print(find_product([2, 3, 4, 5, 2]))  # Output should be 60 (3 * 4 * 5)\n    print(find_product([1, 1, 2, 3, 4]))  # Output should be 24 (2 * 3 * 4)\n    print(find_product([10]))             # Output should be 10\n    print(find_product([1, \"a\", 3]))      # Should raise TypeError\nexcept TypeError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpjszdn28m.py\", line 29, in <module>\n    assert find_product([1,1,2,3],4) == 6\nTypeError: find_product() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 26, "completion": "def check_k_elements(tuples_list, k):\n    # Check if k is an integer\n    if not isinstance(k, int):\n        raise TypeError(\"The value of k must be an integer.\")\n    \n    # Check if the input is a list of tuples\n    if not isinstance(tuples_list, list) or not all(isinstance(item, tuple) for item in tuples_list):\n        raise TypeError(\"The input must be a list of tuples.\")\n    \n    # Check if each tuple has exactly k elements\n    for item in tuples_list:\n        if len(item) != k:\n            return False\n    \n    return True\n\n# Example usage:\ntry:\n    result = check_k_elements([(1, 2), (3, 4), (5, 6)], 2)\n    print(\"All tuples have exactly 2 elements:\", result)\n\n    result = check_k_elements([(1, 2), (3, 4, 5), (5, 6)], 2)\n    print(\"All tuples have exactly 2 elements:\", result)\nexcept TypeError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmppp0_wi_l.py\", line 21, in <module>\n    assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == True\nAssertionError", "passed": false}
{"task_id": 27, "completion": "def remove(strings):\n    \"\"\"\n    Remove all digits from a list of strings.\n    \n    Args:\n        strings (list): A list of strings from which digits will be removed.\n        \n    Returns:\n        list: A new list with all digits removed from each string.\n        \n    Raises:\n        TypeError: If the input is not a list or if any element in the list is not a string.\n    \"\"\"\n    # Check if the input is a list\n    if not isinstance(strings, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    # Check if all elements in the list are strings\n    if not all(isinstance(s, str) for s in strings):\n        raise TypeError(\"All elements in the list must be strings.\")\n    \n    # Remove digits from each string\n    cleaned_strings = [s for s in strings if not any(c.isdigit() for c in s)]\n    \n    return cleaned_strings\n\n# Example usage:\ntry:\n    result = remove([\"hello123\", \"world456\", \"test\"])\n    print(result)  # Output: ['hello', 'world', 'test']\nexcept TypeError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpyfdfiiua.py\", line 17, in <module>\n    assert remove(['4words', '3letters', '4digits']) == ['words', 'letters', 'digits']\nAssertionError", "passed": false}
{"task_id": 28, "completion": "import math\n\ndef binomial_coeff(n, k):\n    # Check for non-negative inputs and k <= n\n    if n < 0 or k < 0:\n        raise ValueError(\"Inputs must be non-negative\")\n    if k > n:\n        raise ValueError(\"k must not be greater than n\")\n\n    # Calculate the binomial coefficient using math.comb which is available in Python 3.8+\n    # If using an older version of Python, you can implement it manually\n    return math.comb(n, k)\n\n# Example usage:\ntry:\n    print(binomial_coeff(5, 2))  # Output: 10\n    print(binomial_coeff(6, 3))  # Output: 20\n    print(binomial_coeff(4, -1)) # Raises ValueError\n    print(binomial_coeff(-2, 1)) # Raises ValueError\n    print(binomial_coeff(3, 4))  # Raises ValueError\nexcept ValueError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpj1yoigcl.py\", line 23, in <module>\n    try: binomial_coeff(-1, 2)\n  File \"/tmp/tmpj1yoigcl.py\", line 5, in binomial_coeff\n    raise ValueError(\"Inputs must be non-negative\")\nValueError: Inputs must be non-negative\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpj1yoigcl.py\", line 24, in <module>\n    except ValueError as e: assert str(e) == 'Inputs must be non-negative and k must not be greater than n'\nAssertionError", "passed": false}
{"task_id": 29, "completion": "def get_odd_occurrence(numbers):\n    \"\"\"\n    Finds the element that occurs an odd number of times in the given list.\n    \n    Args:\n    numbers (list): A list of integers.\n    \n    Returns:\n    int: The element that occurs an odd number of times.\n    \n    Raises:\n    TypeError: If the input is not a list or contains non-integer elements.\n    \"\"\"\n    # Check if the input is a list\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    # Check if all elements in the list are integers\n    if not all(isinstance(x, int) for x in numbers):\n        raise TypeError(\"All elements in the list must be integers.\")\n    \n    # Use a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in numbers:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Find and return the number with an odd occurrence\n    for num, count in count_dict.items():\n        if count % 2 != 0:\n            return num\n\n# Example usage:\ntry:\n    print(get_odd_occurrence([1, 2, 3, 2, 3, 1, 3]))  # Output: 3\n    print(get_odd_occurrence([4, 5, 4, 5, 4]))       # Output: 4\nexcept TypeError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmplcbi4te2.py\", line 25, in <module>\n    assert get_odd_occurrence([1,2,3,1,2,3,1],7) == 1\nTypeError: get_odd_occurrence() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 30, "completion": "def count_substring_with_equal_ends(s):\n    \"\"\"\n    Counts all the substrings starting and ending with the same character.\n    \n    Parameters:\n    s (str): The input string\n    \n    Returns:\n    int: The number of substrings starting and ending with the same character\n    \n    Raises:\n    TypeError: If the input is not a string\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    \n    n = len(s)\n    count = 0\n    \n    # Iterate over each character in the string\n    for i in range(n):\n        # Count substrings starting and ending with s[i]\n        count += (i + 1) * (n - i)\n    \n    return count\n\n# Example usage:\ntry:\n    result = count_substring_with_equal_ends(\"abcab\")\n    print(f\"Number of substrings starting and ending with the same character: {result}\")\nexcept TypeError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "failed: File \"/tmp/tmptx_ba4se.py\", line 20\n    try: count_substring_with_equal_ends(123); assert False, 'Expected TypeError' except TypeError: pass\n                                                                                  ^\nSyntaxError: invalid syntax", "passed": false}
{"task_id": 31, "completion": "import heapq\n\ndef func(lists, k):\n    # Flatten the list of lists into a single list\n    flat_list = [num for sublist in lists for num in sublist]\n    \n    # Create a dictionary to count the frequency of each integer\n    freq_map = {}\n    for num in flat_list:\n        if num in freq_map:\n            freq_map[num] += 1\n        else:\n            freq_map[num] = 1\n    \n    # Check if k is valid\n    if k > len(freq_map):\n        raise ValueError(\"k cannot be greater than the number of distinct integers\")\n    \n    # Use a min-heap to keep track of the top k elements based on their frequency\n    heap = []\n    for num, freq in freq_map.items():\n        heapq.heappush(heap, (freq, num))\n        if len(heap) > k:\n            heapq.heappop(heap)\n    \n    # Extract the top k elements from the heap\n    top_k_elements = [(freq, num) for freq, num in heap]\n    \n    return top_k_elements\n\n# Example usage:\nlists = [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\nk = 2\nprint(func(lists, k))  # Output: [(3, 2), (3, 3)]\n", "requirement": "Exception Handling", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp7ov1qacd.py\", line 28, in <module>\n    assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],3)==[5, 7, 1]\nAssertionError", "passed": false}
{"task_id": 32, "completion": "def max_prime_factors(n):\n    \"\"\"\n    Finds the largest prime factor of a given positive integer.\n    \n    Parameters:\n    n (int): The number for which to find the largest prime factor.\n    \n    Returns:\n    int: The largest prime factor of the given number.\n    \n    Raises:\n    ValueError: If the input is not a positive integer.\n    \"\"\"\n    # Check if the input is a positive integer\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    # Initialize the largest prime factor variable\n    largest_prime = None\n    \n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        largest_prime = 2\n        n //= 2\n    \n    # n must be odd at this point, so we can skip one element (Note i = i + 2)\n    for i in range(3, int(n**0.5) + 1, 2):\n        # While i divides n, remove i and set largest_prime to i\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n    \n    # This condition is to handle the case when n is a prime number\n    # greater than 2\n    if n > 2:\n        largest_prime = n\n    \n    return largest_prime\n\n# Example usage:\ntry:\n    print(max_prime_factors(13195))  # Should return 29\n    print(max_prime_factors(600851475143))  # Should return the largest prime factor of this large number\nexcept ValueError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "passed", "passed": true}
{"task_id": 33, "completion": "def decimal_to_binary(decimal_number):\n    \"\"\"\n    Convert a non-negative integer from decimal to binary.\n    \n    Parameters:\n    decimal_number (int): A non-negative integer to be converted to binary.\n    \n    Returns:\n    str: The binary representation of the given decimal number.\n    \n    Raises:\n    ValueError: If the input is not a non-negative integer.\n    \"\"\"\n    # Check if the input is a non-negative integer\n    if not isinstance(decimal_number, int) or decimal_number < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    # Edge case for 0\n    if decimal_number == 0:\n        return \"0\"\n    \n    binary_number = \"\"\n    while decimal_number > 0:\n        remainder = decimal_number % 2\n        binary_number = str(remainder) + binary_number\n        decimal_number = decimal_number // 2\n    \n    return binary_number\n\n# Example usage:\ntry:\n    print(decimal_to_binary(10))  # Output: 1010\n    print(decimal_to_binary(255)) # Output: 11111111\n    print(decimal_to_binary(-1))  # Raises ValueError\nexcept ValueError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp8wjtglox.py\", line 21, in <module>\n    assert decimal_to_binary(10) == 1010\nAssertionError", "passed": false}
{"task_id": 34, "completion": "def find_missing(arr):\n    # Check if the list is sorted\n    if not all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)):\n        raise ValueError(\"Input list must be sorted.\")\n    \n    # Find the missing number\n    for i in range(len(arr) - 1):\n        if arr[i] + 1 != arr[i + 1]:\n            return arr[i] + 1\n    \n    # If no missing number found within the list, check the edge cases\n    if arr[0] != 0:\n        return 0\n    elif arr[-1] != len(arr):\n        return len(arr)\n    else:\n        return None  # No missing number in the list\n\n# Example usage:\ntry:\n    print(find_missing([0, 1, 2, 4, 5]))  # Output: 3\n    print(find_missing([1, 2, 3, 4, 5]))  # Output: None (no missing number)\n    print(find_missing([0, 1, 3, 4, 5]))  # Output: 2\nexcept ValueError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpsllk5g9g.py\", line 23, in <module>\n    assert find_missing([1,2,3,5],4) == 4\nTypeError: find_missing() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 35, "completion": "def find_rect_num(n):\n    # Check if the input is a positive integer\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    # Calculate the n-th rectangular number\n    rect_num = n * (n + 1)\n    \n    return rect_num\n\n# Example usage:\ntry:\n    print(find_rect_num(5))   # Output: 30 (5 * 6)\n    print(find_rect_num(7))   # Output: 56 (7 * 8)\nexcept ValueError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "passed", "passed": true}
{"task_id": 36, "completion": "def find_nth_digit(numerator, denominator, n):\n    \"\"\"\n    Find the n-th digit in the decimal representation of the fraction numerator/denominator.\n\n    Parameters:\n    numerator (int): The numerator of the fraction.\n    denominator (int): The denominator of the fraction.\n    n (int): The position of the digit to find in the decimal representation.\n\n    Returns:\n    int: The n-th digit in the decimal representation of the fraction.\n\n    Raises:\n    ValueError: If the denominator is zero.\n    IndexError: If the requested digit position is out of range for the repeating or non-repeating part of the decimal.\n    \"\"\"\n    # Check for division by zero\n    if denominator == 0:\n        raise ValueError(\"Denominator cannot be zero\")\n\n    # Convert the fraction to its decimal form\n    decimal_part = str(numerator / denominator)\n\n    # Remove the \"0.\" prefix from the string representation\n    decimal_part = decimal_part.split('.')[1]\n\n    # Check if there is a repeating decimal part\n    if '...' in decimal_part:\n        # Extract the repeating part\n        repeating_start = decimal_part.index('...')\n        repeating_part = decimal_part[repeating_start + 3:]\n    else:\n        repeating_part = \"\"\n\n    # Check if the requested digit is within the repeating part\n    if n <= len(decimal_part) - len(repeating_part):\n        return int(decimal_part[n - 1])\n    elif n <= len(decimal_part):\n        return int(decimal_part[-1])\n    else:\n        # If the requested digit is in the repeating part\n        offset = n - len(decimal_part)\n        return int(repeating_part[offset % len(repeating_part)])\n\n# Example usage:\ntry:\n    print(find_nth_digit(1, 2, 1))  # Should print 5 (since 1/2 = 0.5)\n    print(find_nth_digit(2, 7, 5))  # Should print 1 (since 2/7 = 0.285714285714..., 5th digit is 1)\nexcept ValueError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "passed", "passed": true}
{"task_id": 37, "completion": "def sort_mixed_list(lst):\n    # Check if the input is a list\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    # Check if all elements in the list are either integers or strings\n    if not all(isinstance(item, (int, str)) for item in lst):\n        raise TypeError(\"List must contain only integers and strings.\")\n    \n    # Sort the list\n    # Convert all strings to lowercase for case-insensitive sorting\n    sorted_lst = sorted(lst, key=lambda x: str(x).lower())\n    \n    return sorted_lst\n\n# Example usage:\ntry:\n    print(sort_mixed_list([3, \"apple\", 1, \"banana\", 2, \"cherry\"]))\n    print(sort_mixed_list([\"banana\", 10, \"apple\", 20, \"cherry\", 5]))\nexcept TypeError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "passed", "passed": true}
{"task_id": 38, "completion": "def div_even_odd(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns the division of the first even and odd numbers in the list.\n    \n    Parameters:\n    numbers (list): A list of integers.\n    \n    Returns:\n    float: The division of the first even and odd numbers in the list.\n    \n    Raises:\n    ValueError: If the list does not contain at least one even and one odd number.\n    \"\"\"\n    # Initialize variables to keep track of the first even and odd numbers found\n    first_even = None\n    first_odd = None\n    \n    for num in numbers:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        \n        # If both first_even and first_odd have been found, we can break out of the loop\n        if first_even is not None and first_odd is not None:\n            break\n    \n    # Check if both first_even and first_odd have been found\n    if first_even is None or first_odd is None:\n        raise ValueError('List must contain at least one even and one odd number.')\n    \n    # Return the division of the first even and odd numbers\n    return first_even / first_odd\n\n# Example usage:\ntry:\n    print(div_even_odd([3, 5, 7, 8, 10]))  # Output will be 8/3\nexcept ValueError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "failed: File \"/tmp/tmpdaxvrgly.py\", line 26\n    try: div_even_odd([2, 4, 6]); assert False; except ValueError as e: assert str(e) == 'List must contain at least one even and one odd number.'\n                                                ^\nSyntaxError: invalid syntax", "passed": false}
{"task_id": 39, "completion": "def rearrange_string(s):\n    # Check if the input is a string\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string.\")\n    \n    # Check if the string contains only lowercase letters\n    if not s.islower():\n        raise ValueError(\"String must contain only lowercase letters.\")\n    \n    # Count the frequency of each character in the string\n    from collections import Counter\n    char_count = Counter(s)\n    \n    # Find the most frequent character\n    max_char = char_count.most_common(1)[0][0]\n    max_count = char_count[max_char]\n    \n    # If any character appears more than half the length of the string,\n    # it's impossible to rearrange the string as required\n    if max_count > (len(s) + 1) // 2:\n        return False\n    \n    # Try to construct a valid rearrangement\n    result = []\n    for char, count in char_count.items():\n        if char == max_char:\n            # Place the most frequent character first\n            result.extend([char] * count)\n        else:\n            # Place other characters in between\n            for _ in range(count):\n                try:\n                    index = result.index(max_char)\n                    result.insert(index, char)\n                except ValueError:\n                    # If max_char is not found, append to the end\n                    result.append(char)\n    \n    # Verify that no two adjacent characters are the same\n    for i in range(len(result) - 1):\n        if result[i] == result[i + 1]:\n            return False\n    \n    return True\n\n# Example usage:\ntry:\n    print(rearrange_string(\"aabbcc\"))  # Should return True\n    print(rearrange_string(\"aaabc\"))   # Should return False\n    print(rearrange_string(\"abc\"))     # Should return True\n    print(rearrange_string(\"aabbccddee\"))  # Should return True\n    print(rearrange_string(\"aabbccddeeef\"))  # Should return False\nexcept ValueError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmppjxh16aa.py\", line 47, in <module>\n    assert rearange_string(\"aab\")==('aba')\nNameError: name 'rearange_string' is not defined", "passed": false}
{"task_id": 40, "completion": "from collections import Counter\n\ndef freq_element(input_list):\n    # Check if input is a list of lists\n    if not all(isinstance(sublist, list) for sublist in input_list):\n        raise TypeError(\"Input must be a list of lists\")\n    \n    # Flatten the list of lists into a single list\n    flat_list = [item for sublist in input_list for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    element_freq = Counter(flat_list)\n    \n    return element_freq\n\n# Example usage:\ninput_data = [[1, 2, 3], [4, 5, 1], [6, 7, 8, 1]]\nprint(freq_element(input_data))\n", "requirement": "Exception Handling", "result": "failed: File \"/tmp/tmpuc4wk7n_.py\", line 17\n    try: freq_element('not a list'); assert False; except TypeError: assert True\n                                                   ^\nSyntaxError: invalid syntax", "passed": false}
{"task_id": 41, "completion": "def filter_evennumbers(numbers):\n    # Check if the input is a list\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list\")\n    \n    # Check if all elements in the list are integers\n    if not all(isinstance(x, int) for x in numbers):\n        raise TypeError(\"All elements in the list must be integers\")\n    \n    # Use a lambda function to filter even numbers\n    even_numbers = list(filter(lambda x: x % 2 == 0, numbers))\n    \n    return even_numbers\n\n# Example usage:\ntry:\n    print(filter_evennumbers([1, 2, 3, 4, 5]))  # Output: [2, 4]\n    print(filter_evennumbers([10, 21, 32, 43, 54]))  # Output: [10, 32, 54]\n    print(filter_evennumbers([1, \"two\", 3, 4]))  # Raises TypeError\nexcept TypeError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "passed", "passed": true}
{"task_id": 42, "completion": "def find_sum(arr):\n    \"\"\"\n    Finds the sum of repeated elements in a given list.\n    \n    Parameters:\n    arr (list): The list of elements to process.\n    \n    Returns:\n    int: The sum of the repeated elements.\n    \n    Raises:\n    TypeError: If the input is not a list.\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list\")\n    \n    # Count the occurrences of each element in the list\n    from collections import Counter\n    element_counts = Counter(arr)\n    \n    # Calculate the sum of elements that appear more than once\n    sum_repeated = sum(element for element, count in element_counts.items() if count > 1)\n    \n    return sum_repeated\n\n# Example usage:\ntry:\n    print(find_sum([1, 2, 3, 2, 4, 5, 5]))  # Output: 7 (2 + 5)\nexcept TypeError as e:\n    print(e)\n\ntry:\n    print(find_sum(\"not a list\"))  # This will raise a TypeError\nexcept TypeError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpagjoyzb6.py\", line 19, in <module>\n    assert find_sum([1,2,3,1,1,4,5,6],8) == 3\nTypeError: find_sum() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 43, "completion": "import re\n\ndef text_match(text):\n    \"\"\"\n    Finds sequences of lowercase letters joined with an underscore.\n    \n    Parameters:\n    text (str): The input string to be checked.\n    \n    Returns:\n    bool: True if the input matches the pattern, False otherwise.\n    \n    Raises:\n    TypeError: If the input is not a string.\n    \"\"\"\n    if not isinstance(text, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Define the regex pattern for lowercase letters joined with an underscore\n    pattern = r'^[a-z]+_[a-z]+$'\n    \n    # Search for the pattern in the input text\n    match = re.search(pattern, text)\n    \n    # Return True if a match is found, False otherwise\n    return bool(match)\n\n# Example usage:\ntry:\n    print(text_match(\"hello_world\"))  # Should return True\n    print(text_match(\"Hello_World\"))  # Should return False because it's not all lowercase\n    print(text_match(\"hello_world_123\"))  # Should return False because it contains non-lowercase characters\n    print(text_match(12345))  # Should raise TypeError\nexcept TypeError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpy08hglcv.py\", line 19, in <module>\n    assert text_match(\"aab_cbbbc\") == 'Found a match!'\nAssertionError", "passed": false}
{"task_id": 44, "completion": "def text_match_string(input_string, word):\n    \"\"\"\n    Matches a word at the beginning of a string.\n\n    Parameters:\n    input_string (str): The string to be checked.\n    word (str): The word to match at the beginning of the string.\n\n    Returns:\n    bool: True if the word is found at the beginning of the string, False otherwise.\n\n    Raises:\n    TypeError: If either input_string or word is not a string.\n    \"\"\"\n    # Check if both inputs are strings\n    if not isinstance(input_string, str) or not isinstance(word, str):\n        raise TypeError(\"Both input_string and word must be strings.\")\n\n    # Check if the word is at the beginning of the string\n    return input_string.startswith(word)\n\n# Example usage:\ntry:\n    print(text_match_string(\"Hello world\", \"Hello\"))  # Expected output: True\n    print(text_match_string(\"Hello world\", \"hello\"))  # Expected output: False\n    print(text_match_string(123, \"test\"))             # This will raise a TypeError\nexcept TypeError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "failed: File \"/tmp/tmpl2t0m70q.py\", line 17\n    try: text_match_string(123); assert False, 'TypeError not raised' except TypeError: pass\n                                                                      ^\nSyntaxError: invalid syntax", "passed": false}
{"task_id": 45, "completion": "import math\nfrom typing import List\n\ndef get_gcd(arr: List[int]) -> int:\n    \"\"\"\n    Returns the greatest common divisor (GCD) of the elements in the given array.\n    \n    Parameters:\n    arr (List[int]): A list of integers.\n    \n    Returns:\n    int: The GCD of the elements in the array.\n    \n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError('Input list cannot be empty.')\n    \n    current_gcd = arr[0]\n    for num in arr[1:]:\n        current_gcd = math.gcd(current_gcd, num)\n    \n    return current_gcd\n\n# Example usage:\ntry:\n    print(get_gcd([24, 36, 48]))  # Output: 12\n    print(get_gcd([]))            # This will raise a ValueError\nexcept ValueError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "passed", "passed": true}
{"task_id": 46, "completion": "def test_distinct(lst):\n    \"\"\"\n    Check if all numbers in the list are distinct.\n    \n    Args:\n    lst (list): A list of integers.\n    \n    Returns:\n    bool: True if all numbers are distinct, False otherwise.\n    \n    Raises:\n    TypeError: If the input is not a list or contains non-integer elements.\n    \"\"\"\n    # Check if the input is a list\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    # Check if all elements in the list are integers\n    if not all(isinstance(x, int) for x in lst):\n        raise TypeError(\"All elements in the list must be integers.\")\n    \n    # Use a set to check for distinct elements\n    return len(lst) == len(set(lst))\n\n# Example usage:\ntry:\n    print(test_distinct([1, 2, 3, 4]))  # Should return True\n    print(test_distinct([1, 2, 2, 4]))  # Should return False\n    print(test_distinct([1, \"2\", 3]))   # Should raise TypeError\nexcept TypeError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "passed", "passed": true}
{"task_id": 47, "completion": "def compute_last_digit(a, b):\n    \"\"\"\n    Computes the last digit of the division of factorial(b) by factorial(a).\n    \n    Args:\n    a (int): The first integer.\n    b (int): The second integer, which must be greater than or equal to a.\n    \n    Returns:\n    int: The last digit of the division of factorial(b) by factorial(a).\n    \n    Raises:\n    ValueError: If a > b.\n    \"\"\"\n    if a > b:\n        raise ValueError(\"a should not be greater than b\")\n\n    def factorial(n):\n        \"\"\"Helper function to compute the factorial of n.\"\"\"\n        result = 1\n        for i in range(2, n + 1):\n            result *= i\n        return result\n\n    # Compute factorials\n    fact_a = factorial(a)\n    fact_b = factorial(b)\n\n    # Compute the division and get the last digit\n    last_digit = (fact_b // fact_a) % 10\n\n    return last_digit\n\n# Example usage:\ntry:\n    print(compute_last_digit(3, 5))  # Should print the last digit of 5! / 3!\nexcept ValueError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "passed", "passed": true}
{"task_id": 48, "completion": "def odd_bit_set_number(n):\n    \"\"\"\n    Sets all the odd bits of the given number n.\n    \n    Parameters:\n    n (int): The number whose odd bits need to be set.\n    \n    Returns:\n    int: The number with all odd bits set.\n    \n    Raises:\n    TypeError: If the input is not an integer.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    \n    # Create a mask where odd bits are set to 1\n    # For example, for 32-bit integers, the mask would be 0b10101010101010101010101010101010\n    mask = 0b10101010101010101010101010101010\n    \n    # Use the mask to set the odd bits of the number\n    return n | mask\n\n# Example usage:\ntry:\n    print(odd_bit_set_number(10))  # Output: 21\nexcept TypeError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpc8uisxid.py\", line 14, in <module>\n    assert odd_bit_set_number(10) == 15\nAssertionError", "passed": false}
{"task_id": 49, "completion": "def specified_element(two_d_list, index=0):\n    \"\"\"\n    Extracts the element at the specified index from each sublist in a two-dimensional list.\n    \n    :param two_d_list: A two-dimensional list from which elements are to be extracted.\n    :param index: The index of the element to extract from each sublist. Default is 0 (first element).\n    :return: A list containing the extracted elements.\n    \n    Raises:\n        IndexError: If the specified index is out of range for any sublist.\n    \"\"\"\n    result = []\n    for sublist in two_d_list:\n        try:\n            # Attempt to extract the element at the specified index\n            result.append(sublist[index])\n        except IndexError:\n            # Raise an IndexError with a descriptive message if the index is out of range\n            raise IndexError(\"Index out of range for sublist: \" + str(sublist))\n    return result\n\n# Example usage:\ntry:\n    two_d_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    print(specified_element(two_d_list, 1))  # Should print [2, 5, 8]\nexcept IndexError as e:\n    print(e)\n\ntry:\n    two_d_list = [[1, 2, 3], [4, 5], [7, 8, 9]]\n    print(specified_element(two_d_list, 2))  # Should raise an IndexError\nexcept IndexError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpd3u70g6o.py\", line 6, in specified_element\n    result.append(sublist[index])\nIndexError: list index out of range\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpd3u70g6o.py\", line 25, in <module>\n    try: specified_element([[1, 2], [3, 4]], 3)\n  File \"/tmp/tmpd3u70g6o.py\", line 9, in specified_element\n    raise IndexError(\"Index out of range for sublist: \" + str(sublist))\nIndexError: Index out of range for sublist: [1, 2]\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpd3u70g6o.py\", line 26, in <module>\n    except IndexError as e: assert str(e) == 'Index out of range for sublist'\nAssertionError", "passed": false}
{"task_id": 50, "completion": "def min_length_list(lists):\n    # Check if the input is a list of lists\n    if not all(isinstance(lst, list) for lst in lists):\n        raise ValueError(\"Input must be a list of lists.\")\n    \n    # Use a lambda function to find the list with the minimum length\n    min_list = min(lists, key=lambda x: len(x))\n    \n    return min_list\n\n# Example usage:\ntry:\n    example_lists = [[1, 2, 3], [4, 5], [6], [7, 8, 9, 10]]\n    print(min_length_list(example_lists))  # Output: [6]\nexcept ValueError as e:\n    print(e)\n\n# Testing with invalid input\ntry:\n    invalid_input = [[1, 2], \"not a list\", [3, 4]]\n    print(min_length_list(invalid_input))\nexcept ValueError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpuu4caeoe.py\", line 20, in <module>\n    assert min_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(1, [0])\nAssertionError", "passed": false}
{"task_id": 51, "completion": "def check_equilateral(a, b, c):\n    # Check if all inputs are positive integers\n    if not (isinstance(a, int) and isinstance(b, int) and isinstance(c, int)):\n        raise ValueError(\"All inputs must be integers.\")\n    if a <= 0 or b <= 0 or c <= 0:\n        raise ValueError(\"All sides must be positive integers.\")\n\n    # Check if the triangle is equilateral\n    if a == b == c:\n        print(\"The triangle is equilateral.\")\n    else:\n        print(\"The triangle is not equilateral.\")\n\n# Example usage:\ntry:\n    check_equilateral(5, 5, 5)  # Should print \"The triangle is equilateral.\"\n    check_equilateral(5, 5, 6)  # Should print \"The triangle is not equilateral.\"\n    check_equilateral(-1, 5, 5) # Should raise ValueError\nexcept ValueError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpys179kf8.py\", line 19, in <module>\n    assert check_equilateral(6,8,12)==False \nAssertionError", "passed": false}
{"task_id": 52, "completion": "def parallelogram_area(base, height):\n    \"\"\"\n    Calculate the area of a parallelogram.\n    \n    Parameters:\n    base (float or int): The length of the base of the parallelogram.\n    height (float or int): The height of the parallelogram.\n    \n    Returns:\n    float: The area of the parallelogram.\n    \n    Raises:\n    TypeError: If either base or height is not a number.\n    \"\"\"\n    # Check if both base and height are numbers (int or float)\n    if not isinstance(base, (int, float)) or not isinstance(height, (int, float)):\n        raise TypeError(\"Both base and height must be numerical values.\")\n    \n    # Calculate the area\n    area = base * height\n    \n    return area\n\n# Example usage:\ntry:\n    print(parallelogram_area(5, 10))  # Expected output: 50\n    print(parallelogram_area('5', 10))  # This will raise a TypeError\nexcept TypeError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "passed", "passed": true}
{"task_id": 53, "completion": "def check_equality(input_string):\n    # Check if the input is a string\n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n\n    # Check if the string is empty or has only one character\n    if len(input_string) < 2:\n        return False\n\n    # Check if the first and last characters are equal\n    return input_string[0] == input_string[-1]\n\n# Example usage:\ntry:\n    print(check_equality(\"radar\"))  # Should return True\n    print(check_equality(\"hello\"))  # Should return False\n    print(check_equality(\"a\"))      # Should return False\n    print(check_equality(123))      # Should raise TypeError\nexcept TypeError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp1rq8f32h.py\", line 18, in <module>\n    assert check_equality(\"abcda\") == \"Equal\"\nAssertionError", "passed": false}
{"task_id": 54, "completion": "def counting_sort(arr):\n    # Check if the input is a list\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list\")\n\n    # Check if all elements in the list are integers\n    if not all(isinstance(x, int) for x in arr):\n        raise TypeError(\"All elements in the list must be integers\")\n\n    # Find the maximum element to know the size of the count array\n    max_element = max(arr)\n\n    # Initialize the count array with zeros\n    count = [0] * (max_element + 1)\n\n    # Store the count of each element\n    for num in arr:\n        count[num] += 1\n\n    # Build the sorted array\n    sorted_arr = []\n    for i in range(len(count)):\n        sorted_arr.extend([i] * count[i])\n\n    return sorted_arr\n\n# Example usage:\ntry:\n    print(counting_sort([4, 2, 2, 8, 3, 3, 1]))  # Output: [1, 2, 2, 3, 3, 4, 8]\n    print(counting_sort(['a', 3, 2]))  # Should raise TypeError\nexcept TypeError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "passed", "passed": true}
{"task_id": 55, "completion": "def tn_gp(a, r, t):\n    \"\"\"\n    Calculate the t-th term of a geometric series.\n    \n    Parameters:\n    a (float): The first term of the geometric series.\n    r (float): The common ratio of the geometric series.\n    t (int): The term number to calculate. Must be greater than 0.\n    \n    Returns:\n    float: The t-th term of the geometric series.\n    \n    Raises:\n    ValueError: If t is less than 1.\n    \"\"\"\n    # Validate the term number\n    if t < 1:\n        raise ValueError('Term number must be greater than 0')\n    \n    # Calculate the t-th term of the geometric series\n    return a * (r ** (t - 1))\n\n# Example usage:\ntry:\n    print(tn_gp(2, 3, 4))  # This should print 162\nexcept ValueError as e:\n    print(e)\n\ntry:\n    print(tn_gp(5, 0.5, 3))  # This should print 1.25\nexcept ValueError as e:\n    print(e)\n\ntry:\n    print(tn_gp(1, 2, 0))  # This should raise a ValueError\nexcept ValueError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpt9oyree9.py\", line 20, in <module>\n    assert tn_gp(1,5,2)==16\nAssertionError", "passed": false}
{"task_id": 56, "completion": "def check(number):\n    # Check if the input is an integer\n    if not isinstance(number, int):\n        raise TypeError(\"Input must be an integer\")\n    \n    # Convert the number to a string to reverse it\n    str_number = str(number)\n    reversed_number = str_number[::-1]\n    \n    # Convert the reversed string back to an integer\n    reversed_int = int(reversed_number)\n    \n    # Calculate twice the reversed number minus one\n    expected_value = 2 * reversed_int - 1\n    \n    # Check if the original number matches the expected value\n    return number == expected_value\n\n# Example usage:\ntry:\n    print(check(59))  # Should return True because 59 is one less than twice its reverse (95)\n    print(check(47))  # Should return False because 47 is not one less than twice its reverse (74)\nexcept TypeError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "passed", "passed": true}
{"task_id": 57, "completion": "def find_max_num(digits, num_digits):\n    \"\"\"\n    Find the largest number that can be formed with the given digits.\n    \n    Parameters:\n    digits (list): A list of single-digit integers.\n    num_digits (int): The number of digits to use in forming the largest number.\n    \n    Returns:\n    int: The largest number that can be formed.\n    \n    Raises:\n    ValueError: If the number of digits specified exceeds the length of the list of digits.\n    \"\"\"\n    # Check if the number of digits specified exceeds the length of the list of digits\n    if num_digits > len(digits):\n        raise ValueError(\"Number of digits exceeds the length of the list.\")\n    \n    # Sort the digits in descending order\n    sorted_digits = sorted(digits, reverse=True)\n    \n    # Extract the first 'num_digits' elements from the sorted list\n    max_num_digits = sorted_digits[:num_digits]\n    \n    # Join the digits to form the largest possible number\n    max_num_str = ''.join(map(str, max_num_digits))\n    \n    # Convert the string back to an integer\n    max_num = int(max_num_str)\n    \n    return max_num\n\n# Example usage:\ntry:\n    print(find_max_num([1, 2, 3, 4], 3))  # Should print 4321\n    print(find_max_num([9, 7, 8, 5, 6], 4))  # Should print 9876\n    print(find_max_num([0, 1, 2], 3))  # Should print 210\n    print(find_max_num([1, 2], 3))  # Should raise ValueError\nexcept ValueError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "passed", "passed": true}
{"task_id": 58, "completion": "def opposite_signs(a, b):\n    # Check if both inputs are integers\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError(\"Both inputs must be integers.\")\n    \n    # Check if the numbers have opposite signs\n    return (a < 0) != (b < 0)\n\n# Example usage:\ntry:\n    print(opposite_signs(10, -5))  # Should return True\n    print(opposite_signs(-3, -7))  # Should return False\n    print(opposite_signs(0, 5))    # Should return False\n    print(opposite_signs(2.5, -3)) # Should raise TypeError\nexcept TypeError as e:\n    print(e)\n", "requirement": "Exception Handling", "result": "passed", "passed": true}
{"task_id": 59, "completion": "def is_octagonal(n):\n    # Check if the input is a positive integer\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    # Solve the quadratic equation derived from the octagonal number formula\n    # Rearrange the formula to standard quadratic form: 3n^2 - 2n - O_n = 0\n    # Use the quadratic formula to solve for n: n = (1 + sqrt(1 + 4 * 3 * O_n)) / 6\n    a = 3\n    b = -2\n    c = -n\n    \n    discriminant = b**2 - 4*a*c\n    \n    # Check if the discriminant is non-negative and a perfect square\n    if discriminant < 0 or (discriminant**0.5) % 1 != 0:\n        return False\n    \n    # Calculate the potential value of n using the positive root of the quadratic formula\n    n_value = (b + discriminant**0.5) / (2 * a)\n    \n    # Check if the result is an integer\n    return n_value.is_integer()\n\n# Example usage:\nprint(is_octagonal(1))  # True, because 1 is the first octagonal number\nprint(is_octagonal(21)) # True, because 21 is the 4th octagonal number\nprint(is_octagonal(22)) # False, 22 is not an octagonal number\n", "requirement": "Exception Handling", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpyologor_.py\", line 23, in <module>\n    assert is_octagonal(5) == 65\nAssertionError", "passed": false}
{"task_id": 60, "completion": "def max_len_sub(arr, k):\n    # Check if the input is a list\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list\")\n    \n    # Check if k is an integer\n    if not isinstance(k, int):\n        raise TypeError(\"k must be an integer\")\n\n    # If the list is empty or k is non-positive, return 0\n    if len(arr) == 0 or k <= 0:\n        return 0\n\n    # Initialize variables to keep track of the maximum length subsequence\n    max_length = 1\n    current_length = 1\n\n    # Iterate through the list to find the longest subsequence\n    for i in range(1, len(arr)):\n        # Check if the difference between adjacent elements is at most k\n        if abs(arr[i] - arr[i-1]) <= k:\n            current_length += 1\n            max_length = max(max_length, current_length)\n        else:\n            current_length = 1\n\n    return max_length\n\n# Example usage:\narr = [1, 2, 3, 4, 5, 6, 7]\nk = 1\nprint(max_len_sub(arr, k))  # Output: 7\n\narr = [1, 3, 5, 7, 9]\nk = 2\nprint(max_len_sub(arr, k))  # Output: 5\n\narr = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\nk = 1\nprint(max_len_sub(arr, k))  # Output: 10\n\narr = [1, 3, 5, 7, 9]\nk = 0\nprint(max_len_sub(arr, k))  # Output: 1\n\narr = []\nk = 1\nprint(max_len_sub(arr, k))  # Output: 0\n", "requirement": "Exception Handling", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpq8wiapnt.py\", line 39, in <module>\n    assert max_len_sub([2, 5, 6, 3, 7, 6, 5, 8], 8) == 5\nAssertionError", "passed": false}
