{"task_id": 14, "requirement": "Input-Output Conditions", "completion": "def find_volume(base_area, height_prism):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Parameters:\n    - base_area (float): The area of the triangular base.\n    - height_prism (float): The height (or length) of the prism.\n    \n    Returns:\n    float: The volume of the triangular prism.\n    \"\"\"\n    # Calculate the volume of the triangular prism\n    volume = base_area * height_prism\n    \n    return volume\n\n# Example usage:\n# Find the volume of a triangular prism with a base area of 6 square units,\n# and a height of the prism of 10 units.\nvolume = find_volume(6, 10)\nprint(f\"The volume of the triangular prism is {volume} cubic units.\")\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp1379184n.py\", line 10, in <module>\n    assert find_volume(10,8,6) == 240\nTypeError: find_volume() takes 2 positional arguments but 3 were given", "passed": false}
{"task_id": 15, "requirement": "Input-Output Conditions", "completion": "import re\n\ndef split_lowerstring(input_string):\n    # Use regex to match each lowercase letter as a split point\n    # This pattern captures the position just after each lowercase letter\n    pattern = r'(?<=[a-z])(?=[A-Z0-9])|(?<=[A-Z])(?=[a-z0-9])|(?<=[0-9])(?=[a-zA-Z])'\n    \n    # Split the string using the found patterns\n    split_strings = re.split(pattern, input_string)\n    \n    # Ensure to remove any potential empty strings\n    non_empty_strings = [s for s in split_strings if s]\n    \n    return non_empty_strings\n\n# Example usage:\nexample_string = \"aBcD1eF2g3hIjKlmNOpQrStUvWxYz\"\nprint(split_lowerstring(example_string))  # Expected output: ['aBcD', '1eF', '2g', '3hIjKl', 'mNOpQrSt', 'UvWxYz']\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmprtpfyfaa.py\", line 14, in <module>\n    assert split_lowerstring(\"AbCd\")==['bC','d']\nAssertionError", "passed": false}
{"task_id": 16, "requirement": "Input-Output Conditions", "completion": "import re\n\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if the given text contains sequences of lowercase letters joined with an underscore.\n\n    :param text: A string containing the text to search within.\n    :return: 'Found a match!' if a sequence is found, otherwise 'Not matched!'.\n    \"\"\"\n    # Define the regex pattern for finding sequences of lowercase letters joined with an underscore\n    pattern = r\"([a-z]+_[a-z]+)\"\n    \n    # Use re.search to find if there is any match of the pattern in the text\n    match = re.search(pattern, text)\n    \n    # Return 'Found a match!' if a match is found, otherwise 'Not matched!'\n    if match:\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n\n# Example usage:\nexample_text = \"This_is_an_example_text_with_lower_case_words_and_this_one_is_special\"\nprint(text_lowercase_underscore(example_text))  # Output: Found a match!\nprint(text_lowercase_underscore(\"NO_UNDERSCORE\"))  # Output: Not matched!\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpgw0pkq_s.py\", line 18, in <module>\n    assert text_lowercase_underscore(\"Aaab_abbbc\")==('Not matched!')\nAssertionError", "passed": false}
{"task_id": 17, "requirement": "Input-Output Conditions", "completion": "def square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square.\n    \n    :param side_length: The length of one side of the square.\n    :return: The perimeter of the square.\n    :raises ValueError: If side_length is negative or not an integer.\n    \"\"\"\n    if not isinstance(side_length, int) or side_length < 0:\n        raise ValueError(\"Side length must be a non-negative integer.\")\n    \n    return 4 * side_length\n\n# Example usage:\ntry:\n    perimeter = square_perimeter(5)\n    print(\"The perimeter of the square is:\", perimeter)\nexcept ValueError as e:\n    print(e)\n\ntry:\n    perimeter = square_perimeter(-3)\n    print(\"The perimeter of the square is:\", perimeter)\nexcept ValueError as e:\n    print(e)\n", "result": "passed", "passed": true}
{"task_id": 18, "requirement": "Input-Output Conditions", "completion": "def remove_dirty_chars(main_string, chars_to_remove):\n    \"\"\"\n    Removes characters from main_string that are present in chars_to_remove.\n    \n    Parameters:\n    - main_string (str): The original string from which characters will be removed.\n    - chars_to_remove (str): The string containing characters to be removed from main_string.\n    \n    Returns:\n    - str: The modified string after removing specified characters.\n    \n    Raises:\n    - ValueError: If either of the input strings contains non-alphabetic characters.\n    \"\"\"\n    # Check if input strings contain only alphabetic characters\n    if not (main_string.isalpha() and chars_to_remove.isalpha()):\n        raise ValueError(\"Input strings must only contain alphabetic characters.\")\n    \n    # Create a set of characters to remove for faster lookup\n    chars_set = set(chars_to_remove)\n    \n    # Use a generator expression to filter out unwanted characters\n    filtered_string = ''.join(char for char in main_string if char not in chars_set)\n    \n    return filtered_string\n\n# Example usage:\ntry:\n    original_str = \"abcdefg\"\n    chars_to_remove = \"ace\"\n    cleaned_str = remove_dirty_chars(original_str, chars_to_remove)\n    print(cleaned_str)  # Output should be \"bdfg\"\n\n    # Testing with non-alphabetic characters\n    invalid_str = \"abc123\"\n    remove_dirty_chars(invalid_str, \"a\")\nexcept ValueError as e:\n    print(e)  # Should print \"Input strings must only contain alphabetic characters.\"\n", "result": "passed", "passed": true}
{"task_id": 19, "requirement": "Input-Output Conditions", "completion": "def test_duplicate(arr):\n    \"\"\"\n    Check if the given list contains any duplicate elements.\n\n    :param arr: List of integers\n    :return: True if there are duplicates, False otherwise\n    :raises TypeError: If the input is not a list\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list\")\n\n    seen = set()\n    for number in arr:\n        if not isinstance(number, int):\n            raise TypeError(\"All elements in the list must be integers\")\n        if number in seen:\n            return True\n        seen.add(number)\n    return False\n\n# Example usage:\ntry:\n    example_list = [1, 2, 3, 4, 5, 2]\n    print(test_duplicate(example_list))  # Output: True\n\n    another_example_list = [10, 22, 33, 44, 55]\n    print(test_duplicate(another_example_list))  # Output: False\n\n    invalid_input = \"not a list\"\n    print(test_duplicate(invalid_input))  # This will raise TypeError\nexcept TypeError as e:\n    print(e)\n\ntry:\n    another_invalid_input = [1, 2, \"three\", 4, 5]\n    print(test_duplicate(another_invalid_input))  # This will raise TypeError\nexcept TypeError as e:\n    print(e)\n", "result": "passed", "passed": true}
{"task_id": 20, "requirement": "Input-Output Conditions", "completion": "def is_woodall(num):\n    \"\"\"\n    Check if the given number is a Woodall number.\n    \n    A Woodall number is of the form n * 2^n - 1 for some positive integer n.\n    \n    :param num: Integer to check\n    :return: True if num is a Woodall number, False otherwise\n    \"\"\"\n    # Start with n = 1 and incrementally check each candidate\n    n = 1\n    while True:\n        # Compute the candidate Woodall number for the current n\n        candidate = n * 2**n - 1\n        \n        # If the candidate equals the input number, we have found our match\n        if candidate == num:\n            return True\n        \n        # If the candidate exceeds the input number, num cannot be a Woodall number\n        if candidate > num:\n            return False\n        \n        # Move to the next candidate\n        n += 1\n\n# Example usage:\nprint(is_woodall(7))   # True, because 7 is 1*2^1-1\nprint(is_woodall(23))  # True, because 23 is 2*2^2-1\nprint(is_woodall(63))  # True, because 63 is 3*2^3-1\nprint(is_woodall(10))  # False\n", "result": "passed", "passed": true}
{"task_id": 23, "requirement": "Input-Output Conditions", "completion": "def maximum_sum(list_of_lists):\n    \"\"\"\n    Finds the maximum sum of elements among all sublists in a given list of lists.\n    \n    Parameters:\n    - list_of_lists (list of lists): A list containing multiple sublists of integers.\n    \n    Returns:\n    - int: The maximum sum of elements found in any of the sublists.\n    \"\"\"\n    max_sum = float('-inf')  # Initialize with negative infinity to handle negative numbers as well\n    \n    for sublist in list_of_lists:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n# Example usage:\nexample_list_of_lists = [[1, 2, 3], [4, 5, 6], [-7, -8, 9], [0]]\nprint(maximum_sum(example_list_of_lists))  # Output should be 15 (from the sublist [4, 5, 6])\n", "result": "passed", "passed": true}
{"task_id": 25, "requirement": "Input-Output Conditions", "completion": "from collections import Counter\n\ndef find_product(arr):\n    # Count the frequency of each element in the array\n    freq = Counter(arr)\n    \n    # Initialize the product variable\n    product = 1\n    # Flag to check if there are any non-repeated elements\n    has_non_repeated_elements = False\n    \n    # Iterate through the frequency dictionary\n    for element, count in freq.items():\n        if count == 1:\n            product *= element\n            has_non_repeated_elements = True\n    \n    # If no non-repeated elements were found, return 0 or handle appropriately\n    if not has_non_repeated_elements:\n        return 0\n    \n    return product\n\n# Example usage:\narr = [2, 3, 4, 5, 6, 3, 4]\nprint(find_product(arr))  # Output should be 2 * 5 * 6 = 60\n\narr = [1, 1, 1, 1]\nprint(find_product(arr))  # Output should be 0 since there are no non-repeated elements\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpye1l35z1.py\", line 23, in <module>\n    assert find_product([1,1,2,3],4) == 6\nTypeError: find_product() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 26, "requirement": "Input-Output Conditions", "completion": "def check_k_elements(tuples_list, k):\n    \"\"\"\n    Checks if all tuples in the list contain exactly k elements.\n    \n    :param tuples_list: List of tuples to be checked.\n    :param k: The exact number of elements each tuple should contain.\n    :return: True if all tuples contain exactly k elements, False otherwise.\n    \"\"\"\n    for tup in tuples_list:\n        if len(tup) != k:\n            return False\n    return True\n\n# Example usage:\ntuples_list = [(1, 2), (3, 4), (5, 6)]\nk = 2\nprint(check_k_elements(tuples_list, k))  # Output: True\n\ntuples_list = [(1, 2), (3, 4, 5), (5, 6)]\nk = 2\nprint(check_k_elements(tuples_list, k))  # Output: False\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpfvya7vr3.py\", line 13, in <module>\n    assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == True\nAssertionError", "passed": false}
{"task_id": 28, "requirement": "Input-Output Conditions", "completion": "def binomial_coeff(n, k):\n    \"\"\"\n    Calculate the binomial coefficient C(n, k).\n\n    Parameters:\n    n (int): The total number of items.\n    k (int): The number of items to choose.\n\n    Returns:\n    int: The binomial coefficient C(n, k).\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    # Ensure k is the smaller of the two to optimize calculation\n    if k > n - k:\n        k = n - k\n\n    result = 1\n    for i in range(k):\n        result *= (n - i)\n        result //= (i + 1)\n    \n    return result\n\n# Example usage:\nprint(binomial_coeff(5, 2))  # Output: 10\nprint(binomial_coeff(10, 3)) # Output: 120\nprint(binomial_coeff(10, 7)) # Output: 120, equivalent to binomial_coeff(10, 3)\n", "result": "passed", "passed": true}
{"task_id": 30, "requirement": "Input-Output Conditions", "completion": "from collections import Counter\n\ndef count_substring_with_equal_ends(s):\n    \"\"\"\n    Counts all substrings starting and ending with the same character.\n    \n    :param s: Input string\n    :return: Number of substrings starting and ending with the same character\n    \"\"\"\n    # Count the frequency of each character in the string\n    char_count = Counter(s)\n    \n    # Calculate the number of substrings for each character\n    count = sum((freq * (freq + 1)) // 2 for freq in char_count.values())\n    \n    return count\n\n# Example usage:\nprint(count_substring_with_equal_ends(\"abcab\"))  # Output: 7\n", "result": "passed", "passed": true}
{"task_id": 32, "requirement": "Input-Output Conditions", "completion": "def max_prime_factors(n):\n    if not isinstance(n, int) or n < 2:\n        raise ValueError(\"Input must be a positive integer greater than 1.\")\n    \n    max_prime = -1\n    \n    # Divide n by 2 to remove all factors of 2\n    while n % 2 == 0:\n        max_prime = 2\n        n //= 2\n    \n    # Now n must be odd, start checking for odd factors\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            max_prime = factor\n            n //= factor\n        factor += 2\n    \n    # If n is a prime number greater than 2\n    if n > 2:\n        max_prime = n\n    \n    return max_prime\n\n# Example usage:\nprint(max_prime_factors(13195))  # Output: 29\nprint(max_prime_factors(2048))   # Output: 2\n", "result": "passed", "passed": true}
{"task_id": 35, "requirement": "Input-Output Conditions", "completion": "def find_rect_num(n):\n    \"\"\"\n    Calculate the n-th rectangular number.\n\n    :param n: An integer representing the position in the sequence of rectangular numbers.\n    :return: The n-th rectangular number.\n    \"\"\"\n    return n * (n + 1)\n", "result": "passed", "passed": true}
{"task_id": 36, "requirement": "Input-Output Conditions", "completion": "def find_nth_digit(dividend, divisor, n):\n    # Edge case: If the divisor is zero, return an error code (or raise an exception)\n    if divisor == 0:\n        return -1\n    \n    # Handle the integer part first\n    quotient, remainder = divmod(dividend, divisor)\n    \n    # Convert the remainder into a string representation to process the decimal part\n    decimal_part = []\n    seen_remainders = {}\n    \n    # Process the decimal part until we encounter a repeated remainder (indicating a repeating sequence) or find the nth digit\n    while remainder != 0 and len(seen_remainders) < 100:  # Limiting the number of iterations to prevent infinite loops\n        if remainder in seen_remainders:\n            # If a repeating sequence is detected, return -1 (or an appropriate error indicator)\n            return -1\n        \n        seen_remainders[remainder] = len(decimal_part)\n        \n        remainder *= 10\n        digit, remainder = divmod(remainder, divisor)\n        decimal_part.append(str(digit))\n        \n        # If we've found the nth digit, return it\n        if len(decimal_part) >= n:\n            return int(decimal_part[n - 1])\n    \n    # If we exit the loop without finding the nth digit, return -1 (or an appropriate error indicator)\n    return -1\n\n# Examples\nprint(find_nth_digit(1, 2, 1))  # Should return 5 because 1/2 = 0.5 and the 1st digit is 5\nprint(find_nth_digit(2, 3, 2))  # Should return 6 because 2/3 = 0.666... and the 2nd digit is 6\nprint(find_nth_digit(1, 7, 3))  # Should return 2 because 1/7 = 0.142857... and the 3rd digit is 2\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpt4hwkf6x.py\", line 30, in <module>\n    assert find_nth_digit(5,6,5) == 3\nAssertionError", "passed": false}
{"task_id": 38, "requirement": "Input-Output Conditions", "completion": "def div_even_odd(numbers):\n    \"\"\"\n    Divides the first even number by the first odd number in the given list.\n    \n    :param numbers: List of integers.\n    :return: The division result of the first even number by the first odd number as a float or int.\n             Returns None if there's no even or odd number in the list.\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    for num in numbers:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        elif first_odd is None and num % 2 != 0:\n            first_odd = num\n        \n        # Once both first even and first odd are found, break the loop\n        if first_even is not None and first_odd is not None:\n            break\n    \n    # Check if both first even and first odd were found\n    if first_even is None or first_odd is None:\n        return None\n    \n    # Perform the division\n    result = first_even / first_odd\n    \n    # Return the result as a float or int, depending on the values\n    return float(result) if result % 1 != 0 else int(result)\n\n# Example usage:\nprint(div_even_odd([5, 3, 2, 8]))  # Output should be 2 (2/1, which is an integer)\nprint(div_even_odd([2, 4, 6]))     # Output should be None (no odd number)\nprint(div_even_odd([1, 3, 5]))     # Output should be None (no even number)\n", "result": "passed", "passed": true}
{"task_id": 39, "requirement": "Input-Output Conditions", "completion": "from collections import Counter\n\ndef rearrange_string(s):\n    # Step 1: Count the frequency of each character\n    char_count = Counter(s)\n    \n    # Step 2: Sort characters by their frequency (descending order)\n    sorted_chars = sorted(char_count.items(), key=lambda x: -x[1])\n    \n    # Initialize the result list with the most frequent character\n    result = [sorted_chars[0][0]]\n    used_char = sorted_chars[0][0]\n    sorted_chars[0] = (used_char, char_count[used_char] - 1)\n    \n    # Continue building the result list\n    while sorted_chars:\n        placed = False\n        for i, (char, count) in enumerate(sorted_chars):\n            if char != used_char:\n                # Add the character to the result\n                result.append(char)\n                used_char = char\n                # Decrease the count\n                sorted_chars[i] = (char, count - 1)\n                \n                # Remove the character from the list if its count becomes zero\n                if count - 1 == 0:\n                    del sorted_chars[i]\n                    \n                placed = True\n                break\n        \n        if not placed:\n            # If we couldn't find a suitable character to add, return an empty string\n            return \"\"\n        \n    # Join the list into a string\n    return ''.join(result)\n\n# Example usage:\nprint(rearrange_string(\"aab\"))       # Output: \"aba\"\nprint(rearrange_string(\"aaab\"))      # Output: \"\"\nprint(rearrange_string(\"abcabc\"))    # Output: \"abacbc\" (or any valid permutation)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmppaltyblz.py\", line 35, in <module>\n    assert rearange_string(\"aab\")==('aba')\nNameError: name 'rearange_string' is not defined", "passed": false}
{"task_id": 42, "requirement": "Input-Output Conditions", "completion": "def find_sum(arr):\n    \"\"\"\n    Finds the sum of all repeated elements in a given list.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    int: The sum of all repeated elements in the list. Returns 0 if there are no repeated elements.\n    \"\"\"\n    # Dictionary to store the count of each element\n    element_count = {}\n    \n    # Iterate through the list to populate the dictionary with counts\n    for element in arr:\n        if element in element_count:\n            element_count[element] += 1\n        else:\n            element_count[element] = 1\n    \n    # Calculate the sum of elements that appear more than once\n    repeated_sum = sum(element * (count - 1) for element, count in element_count.items() if count > 1)\n    \n    return repeated_sum\n\n# Example usage:\nexample_list = [1, 2, 3, 2, 3, 4, 5, 3]\nprint(find_sum(example_list))  # Output will be 8 because 2 appears twice (2*1=2) and 3 appears three times (3*2=6), total is 8\n\nexample_list_no_repeats = [1, 2, 3, 4, 5]\nprint(find_sum(example_list_no_repeats))  # Output will be 0 as there are no repeated elements\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpf6tp9xh2.py\", line 18, in <module>\n    assert find_sum([1,2,3,1,1,4,5,6],8) == 3\nTypeError: find_sum() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 43, "requirement": "Input-Output Conditions", "completion": "import re\n\ndef text_match(text):\n    # Define the regex pattern to match sequences of lowercase letters joined with an underscore\n    pattern = r'\\b[a-z]+_[a-z]+\\b'\n    \n    # Find all occurrences of the pattern in the provided text\n    matches = re.findall(pattern, text)\n    \n    # Check if any matches were found\n    if matches:\n        return matches\n    else:\n        return 'Not matched!'\n\n# Example usage:\nsample_text = \"this_is_a_sample_text with_multiple_matches_like_this_one_and_another_example\"\nno_match_text = \"no underscore sequences here\"\n\nprint(text_match(sample_text))  # Should print the list of matches\nprint(text_match(no_match_text))  # Should print 'Not matched!'\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpw4jut_cm.py\", line 17, in <module>\n    assert text_match(\"aab_cbbbc\") == 'Found a match!'\nAssertionError", "passed": false}
{"task_id": 46, "requirement": "Input-Output Conditions", "completion": "def test_distinct(numbers):\n    \"\"\"\n    Check if all numbers in the given list are distinct.\n\n    Args:\n    - numbers: A list of integers.\n\n    Returns:\n    - True if all numbers are distinct, False otherwise.\n    \"\"\"\n    return len(numbers) == len(set(numbers))\n\n# Example usage:\nprint(test_distinct([1, 2, 3, 4]))  # Should print True\nprint(test_distinct([1, 2, 2, 3]))  # Should print False\nprint(test_distinct([5, 6, 7, 8, 9]))  # Should print True\nprint(test_distinct([10, 10, 11, 12]))  # Should print False\n", "result": "passed", "passed": true}
{"task_id": 48, "requirement": "Input-Output Conditions", "completion": "def odd_bit_set_number(n):\n    \"\"\"\n    Set all odd bits of the given integer n to 1.\n    \n    Args:\n    - n (int): The input integer whose odd bits are to be set.\n    \n    Returns:\n    - int: The modified integer with all odd bits set to 1.\n    \"\"\"\n    # Create a mask with all odd bits set to 1\n    # This can be done by creating a sequence of 1s and 0s in a pattern that sets odd bits to 1\n    mask = 0\n    bit_position = 1\n    while bit_position <= n.bit_length():\n        mask |= (1 << (bit_position - 1))\n        bit_position += 2\n    \n    # Apply the mask to set the odd bits of n\n    result = n | mask\n    \n    return result\n\n# Example usage:\nprint(bin(odd_bit_set_number(10)))  # Example input: 10 (binary: 1010)\n", "result": "passed", "passed": true}
{"task_id": 49, "requirement": "Input-Output Conditions", "completion": "def specified_element(two_dim_list, index):\n    \"\"\"\n    Extracts the element at the specified index from each sub-list of a two-dimensional list.\n    \n    :param two_dim_list: A two-dimensional list (list of lists)\n    :param index: The index of the element to extract from each sub-list\n    :return: A list containing the extracted elements or an empty list if the input is empty\n    \"\"\"\n    # Initialize an empty list to store the extracted elements\n    extracted_elements = []\n    \n    # Check if the input list is empty\n    if not two_dim_list:\n        return extracted_elements\n    \n    # Iterate through each sub-list in the two-dimensional list\n    for sublist in two_dim_list:\n        # Extract the element at the specified index if within bounds, otherwise skip\n        if 0 <= index < len(sublist):\n            extracted_elements.append(sublist[index])\n    \n    return extracted_elements\n\n# Example usage:\ntwo_dim_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nindex = 1  # We want to extract the second element (index 1) from each sublist\nprint(specified_element(two_dim_list, index))  # Output: [2, 5, 8]\n\nempty_list = []\nprint(specified_element(empty_list, 0))  # Output: []\n", "result": "passed", "passed": true}
{"task_id": 50, "requirement": "Input-Output Conditions", "completion": "def min_length_list(lists):\n    # Find the list with the minimum length using the min function and a lambda key\n    shortest_list = min(lists, key=lambda x: len(x))\n    # Return a tuple containing the length of the shortest list and the list itself\n    return (len(shortest_list), shortest_list)\n\n# Example usage:\nlists = [[1, 2, 3], [4, 5], [6], [7, 8, 9, 10]]\nresult = min_length_list(lists)\nprint(result)  # Output: (1, [6])\n", "result": "passed", "passed": true}
{"task_id": 52, "requirement": "Input-Output Conditions", "completion": "def parallelogram_area(base, height):\n    \"\"\"\n    Calculate the area of a parallelogram.\n    \n    Parameters:\n    base (float): The length of the base of the parallelogram. Must be a positive number.\n    height (float): The height of the parallelogram, measured perpendicularly from the base. Must be a positive number.\n    \n    Returns:\n    float: The area of the parallelogram.\n    \n    Raises:\n    ValueError: If either base or height is not a positive number.\n    \"\"\"\n    if base <= 0 or height <= 0:\n        raise ValueError(\"Both base and height must be positive numbers.\")\n    \n    area = base * height\n    return area\n\n# Example usage:\ntry:\n    base = 5.0\n    height = 3.0\n    area = parallelogram_area(base, height)\n    print(f\"The area of the parallelogram with base {base} and height {height} is {area}\")\nexcept ValueError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmppcoonxjl.py\", line 18, in <module>\n    assert parallelogram_area(0, 10) == 0\n  File \"/tmp/tmppcoonxjl.py\", line 3, in parallelogram_area\n    raise ValueError(\"Both base and height must be positive numbers.\")\nValueError: Both base and height must be positive numbers.", "passed": false}
{"task_id": 53, "requirement": "Input-Output Conditions", "completion": "def check_equality(s):\n    \"\"\"\n    Check if the first and last characters of the string s are equal.\n    \n    :param s: Input string\n    :return: 'Equal' if the first and last characters are the same, 'Not Equal' otherwise\n    \"\"\"\n    # Check if the input is a string\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string.\")\n    \n    # Check if the string is empty or has only one character\n    if len(s) <= 1:\n        return 'Equal'\n    \n    # Compare the first and last character\n    if s[0] == s[-1]:\n        return 'Equal'\n    else:\n        return 'Not Equal'\n\n# Example usage:\nprint(check_equality(\"radar\"))  # Should print 'Equal'\nprint(check_equality(\"hello\"))  # Should print 'Not Equal'\nprint(check_equality(\"a\"))      # Should print 'Equal'\n", "result": "passed", "passed": true}
{"task_id": 54, "requirement": "Input-Output Conditions", "completion": "def counting_sort(arr):\n    # Check if the input list is empty or None\n    if not arr:\n        return arr\n    \n    # Verify that all elements in the list are non-negative integers\n    if not all(isinstance(x, int) and x >= 0 for x in arr):\n        raise ValueError(\"All elements in the list must be non-negative integers.\")\n    \n    # Find the maximum value in the array\n    max_val = max(arr)\n    \n    # Initialize count array with zeros\n    count_arr = [0] * (max_val + 1)\n    \n    # Store the count of each element in count_arr\n    for num in arr:\n        count_arr[num] += 1\n    \n    # Modify count_arr such that each element at each index\n    # stores the sum of previous counts\n    for i in range(1, len(count_arr)):\n        count_arr[i] += count_arr[i - 1]\n    \n    # Output array that will have sorted arr\n    output_arr = [0] * len(arr)\n    \n    # Build the output array\n    for num in reversed(arr):\n        output_arr[count_arr[num] - 1] = num\n        count_arr[num] -= 1\n    \n    return output_arr\n\n# Example usage:\narr = [4, 2, 2, 8, 3, 3, 1]\nsorted_arr = counting_sort(arr)\nprint(\"Sorted array:\", sorted_arr)\n", "result": "passed", "passed": true}
{"task_id": 57, "requirement": "Input-Output Conditions", "completion": "from collections import Counter\n\ndef find_max_num(digits, num_digits):\n    # Count the frequency of each digit in the input list\n    digit_count = Counter(digits)\n    \n    # Initialize the result as a list to build the number\n    result = []\n    \n    # Start from the highest digit (9) and go down to the lowest (0)\n    for digit in range(9, -1, -1):\n        # Add the digit to the result as many times as its count allows, up to num_digits\n        while num_digits > 0 and digit_count[digit] > 0:\n            result.append(str(digit))\n            num_digits -= 1\n            digit_count[digit] -= 1\n    \n    # If we still have remaining digits to fill, add the smallest digits (0)\n    while num_digits > 0:\n        result.append('0')\n        num_digits -= 1\n    \n    # Join the list into a string and convert it to an integer\n    max_num = int(''.join(result))\n    \n    return max_num\n\n# Example usage:\ndigits = [5, 3, 7, 9, 0]\nnum_digits = 4\nprint(find_max_num(digits, num_digits))  # Output will be 9750\n", "result": "passed", "passed": true}
{"task_id": 58, "requirement": "Input-Output Conditions", "completion": "def opposite_signs(a, b):\n    \"\"\"\n    Check if two integers have opposite signs.\n\n    Args:\n    a (int): The first integer.\n    b (int): The second integer.\n\n    Returns:\n    bool: True if the integers have opposite signs, False otherwise.\n\n    Raises:\n    TypeError: If either input is not an integer.\n    \"\"\"\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError(\"Both inputs must be integers.\")\n    \n    return a * b < 0\n\n# Example usage:\ntry:\n    print(opposite_signs(1, -2))  # Should print True\n    print(opposite_signs(-1, -2)) # Should print False\nexcept TypeError as e:\n    print(e)\n", "result": "passed", "passed": true}
{"task_id": 60, "requirement": "Input-Output Conditions", "completion": "def max_len_sub(arr):\n    if not arr:\n        return 0\n    \n    # Dictionary to store the length of the longest subsequence ending at each value\n    dp = {}\n    \n    max_length = 1  # Initialize the maximum length to at least 1\n    \n    for num in arr:\n        # Check if there's a subsequence ending at num-1\n        length_from_left = dp.get(num - 1, 0) + 1\n        # Check if there's a subsequence ending at num+1\n        length_from_right = dp.get(num + 1, 0) + 1\n        \n        # Choose the longer one and add 1 for the current number itself\n        dp[num] = max(length_from_left, length_from_right)\n        \n        # Update the maximum length found so far\n        max_length = max(max_length, dp[num])\n    \n    return max_length\n\n# Example usage:\narr = [1, 2, 3, 4, 5, 3, 2, 1]\nprint(max_len_sub(arr))  # Output should be the length of the longest subsequence with the required property\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmproae0cja.py\", line 20, in <module>\n    assert max_len_sub([2, 5, 6, 3, 7, 6, 5, 8], 8) == 5\nTypeError: max_len_sub() takes 1 positional argument but 2 were given", "passed": false}
