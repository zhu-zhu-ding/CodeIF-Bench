{"task_id": 11, "requirement": "Code Complexity", "completion": "from typing import TypeVar, overload\n\nT = TypeVar('T', bound=str)\n\n@overload\ndef remove_occ(s: T, ch: str) -> T: ...\ndef remove_occ(s: str, ch: str) -> str:\n    \"\"\"\n    Removes the first and last occurrences of a given character from the string.\n    \n    :param s: The original string.\n    :param ch: The character to be removed.\n    :return: A new string with the first and last occurrences of the character removed.\n    \"\"\"\n    if len(ch) != 1:\n        raise ValueError(\"The character must be a single character.\")\n    \n    # Check if the character occurs more than once in the string\n    if s.count(ch) < 2:\n        return s\n    \n    # Find indices of the first and last occurrences\n    first_occurrence = s.find(ch)\n    last_occurrence = s.rfind(ch)\n    \n    # Construct the new string\n    new_string = s[:first_occurrence] + s[first_occurrence+1:last_occurrence] + s[last_occurrence+1:]\n    \n    return new_string\n\n# Example usage\nif __name__ == \"__main__\":\n    test_string = \"hello world\"\n    char_to_remove = \"l\"\n    print(remove_occ(test_string, char_to_remove))  # Output: \"heo word\"\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpas85tpv4.py\", line 25, in <module>\n    try: remove_occ('hello', 'll')\n  File \"/tmp/tmpas85tpv4.py\", line 7, in remove_occ\n    raise ValueError(\"The character must be a single character.\")\nValueError: The character must be a single character.\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpas85tpv4.py\", line 26, in <module>\n    except ValueError as e: assert str(e) == 'Second parameter must be a single character.'\nAssertionError", "passed": false}
{"task_id": 14, "requirement": "Code Complexity", "completion": "def find_volume(base_area: float, height: float, length: float) -> float:\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Parameters:\n    - base_area (float): The area of the triangular base.\n    - height (float): The height of the prism.\n    - length (float): The length of the prism.\n    \n    Returns:\n    float: The volume of the triangular prism.\n    \n    Raises:\n    ValueError: If any of the inputs are non-positive.\n    \"\"\"\n    # Validate inputs\n    if base_area <= 0 or height <= 0 or length <= 0:\n        raise ValueError('All dimensions must be positive numbers.')\n    \n    # Calculate the volume of the triangular prism\n    volume = base_area * height * length\n    \n    return volume\n\n# Example usage:\n# Find the volume of a triangular prism with a base area of 6 square units,\n# height of the prism of 5 units, and length of the prism of 7 units.\ntry:\n    volume = find_volume(6, 5, 7)\n    print(f\"The volume of the triangular prism is {volume} cubic units.\")\nexcept ValueError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpn1cvsbgf.py\", line 16, in <module>\n    assert find_volume(10,8,6) == 240\nAssertionError", "passed": false}
{"task_id": 15, "requirement": "Code Complexity", "completion": "import re\n\ndef split_lowerstring(text: str) -> list:\n    if not isinstance(text, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Use regex to split the string at each lowercase letter\n    # The pattern looks for positions where a lowercase letter is followed by a non-lowercase letter\n    split_strings = re.findall(r'[a-z](?![a-z])|[a-z]', text)\n    \n    return split_strings\n\n# Example usage:\nexample_string = \"aBcDeFgHiJkLmNoPqRsTuVwXyZ\"\nprint(split_lowerstring(example_string))\n", "result": "failed: File \"/tmp/tmpvf7xipjd.py\", line 16\n    try: split_lowerstring(123); assert False, 'Expected TypeError' except TypeError: pass\n                                                                    ^\nSyntaxError: invalid syntax", "passed": false}
{"task_id": 16, "requirement": "Code Complexity", "completion": "import re\n\ndef text_lowercase_underscore(text: str) -> str:\n    \"\"\"\n    Checks if the input string contains sequences of lowercase letters joined with an underscore.\n\n    :param text: A string to search within.\n    :return: 'Found a match!' if a sequence is found, 'Not matched!' otherwise.\n    :raises TypeError: If the input is not a string.\n    \"\"\"\n    if not isinstance(text, str):\n        raise TypeError(\"Input must be a string.\")\n    \n    # Define the regex pattern for finding sequences of lowercase letters joined with an underscore\n    pattern = r\"[a-z]+_[a-z]+\"\n    \n    # Check if there is any match\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n\n# Example usage:\ntry:\n    example_text = \"This_is_an_example_text_with_lower_case_words\"\n    print(text_lowercase_underscore(example_text))  # Should print 'Found a match!'\n    \n    example_text2 = \"NoMatchingPatternHere\"\n    print(text_lowercase_underscore(example_text2))  # Should print 'Not matched!'\n    \n    example_text3 = \"\"\n    print(text_lowercase_underscore(example_text3))  # Should print 'Not matched!'\nexcept TypeError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpmcjsppqg.py\", line 24, in <module>\n    assert text_lowercase_underscore(\"Aaab_abbbc\")==('Not matched!')\nAssertionError", "passed": false}
{"task_id": 17, "requirement": "Code Complexity", "completion": "def square_perimeter(a: int) -> int:\n    \"\"\"\n    Calculate the perimeter of a square.\n    \n    :param a: The length of one side of the square.\n    :return: The perimeter of the square.\n    \"\"\"\n    if a < 0:\n        raise ValueError(\"Side length must be a non-negative integer.\")\n    return 4 * a\n\n# Example usage:\ntry:\n    perimeter = square_perimeter(5)\n    print(\"The perimeter of the square is:\", perimeter)\nexcept ValueError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpbo6rft2s.py\", line 32, in <module>\n    assert cc_visit(inspect.getsource(square_perimeter))[0].complexity == 1\nAssertionError", "passed": false}
{"task_id": 20, "requirement": "Code Complexity", "completion": "from math import log2\n\ndef is_woodall(x: int) -> bool:\n    \"\"\"\n    Check if the given number is a Woodall number.\n    \n    A Woodall number is of the form n * 2^n - 1 for some positive integer n.\n    \n    :param x: Integer to check\n    :return: True if x is a Woodall number, False otherwise\n    \"\"\"\n    if not isinstance(x, int):\n        raise TypeError(\"Input must be an integer\")\n    \n    if x < 7:\n        return False\n    \n    # Compute potential n from the formula and check if it fits\n    potential_n = round(log2(x + 1))\n    return x == potential_n * 2**potential_n - 1\n\n# Example usage:\nprint(is_woodall(7))   # True, because 7 is 1*2^1-1\nprint(is_woodall(23))  # True, because 23 is 2*2^2-1\nprint(is_woodall(63))  # True, because 63 is 3*2^3-1\nprint(is_woodall(10))  # False\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpyt0ig9i7.py\", line 15, in <module>\n    assert is_woodall(383) == True\nAssertionError", "passed": false}
{"task_id": 21, "requirement": "Code Complexity", "completion": "def multiples_of_num(m: int, n: int) -> list:\n    \"\"\"\n    Generates the first m multiples of the number n.\n    \n    Raises:\n    ValueError: If either m or n is negative.\n    \n    Returns:\n    list: A list containing the first m multiples of n.\n    \"\"\"\n    return [] if m == 0 else ([i * n for i in range(1, m + 1)] if n > 0 else []) if m > 0 else []\n\n# Example usage:\nm = 5\nn = 3\nprint(multiples_of_num(m, n))  # Output: [3, 6, 9, 12, 15]\n\n# Test cases\nprint(multiples_of_num(0, 3))  # Output: []\nprint(multiples_of_num(-1, 3)) # Output: []\nprint(multiples_of_num(3, -2)) # Output: []\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpe16zagu0.py\", line 16, in <module>\n    else: assert False, 'Expected ValueError'\nAssertionError: Expected ValueError", "passed": false}
{"task_id": 24, "requirement": "Code Complexity", "completion": "def binary_to_decimal(binary: str) -> int:\n    \"\"\"\n    Convert a binary number (as a string) to its decimal equivalent.\n    \n    :param binary: A string representing a binary number.\n    :return: The decimal equivalent of the binary number.\n    \"\"\"\n    try:\n        # Check if the string is a valid binary number\n        if set(binary) - {'0', '1'}:\n            raise ValueError(\"Invalid binary number\")\n        return int(binary, 2)\n    except ValueError:\n        return 0 if binary == '' else raise ValueError(\"Invalid binary number\")\n\n# Example usage:\nprint(binary_to_decimal('1011'))  # Output should be 11\nprint(binary_to_decimal(''))      # Output should be 0\ntry:\n    print(binary_to_decimal('102'))\nexcept ValueError as e:\n    print(e)  # Output should be \"Invalid binary number\"\n", "result": "failed: File \"/tmp/tmp6rgo4aue.py\", line 8\n    return 0 if binary == '' else raise ValueError(\"Invalid binary number\")\n                                  ^\nSyntaxError: invalid syntax", "passed": false}
{"task_id": 32, "requirement": "Code Complexity", "completion": "from typing import Union\n\ndef max_prime_factors(n: int) -> int:\n    if not isinstance(n, int) or n < 2:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    # Handle the smallest prime number, 2\n    if n == 2:\n        return 2\n    \n    # Divide out all factors of 2\n    while n % 2 == 0:\n        n //= 2\n    \n    # Find odd factors\n    for factor in range(3, int(n**0.5) + 1, 2):\n        while n % factor == 0:\n            max_prime = factor\n            n //= factor\n    \n    # If n is a prime number greater than 2\n    if n > 2:\n        max_prime = n\n    \n    return max_prime\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpslovcrfk.py\", line 36, in <module>\n    assert cc_visit(inspect.getsource(max_prime_factors))[0].complexity <= 5\nAssertionError", "passed": false}
{"task_id": 33, "requirement": "Code Complexity", "completion": "from typing import Union\n\ndef decimal_to_binary(N: int) -> str:\n    \"\"\"\n    Convert a decimal number to its binary representation.\n    \n    Parameters:\n    - N (int): The decimal number to be converted.\n    \n    Returns:\n    - str: The binary representation of the decimal number.\n    \n    Raises:\n    - ValueError: If the input is not a non-negative integer.\n    \"\"\"\n    if not isinstance(N, int) or N < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    # Use built-in bin function and strip the '0b' prefix\n    binary_representation = bin(N)[2:]\n    \n    # Handle the edge case where the input is zero\n    if N == 0:\n        binary_representation = '0'\n    \n    return binary_representation\n\n# Example usage:\nprint(decimal_to_binary(10))  # Output: \"1010\"\nprint(decimal_to_binary(255)) # Output: \"11111111\"\nprint(decimal_to_binary(0))   # Output: \"0\"\ntry:\n    print(decimal_to_binary(-1))\nexcept ValueError as e:\n    print(e)  # Output: Input must be a non-negative integer.\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp3ebm46om.py\", line 19, in <module>\n    assert decimal_to_binary(10) == 1010\nAssertionError", "passed": false}
{"task_id": 35, "requirement": "Code Complexity", "completion": "def find_rect_num(n: int) -> int:\n    \"\"\"\n    Calculate the n-th rectangular number.\n    \n    :param n: An integer representing the position in the sequence of rectangular numbers.\n    :return: The n-th rectangular number.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    return n * (n + 1)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp4_zxxb4m.py\", line 16, in <module>\n    assert cc_visit(inspect.getsource(find_rect_num))[0].complexity == 1\nAssertionError", "passed": false}
{"task_id": 36, "requirement": "Code Complexity", "completion": "from typing import Tuple\n\ndef find_nth_digit(p: int, q: int, N: int) -> int:\n    \"\"\"\n    Finds the Nth digit in the decimal representation of p / q.\n    \n    Args:\n    p (int): Numerator.\n    q (int): Denominator.\n    N (int): Position of the digit in the decimal representation.\n    \n    Returns:\n    int: The Nth digit in the decimal representation of p / q.\n    \n    Raises:\n    ValueError: If the denominator q is zero.\n    ValueError: If N is less than 1.\n    ValueError: If N is greater than the length of the decimal part generated.\n    \"\"\"\n    \n    if q == 0:\n        raise ValueError(\"Denominator cannot be zero\")\n    if N < 1:\n        raise ValueError(\"N must be at least 1\")\n\n    # Whole part of the division\n    whole_part = p // q\n\n    # Start generating the decimal part\n    remainder = p % q\n    decimal_part = \"\"\n\n    # Generate decimal part up to the required digit\n    for _ in range(N):\n        remainder *= 10\n        new_digit = remainder // q\n        decimal_part += str(new_digit)\n        remainder %= q\n\n        # If remainder becomes zero, the decimal part is finite\n        if remainder == 0:\n            break\n\n    # Check if we have enough digits in the decimal part\n    if len(decimal_part) < N:\n        raise ValueError(f\"Nth digit ({N}) exceeds the length of the decimal part.\")\n\n    # Return the Nth digit\n    return int(decimal_part[N-1])\n\n# Example usage:\ntry:\n    print(find_nth_digit(1, 2, 3))  # Should print 0\n    print(find_nth_digit(2, 3, 5))  # Should print 6\nexcept ValueError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpu58b8hpk.py\", line 43, in <module>\n    assert cc_visit(inspect.getsource(find_nth_digit))[0].complexity <= 5\nAssertionError", "passed": false}
{"task_id": 38, "requirement": "Code Complexity", "completion": "from typing import List\n\ndef div_even_odd(numbers: List[int]) -> float:\n    \"\"\"\n    Divides the first even number by the first odd number in the given list.\n    \n    :param numbers: List of integers.\n    :return: The division result of the first even number by the first odd number.\n             Raises ValueError if the list does not contain at least one even and one odd number.\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    for num in numbers:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        if num % 2 != 0 and first_odd is None:\n            first_odd = num\n        \n        if first_even is not None and first_odd is not None:\n            break\n    \n    if first_even is None or first_odd is None:\n        raise ValueError(\"List must contain at least one even and one odd number.\")\n    \n    # Handle division by zero\n    if first_odd == 0:\n        return 0\n    \n    return first_even / first_odd\n\n# Example usage:\ntry:\n    print(div_even_odd([5, 3, 2, 8]))  # Output should be 2.0\n    print(div_even_odd([2, 4, 6]))     # Raises ValueError\n    print(div_even_odd([1, 3, 5]))     # Raises ValueError\nexcept ValueError as e:\n    print(e)\n", "result": "failed: File \"/tmp/tmpqm2d9yor.py\", line 29\n    try: div_even_odd([2, 4, 6]); assert False; except ValueError as e: assert str(e) == 'List must contain at least one even and one odd number.'\n                                                ^\nSyntaxError: invalid syntax", "passed": false}
{"task_id": 40, "requirement": "Code Complexity", "completion": "from collections import Counter\n\ndef freq_element(nums: list[list[int]]) -> dict[int, int]:\n    # Validate input type\n    if not isinstance(nums, list) or not all(isinstance(sublist, list) for sublist in nums):\n        raise TypeError(\"Input must be a list of lists\")\n    \n    # Return an empty dictionary if the input list is empty\n    if not nums:\n        return {}\n    \n    # Flatten the list of lists and calculate the frequency\n    return Counter([item for sublist in nums for item in sublist])\n", "result": "failed: File \"/tmp/tmp0cv898wb.py\", line 14\n    try: freq_element('not a list'); assert False; except TypeError: assert True\n                                                   ^\nSyntaxError: invalid syntax", "passed": false}
{"task_id": 42, "requirement": "Code Complexity", "completion": "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    \"\"\"\n    Finds the sum of all repeated elements in a given list.\n    \n    Parameters:\n    arr (List[int]): A list of integers.\n    \n    Returns:\n    int: The sum of all repeated elements in the list.\n    \n    Raises:\n    TypeError: If the input is not a list.\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list\")\n    \n    # Dictionary to store the count of each element\n    element_count = {}\n    repeated_sum = 0\n    \n    # Iterate through the list to populate the dictionary with counts\n    for element in arr:\n        if element in element_count:\n            element_count[element] += 1\n        else:\n            element_count[element] = 1\n    \n    # Calculate the sum of elements that appear more than once\n    for element, count in element_count.items():\n        if count > 1:\n            repeated_sum += element * (count - 1)\n    \n    return repeated_sum\n\n# Example usage:\nexample_list = [1, 2, 3, 2, 3, 4, 5, 3]\nprint(find_sum(example_list))  # Output will be 8 because 2 appears twice (2*1=2) and 3 appears twice (3*2=6), total is 2+6=8\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp5hshuiv6.py\", line 22, in <module>\n    assert find_sum([1,2,3,1,1,4,5,6],8) == 3\nTypeError: find_sum() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 43, "requirement": "Code Complexity", "completion": "import re\n\ndef text_match(text: str) -> str:\n    \"\"\"\n    Searches for sequences of lowercase letters joined with an underscore in the given text.\n    \n    Args:\n        text: A string to search within.\n        \n    Returns:\n        A string indicating whether any matches were found.\n    \"\"\"\n    # Ensure the input is a non-empty string\n    if not isinstance(text, str) or len(text) == 0:\n        return 'Not matched!'\n    \n    # Define the regex pattern to match sequences of lowercase letters joined with an underscore\n    pattern = r'\\b[a-z]+_[a-z]+\\b'\n    \n    # Find all occurrences of the pattern in the provided text\n    matches = re.findall(pattern, text)\n    \n    # If any matches are found, return them; otherwise, return 'Not matched!'\n    return ', '.join(matches) if matches else 'Not matched!'\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpkfqqu_4s.py\", line 12, in <module>\n    assert text_match(\"aab_cbbbc\") == 'Found a match!'\nAssertionError", "passed": false}
{"task_id": 45, "requirement": "Code Complexity", "completion": "from math import gcd\n\ndef get_gcd(numbers: list[int]) -> int:\n    \"\"\"\n    Find the greatest common divisor (GCD) of all elements in the given list of integers.\n    \n    :param numbers: List[int] - A list of positive integers.\n    :return: int - The GCD of all elements in the list.\n    :raises ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError('Input list cannot be empty.')\n    \n    # Initialize gcd_result with the first element of the list\n    gcd_result = numbers[0]\n    \n    # Iterate through the list starting from the second element\n    for num in numbers[1:]:\n        gcd_result = gcd(gcd_result, num)\n        \n    return gcd_result\n\n# Example usage:\ntry:\n    numbers = [8, 12, 24]\n    print(\"The GCD of\", numbers, \"is:\", get_gcd(numbers))\nexcept ValueError as e:\n    print(e)\n\ntry:\n    numbers = []\n    print(\"The GCD of\", numbers, \"is:\", get_gcd(numbers))\nexcept ValueError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpojusnuwq.py\", line 27, in <module>\n    assert get_gcd.__annotations__ == {'numbers': list, 'return': int}\nAssertionError", "passed": false}
{"task_id": 47, "requirement": "Code Complexity", "completion": "def compute_last_digit(a: int, b: int) -> int:\n    if a > b:\n        raise ValueError('a should not be greater than b')\n    elif a == b:\n        return 1\n    \n    # Factorials of numbers >= 5 end with 0, so the last digit of the division is influenced only by smaller numbers.\n    last_digits = [1, 1, 2, 6, 4]  # Last digits of 0!, 1!, 2!, 3!, 4!\n    \n    # Compute the last digit of a! and b! using precomputed values for small numbers.\n    last_digit_a = last_digits[a] if a < 5 else 0\n    last_digit_b = last_digits[b] if b < 5 else 0\n    \n    # Handle division of last digits.\n    if last_digit_b == 0:\n        return 0  # Division by zero case\n    else:\n        return (last_digit_a // last_digit_b) % 10\n\n# Example usage:\ntry:\n    print(compute_last_digit(3, 5))  # Example output\nexcept ValueError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmph8tpe575.py\", line 21, in <module>\n    assert compute_last_digit(2,4) == 2\nAssertionError", "passed": false}
{"task_id": 51, "requirement": "Code Complexity", "completion": "def check_equilateral(a: int, b: int, c: int) -> bool:\n    \"\"\"\n    Check if a triangle with sides a, b, and c is equilateral.\n\n    Parameters:\n    a (int): Length of the first side of the triangle.\n    b (int): Length of the second side of the triangle.\n    c (int): Length of the third side of the triangle.\n\n    Returns:\n    bool: True if the triangle is equilateral, False otherwise.\n\n    Raises:\n    ValueError: If any input is a non-positive integer.\n    \"\"\"\n    if a <= 0 or b <= 0 or c <= 0:\n        raise ValueError(\"All sides must be positive integers.\")\n    \n    return a == b == c\n\n# Example usage:\ntry:\n    if check_equilateral(5, 5, 5):\n        print(\"The triangle is equilateral.\")\n    else:\n        print(\"The triangle is not equilateral.\")\nexcept ValueError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp65s97v3l.py\", line 32, in <module>\n    assert cc_visit(inspect.getsource(check_equilateral))[0].complexity ==1\nAssertionError", "passed": false}
{"task_id": 52, "requirement": "Code Complexity", "completion": "def parallelogram_area(base: float, height: float) -> float:\n    \"\"\"\n    Calculate the area of a parallelogram.\n\n    Parameters:\n    base (float): The length of the base of the parallelogram.\n    height (float): The height of the parallelogram, measured perpendicularly from the base.\n\n    Returns:\n    float: The area of the parallelogram.\n    \"\"\"\n    return base * height\n\ndef validate_and_calculate(base, height):\n    if not isinstance(base, (int, float)) or not isinstance(height, (int, float)):\n        raise TypeError(\"Both base and height must be numerical values.\")\n    \n    if base < 0 or height < 0:\n        raise ValueError(\"Base and height must be positive numerical values.\")\n    \n    return parallelogram_area(base, height)\n\n# Example usage:\ntry:\n    base = 5.0\n    height = 3.0\n    area = validate_and_calculate(base, height)\n    print(f\"The area of the parallelogram with base {base} and height {height} is {area}\")\nexcept TypeError as e:\n    print(e)\nexcept ValueError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpet8gi33c.py\", line 28, in <module>\n    assert False, 'Expected TypeError'\nAssertionError: Expected TypeError", "passed": false}
{"task_id": 53, "requirement": "Code Complexity", "completion": "def check_equality(s: str) -> str:\n    \"\"\"\n    Checks if the first and last characters of the string s are equal.\n\n    :param s: Input string\n    :return: 'Equal' if the first and last characters are the same, 'Not Equal' otherwise\n    :raises TypeError: If the input is not a string\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError('Input must be a string')\n    \n    try:\n        # Check if the first and last characters are equal\n        if s[0] == s[-1]:\n            return 'Equal'\n        else:\n            return 'Not Equal'\n    except IndexError:\n        # Handle empty string or single character string\n        return 'Equal'\n\n# Example usage:\nprint(check_equality(\"radar\"))   # Should print 'Equal'\nprint(check_equality(\"hello\"))   # Should print 'Not Equal'\nprint(check_equality(\"a\"))       # Should print 'Equal'\nprint(check_equality(\"\"))        # Should print 'Equal'\ntry:\n    print(check_equality(123))   # Should raise TypeError\nexcept TypeError as e:\n    print(e)                     # Should print 'Input must be a string'\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp1qykt69a.py\", line 36, in <module>\n    assert cc_visit(inspect.getsource(check_equality))[0].complexity <=3\nAssertionError", "passed": false}
{"task_id": 56, "requirement": "Code Complexity", "completion": "def reverse_number(n: int) -> int:\n    \"\"\"Helper function to reverse the digits of a number.\"\"\"\n    return int(str(n)[::-1])\n\ndef check(n: int) -> bool:\n    \"\"\"\n    Function to check if a given number is one less than twice its reverse.\n    \n    Parameters:\n    - n: An integer\n    \n    Returns:\n    - True if the number is one less than twice its reverse, False otherwise.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n    \n    reversed_num = reverse_number(n)\n    doubled_reversed = 2 * reversed_num\n    one_less_than_twice_reverse = doubled_reversed - 1\n    \n    # Perform the check without explicit branching\n    return bool(n == one_less_than_twice_reverse)\n\n# Example usage:\nprint(check(47))   # Should return True because 2*74 - 1 = 147\nprint(check(83))   # Should return False\nprint(check('56')) # Should raise TypeError\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpqhnm3u68.py\", line 15, in <module>\n    print(check('56')) # Should raise TypeError\n  File \"/tmp/tmpqhnm3u68.py\", line 6, in check\n    raise TypeError(\"Input must be an integer\")\nTypeError: Input must be an integer", "passed": false}
{"task_id": 58, "requirement": "Code Complexity", "completion": "def opposite_signs(a: int, b: int) -> bool:\n    \"\"\"\n    Check if two integers have opposite signs.\n\n    Args:\n    a (int): The first integer.\n    b (int): The second integer.\n\n    Returns:\n    bool: True if the integers have opposite signs, False otherwise.\n    \"\"\"\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError(\"Both inputs must be integers.\")\n    \n    return (a * b) < 0\n\n# Example usage:\nprint(opposite_signs(1, -2))   # Should print True\nprint(opposite_signs(-1, -2))  # Should print False\nprint(opposite_signs(0, 5))    # Should print False\nprint(opposite_signs(0, -5))   # Should print True\ntry:\n    print(opposite_signs(1.5, 2))\nexcept TypeError as e:\n    print(e)                   # Should print \"Both inputs must be integers.\"\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpiap3vxxn.py\", line 32, in <module>\n    assert opposite_signs(0, -1) == True\nAssertionError", "passed": false}
