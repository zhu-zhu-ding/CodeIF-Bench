{"task_id": 11, "requirement": "Code Complexity", "completion": "def remove_occ(s: str, ch: str) -> str:\n    # Check if the second parameter is a single character\n    if not isinstance(ch, str) or len(ch) != 1:\n        raise ValueError(\"Second parameter must be a single character.\")\n\n    # Find the indices of the first and last occurrences\n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n\n    # If the character doesn't exist in the string, return the original string\n    if first_index == -1 or last_index == -1:\n        return s\n\n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n\n    # Recalculate the last index after removing the first occurrence\n    last_index = s.rfind(ch)\n\n    # Remove the last occurrence\n    s = s[:last_index] + s[last_index + 1:]\n\n    return s\n", "result": "passed", "passed": true}
{"task_id": 14, "requirement": "Code Complexity", "completion": "def find_volume(base_area: float, height: float, length: float) -> float:\n    \"\"\"\n    Calculate the volume of a triangular prism.\n\n    Parameters:\n    base_area (float): The area of the triangular base.\n    height (float): The height of the triangular prism.\n    length (float): The length of the triangular prism.\n\n    Returns:\n    float: The volume of the triangular prism.\n\n    Raises:\n    ValueError: If any of the inputs are non-positive or non-numeric.\n    \"\"\"\n    # Ensure all inputs are positive numbers\n    if not (isinstance(base_area, (int, float)) and base_area > 0):\n        raise ValueError(\"All dimensions must be positive numbers.\")\n    if not (isinstance(height, (int, float)) and height > 0):\n        raise ValueError(\"All dimensions must be positive numbers.\")\n    if not (isinstance(length, (int, float)) and length > 0):\n        raise ValueError(\"All dimensions must be positive numbers.\")\n\n    # Calculate the volume\n    volume = base_area * height * length\n    return volume\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpxe2g92v7.py\", line 12, in <module>\n    assert find_volume(10,8,6) == 240\nAssertionError", "passed": false}
{"task_id": 15, "requirement": "Code Complexity", "completion": "import re\nfrom typing import List\n\ndef split_lowerstring(text: str) -> List[str]:\n    \"\"\"\n    Splits a string at lowercase letters.\n\n    Args:\n        text (str): The input string to be split.\n\n    Returns:\n        List[str]: A list of strings, each representing a segment of the original string split at lowercase letters.\n\n    Raises:\n        TypeError: If the input is not a string.\n    \"\"\"\n    if not isinstance(text, str):\n        raise TypeError(\"Input must be a string.\")\n    \n    # Use regex to split the string at lowercase letters\n    return re.split('[a-z]', text)\n\n# Example usage:\ninput_string = \"HelloWorldPython\"\nresult = split_lowerstring(input_string)\nprint(result)  # Output: ['H', 'W', 'P']\n", "result": "failed: File \"/tmp/tmp73kik67s.py\", line 16\n    try: split_lowerstring(123); assert False, 'Expected TypeError' except TypeError: pass\n                                                                    ^\nSyntaxError: invalid syntax", "passed": false}
{"task_id": 16, "requirement": "Code Complexity", "completion": "import re\nfrom typing import Union\n\ndef text_lowercase_underscore(text: str) -> str:\n    \"\"\"\n    Find sequences of lowercase letters joined with an underscore.\n\n    :param text: The input string to search for sequences.\n    :return: 'Found a match!' if a match is found, otherwise 'Not matched!'.\n    :raises TypeError: If the input is not a string.\n    \"\"\"\n    # Check if the input is a string\n    if not isinstance(text, str):\n        raise TypeError(\"Input must be a string.\")\n\n    # Regular expression pattern to match lowercase letters joined with an underscore\n    pattern = r'[a-z]+_[a-z]+'\n\n    # Use re.search to check if the pattern exists in the input\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n\n# Example usage:\nprint(text_lowercase_underscore(\"hello_world\"))  # Output: 'Found a match!'\nprint(text_lowercase_underscore(\"Hello_World\"))  # Output: 'Not matched!'\nprint(text_lowercase_underscore(\"123_abc\"))      # Output: 'Not matched!'\nprint(text_lowercase_underscore(\"\"))             # Output: 'Not matched!'\nprint(text_lowercase_underscore(\"test_example\")) # Output: 'Found a match!'\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp3094abzt.py\", line 22, in <module>\n    assert text_lowercase_underscore(\"Aaab_abbbc\")==('Not matched!')\nAssertionError", "passed": false}
{"task_id": 17, "requirement": "Code Complexity", "completion": "def square_perimeter(a: int) -> int:\n    \"\"\"\n    Calculate the perimeter of a square.\n\n    Parameters:\n    a (int): The length of one side of the square. Must be a non-negative integer.\n\n    Returns:\n    int: The perimeter of the square.\n\n    Raises:\n    ValueError: If the input `a` is negative.\n    \"\"\"\n    if a < 0:\n        raise ValueError(\"Side length must be a non-negative integer.\")\n    return 4 * a\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp8biueqcw.py\", line 26, in <module>\n    assert cc_visit(inspect.getsource(square_perimeter))[0].complexity == 1\nAssertionError", "passed": false}
{"task_id": 20, "requirement": "Code Complexity", "completion": "import math\n\ndef is_woodall(x: int) -> bool:\n    # Handle edge cases\n    if x < 1:\n        return False\n\n    # Solve for n in the equation x = n * 2^n - 1\n    # Rearrange to: n * 2^n = x + 1\n    target = x + 1\n\n    # Use logarithms to approximate n\n    if target == 1:\n        return True  # Special case: n = 1, W_1 = 1\n\n    # Approximate n using logarithms\n    n_approx = math.log2(target)\n\n    # Check integer values around the approximation\n    n_candidate = math.floor(n_approx)\n    if n_candidate * (2 ** n_candidate) == target:\n        return True\n\n    n_candidate = math.ceil(n_approx)\n    if n_candidate * (2 ** n_candidate) == target:\n        return True\n\n    return False\n\n# Example usage:\nprint(is_woodall(1))    # True, because 1 * 2^1 - 1 = 1\nprint(is_woodall(7))    # True, because 2 * 2^2 - 1 = 7\nprint(is_woodall(23))   # True, because 3 * 2^3 - 1 = 23\nprint(is_woodall(10))   # False, 10 is not a Woodall number\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpnbcyl_lu.py\", line 27, in <module>\n    assert is_woodall(383) == True\nAssertionError", "passed": false}
{"task_id": 21, "requirement": "Code Complexity", "completion": "def multiples_of_num(n: int, m: int) -> list:\n    \"\"\"\n    Find m number of multiples of n.\n\n    Parameters:\n    n (int): The number whose multiples are to be found.\n    m (int): The number of multiples to find.\n\n    Returns:\n    list: A list containing the first m multiples of n.\n\n    Raises:\n    ValueError: If either m or n is negative.\n    \"\"\"\n    if m < 0 or n < 0:\n        raise ValueError(\"Both m and n must be non-negative integers.\")\n    return [n * i for i in range(1, m + 1)]\n\n# Example usage:\ntry:\n    n = 5\n    m = 10\n    result = multiples_of_num(n, m)\n    print(f\"The first {m} multiples of {n} are: {result}\")\nexcept ValueError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp1qoxjl2t.py\", line 13, in <module>\n    assert multiples_of_num(4,3)== [3,6,9,12]\nAssertionError", "passed": false}
{"task_id": 24, "requirement": "Code Complexity", "completion": "def binary_to_decimal(binary: str) -> int:\n    \"\"\"\n    Convert a binary string to its decimal equivalent.\n\n    :param binary: A string representing a binary number (e.g., '1010')\n    :return: The decimal equivalent of the binary number\n    :raises ValueError: If the input is not a valid binary string\n    \"\"\"\n    try:\n        # Use Python's built-in int() function with base 2 for conversion\n        return int(binary, 2)\n    except ValueError:\n        raise ValueError(\"Invalid binary number\")\n", "result": "failed: File \"/tmp/tmpp37rr3ho.py\", line 10\n    try: binary_to_decimal('102'); assert False, 'Expected ValueError' except ValueError as e: assert str(e) == 'Invalid binary number'\n                                                                       ^\nSyntaxError: invalid syntax", "passed": false}
{"task_id": 32, "requirement": "Code Complexity", "completion": "def max_prime_factors(n: int) -> int:\n    # Validate input\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    # Initialize the largest prime factor\n    largest_prime = 2\n    \n    # Remove all factors of 2\n    while n % largest_prime == 0:\n        n //= largest_prime\n    \n    # Check odd factors starting from 3\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_prime = factor\n            n //= factor\n        factor += 2\n    \n    # If n is still greater than 2, it is the largest prime factor\n    if n > 2:\n        largest_prime = n\n    \n    return largest_prime\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpgp0jvm6u.py\", line 37, in <module>\n    assert cc_visit(inspect.getsource(max_prime_factors))[0].complexity <= 5\nAssertionError", "passed": false}
{"task_id": 33, "requirement": "Code Complexity", "completion": "def decimal_to_binary(N: int) -> str:\n    \"\"\"\n    Convert a non-negative integer to its binary representation.\n\n    Args:\n        N (int): The non-negative integer to convert.\n\n    Returns:\n        str: The binary representation of the input number.\n\n    Raises:\n        ValueError: If the input is not a non-negative integer.\n    \"\"\"\n    if not isinstance(N, int) or N < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    return bin(N)[2:]\n\n# Example usage:\ndecimal_number = 13\nbinary_number = decimal_to_binary(decimal_number)\nprint(f\"The binary representation of {decimal_number} is {binary_number}\")\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp7v075pda.py\", line 9, in <module>\n    assert decimal_to_binary(10) == 1010\nAssertionError", "passed": false}
{"task_id": 35, "requirement": "Code Complexity", "completion": "def find_rect_num(n: int) -> int:\n    \"\"\"\n    Calculate the n-th rectangular number.\n\n    Parameters:\n    n (int): The position of the rectangular number to find.\n\n    Returns:\n    int: The n-th rectangular number.\n\n    Raises:\n    ValueError: If n is not a positive integer.\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"n must be a positive integer.\")\n    \n    return n * (n + 1)\n\n# Example usage:\nif __name__ == \"__main__\":\n    n = 5\n    result = find_rect_num(n)\n    print(f\"The {n}-th rectangular number is: {result}\")\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpnciwyogb.py\", line 21, in <module>\n    assert cc_visit(inspect.getsource(find_rect_num))[0].complexity == 1\nAssertionError", "passed": false}
{"task_id": 36, "requirement": "Code Complexity", "completion": "def find_nth_digit(p: int, q: int, N: int) -> int:\n    \"\"\"\n    Find the Nth digit in the decimal representation of the fraction p/q.\n\n    Args:\n        p (int): Numerator of the fraction.\n        q (int): Denominator of the fraction.\n        N (int): The position of the digit to find (1-based index).\n\n    Returns:\n        int: The Nth digit in the decimal representation of p/q.\n\n    Raises:\n        ValueError: If the denominator q is zero.\n    \"\"\"\n    if q == 0:\n        raise ValueError(\"Denominator cannot be zero\")\n\n    # Calculate the decimal representation of p/q\n    decimal = abs(p) / abs(q)\n    decimal_str = str(decimal).split('.')[1]\n\n    # Ensure N is within the range of the decimal digits\n    if N > len(decimal_str):\n        return 0  # Return 0 if N is out of range (or raise an error if preferred)\n\n    # Return the Nth digit\n    return int(decimal_str[N - 1])\n", "result": "passed", "passed": true}
{"task_id": 38, "requirement": "Code Complexity", "completion": "from typing import List, Union\n\ndef div_even_odd(numbers: List[int]) -> Union[int, float]:\n    first_even = next((num for num in numbers if num % 2 == 0), None)\n    first_odd = next((num for num in numbers if num % 2 != 0), None)\n\n    if first_even is None or first_odd is None:\n        raise ValueError(\"List must contain at least one even and one odd number.\")\n\n    if first_even == 0:\n        return 0\n\n    return first_even / first_odd\n", "result": "failed: File \"/tmp/tmpdt96d1q0.py\", line 14\n    try: div_even_odd([2, 4, 6]); assert False; except ValueError as e: assert str(e) == 'List must contain at least one even and one odd number.'\n                                                ^\nSyntaxError: invalid syntax", "passed": false}
{"task_id": 40, "requirement": "Code Complexity", "completion": "from collections import Counter\nfrom typing import List, Dict\n\ndef freq_element(nums: List[List[int]]) -> Dict[int, int]:\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in nums for item in sublist]\n    \n    # Use Counter to get the frequency of each element\n    frequency = Counter(flattened_list)\n    \n    return dict(frequency)\n\n# Example usage:\nlist_of_lists = [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\nresult = freq_element(list_of_lists)\nprint(result)\n", "result": "failed: File \"/tmp/tmphzwv9qmx.py\", line 16\n    try: freq_element('not a list'); assert False; except TypeError: assert True\n                                                   ^\nSyntaxError: invalid syntax", "passed": false}
{"task_id": 42, "requirement": "Code Complexity", "completion": "from collections import Counter\nfrom typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    # Check if the input is a list\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    # Handle empty array\n    if not arr:\n        return 0\n    \n    # Count occurrences of each element\n    element_counts = Counter(arr)\n    \n    # Sum elements that appear more than once\n    sum_repeated = 0\n    for element, count in element_counts.items():\n        if count > 1:\n            sum_repeated += element\n    \n    return sum_repeated\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpu4exqgim.py\", line 18, in <module>\n    assert find_sum([1,2,3,1,1,4,5,6],8) == 3\nTypeError: find_sum() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 43, "requirement": "Code Complexity", "completion": "import re\nfrom typing import Union\n\ndef text_match(text: str) -> str:\n    # Check if the input is a string\n    if not isinstance(text, str):\n        raise TypeError(\"Input must be a string.\")\n    \n    # Return 'Not matched!' for an empty string\n    if not text:\n        return \"Not matched!\"\n    \n    # Define the regex pattern to match sequences of lowercase letters joined by an underscore\n    pattern = r'^[a-z]+_[a-z]+$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    if re.match(pattern, text):\n        return \"Matched!\"\n    else:\n        return \"Not matched!\"\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpgut4xr8d.py\", line 17, in <module>\n    assert text_match(\"aab_cbbbc\") == 'Found a match!'\nAssertionError", "passed": false}
{"task_id": 45, "requirement": "Code Complexity", "completion": "from math import gcd\nfrom functools import reduce\nfrom typing import List\n\ndef get_gcd(numbers: List[int]) -> int:\n    \"\"\"\n    Compute the greatest common divisor (GCD) of an array of integers.\n\n    :param numbers: List of integers\n    :return: GCD of the array elements\n    :raises ValueError: If the input list is empty\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Input list cannot be empty.\")\n    \n    # Use reduce to apply the gcd function across the array\n    return reduce(gcd, numbers)\n\n# Example usage:\narray = [24, 36, 48, 60]\nresult = get_gcd(array)\nprint(f\"The GCD of {array} is {result}\")\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp0nnra7_z.py\", line 18, in <module>\n    assert get_gcd.__annotations__ == {'numbers': list, 'return': int}\nAssertionError", "passed": false}
{"task_id": 47, "requirement": "Code Complexity", "completion": "def compute_last_digit(a: int, b: int) -> int:\n    if a > b:\n        raise ValueError(\"a should not be greater than b\")\n    \n    if a == b:\n        return 1\n    \n    # Compute the product (a+1) * (a+2) * ... * b modulo 10\n    result = 1\n    for i in range(a + 1, b + 1):\n        result = (result * i) % 10\n        if result == 0:\n            break  # If result is 0, it will remain 0\n    return result\n\n# Example usage:\nprint(compute_last_digit(3, 5))  # Output: 2 (since 5! / 3! = 20, last digit is 0)\nprint(compute_last_digit(7, 7))  # Output: 1 (since 7! / 7! = 1, last digit is 1)\nprint(compute_last_digit(5, 3))  # Raises ValueError: a should not be greater than b\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpe1di7pap.py\", line 16, in <module>\n    print(compute_last_digit(5, 3))  # Raises ValueError: a should not be greater than b\n  File \"/tmp/tmpe1di7pap.py\", line 3, in compute_last_digit\n    raise ValueError(\"a should not be greater than b\")\nValueError: a should not be greater than b", "passed": false}
{"task_id": 51, "requirement": "Code Complexity", "completion": "def check_equilateral(a: int, b: int, c: int) -> bool:\n    \"\"\"\n    Check if a triangle is equilateral.\n\n    Parameters:\n    a (int): Length of the first side of the triangle.\n    b (int): Length of the second side of the triangle.\n    c (int): Length of the third side of the triangle.\n\n    Returns:\n    bool: True if the triangle is equilateral, False otherwise.\n\n    Raises:\n    ValueError: If any of the inputs are non-positive integers.\n    \"\"\"\n    # Check if all sides are positive integers\n    if a <= 0 or b <= 0 or c <= 0:\n        raise ValueError(\"All sides must be positive integers.\")\n\n    # Check if all sides are equal\n    return a == b == c\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp2nmb4so7.py\", line 26, in <module>\n    assert cc_visit(inspect.getsource(check_equilateral))[0].complexity ==1\nAssertionError", "passed": false}
{"task_id": 52, "requirement": "Code Complexity", "completion": "def parallelogram_area(base: float, height: float) -> float:\n    \"\"\"\n    Calculate the area of a parallelogram.\n\n    Parameters:\n    base (float): The length of the base of the parallelogram.\n    height (float): The height of the parallelogram.\n\n    Returns:\n    float: The area of the parallelogram.\n\n    Raises:\n    TypeError: If the inputs are not numerical.\n    \"\"\"\n    if not isinstance(base, (int, float)) or not isinstance(height, (int, float)):\n        raise TypeError(\"Both base and height must be numerical values.\")\n    \n    return base * height\n\n# Example usage:\ntry:\n    base = 5.0\n    height = 3.0\n    area = parallelogram_area(base, height)\n    print(f\"The area of the parallelogram is: {area}\")\nexcept TypeError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpc16bskw5.py\", line 41, in <module>\n    assert cc_visit(inspect.getsource(parallelogram_area))[0].complexity ==1\nAssertionError", "passed": false}
{"task_id": 53, "requirement": "Code Complexity", "completion": "def check_equality(s: str) -> str:\n    \"\"\"\n    Check if the first and last characters of a given string are equal.\n\n    Args:\n        s (str): The input string to check.\n\n    Returns:\n        str: 'Equal' if the first and last characters are the same, otherwise 'Not Equal'.\n\n    Raises:\n        TypeError: If the input is not a string.\n    \"\"\"\n    # Ensure the input is a string\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n\n    # Handle empty strings by returning 'Equal'\n    if not s:\n        return \"Equal\"\n\n    # Compare the first and last characters\n    return \"Equal\" if s[0] == s[-1] else \"Not Equal\"\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmprckkmlvi.py\", line 24, in <module>\n    assert cc_visit(inspect.getsource(check_equality))[0].complexity <=3\nAssertionError", "passed": false}
{"task_id": 56, "requirement": "Code Complexity", "completion": "def check(n: int) -> bool:\n    \"\"\"\n    Check if a given number is one less than twice its reverse.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is one less than twice its reverse, False otherwise.\n\n    Raises:\n        TypeError: If the input is not an integer.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    \n    # Reverse the number\n    reversed_n = int(str(n)[::-1])\n    \n    # Check if the number is one less than twice its reverse\n    return n == 2 * reversed_n - 1\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpe475eajj.py\", line 18, in <module>\n    assert check(1) == False\nAssertionError", "passed": false}
{"task_id": 58, "requirement": "Code Complexity", "completion": "def opposite_signs(a: int, b: int) -> bool:\n    \"\"\"\n    Check if two integers have opposite signs.\n\n    Parameters:\n    a (int): The first integer.\n    b (int): The second integer.\n\n    Returns:\n    bool: True if the integers have opposite signs, False otherwise.\n\n    Raises:\n    TypeError: If either of the inputs is not an integer.\n    \"\"\"\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError(\"Both inputs must be integers.\")\n    \n    return (a ^ b) < 0\n\n# Example usage:\nprint(opposite_signs(5, -3))  # Output: True\nprint(opposite_signs(-4, -7))  # Output: False\nprint(opposite_signs(10, 20))  # Output: False\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpo272__gq.py\", line 28, in <module>\n    assert opposite_signs(0, 1) == True\nAssertionError", "passed": false}
