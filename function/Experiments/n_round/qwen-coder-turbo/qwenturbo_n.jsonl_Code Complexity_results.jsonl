{"task_id": 11, "requirement": "Code Complexity", "completion": "from typing import Union\n\ndef remove_occ(s: str, ch: str) -> str:\n    # Check if the second parameter is a single character\n    if len(ch) != 1:\n        raise ValueError('Second parameter must be a single character.')\n    \n    # Find all occurrences of the character\n    indices = [i for i, c in enumerate(s) if c == ch]\n    \n    # Return the original string if no occurrences are found\n    if not indices:\n        return s\n    \n    # Remove the first and last occurrence\n    s = s[:indices[0]] + s[indices[0]+1:]\n    if len(indices) > 1:\n        s = s[:indices[-1]-1] + s[indices[-1]:]\n    \n    return s\n\n# Example usage:\nresult = remove_occ(\"hello world\", \"o\")\nprint(result)  # Output: \"hell wrld\"\n", "result": "passed", "passed": true}
{"task_id": 14, "requirement": "Code Complexity", "completion": "from typing import Union\n\ndef find_volume(base_area: Union[int, float], height: Union[int, float], length: Union[int, float]) -> float:\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Parameters:\n    - base_area: Area of the triangular base.\n    - height: Height of the prism.\n    - length: Length of the prism.\n    \n    Returns:\n    - Volume of the triangular prism.\n    \n    Raises:\n    - ValueError: If any of the inputs are non-positive or non-numeric.\n    \"\"\"\n    # Ensure all inputs are positive numbers\n    if not all(isinstance(x, (int, float)) and x > 0 for x in [base_area, height, length]):\n        raise ValueError('All dimensions must be positive numbers.')\n    \n    # Calculate the volume of the prism\n    volume = base_area * height * length\n    \n    return volume\n\n# Example usage:\nbase_area = 6  # Area of the triangular base (e.g., 0.5 * base * height)\nheight = 10   # Height of the prism\nlength = 8    # Length of the prism\n\ntry:\n    volume = find_volume(base_area, height, length)\n    print(f\"The volume of the triangular prism is: {volume}\")\nexcept ValueError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpoh3olw2w.py\", line 18, in <module>\n    assert find_volume(10,8,6) == 240\nAssertionError", "passed": false}
{"task_id": 15, "requirement": "Code Complexity", "completion": "import re\n\ndef split_lowerstring(text: str) -> list:\n    if not isinstance(text, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Use regular expression to find all occurrences where a lowercase letter is followed by any non-lowercase characters\n    segments = re.findall(r'[a-z][^a-z]*', text)\n    \n    return segments\n\n# Example usage:\ninput_string = \"helloWorldThisIsPython\"\nresult = split_lowerstring(input_string)\nprint(result)  # Output: ['hello', 'World', 'This', 'Is', 'Python']\n", "result": "failed: File \"/tmp/tmpbvhca3kb.py\", line 16\n    try: split_lowerstring(123); assert False, 'Expected TypeError' except TypeError: pass\n                                                                    ^\nSyntaxError: invalid syntax", "passed": false}
{"task_id": 16, "requirement": "Code Complexity", "completion": "import re\n\ndef text_lowercase_underscore(text: str) -> str:\n    if not isinstance(text, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Define the regex pattern for lowercase letters joined with an underscore\n    pattern = r'[a-z]+_[a-z]+'\n    \n    # Check if the pattern exists in the text\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n\n# Example usage:\ntext = \"hello_world this_is_python example_text\"\nresult = text_lowercase_underscore(text)\nprint(result)  # Output: Found a match!\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpgi7k2eid.py\", line 18, in <module>\n    assert text_lowercase_underscore(\"Aaab_abbbc\")==('Not matched!')\nAssertionError", "passed": false}
{"task_id": 17, "requirement": "Code Complexity", "completion": "def square_perimeter(side_length: int) -> int:\n    \"\"\"\n    Calculate the perimeter of a square.\n\n    Args:\n        side_length (int): The length of one side of the square.\n\n    Returns:\n        int: The perimeter of the square.\n    \n    Raises:\n        ValueError: If the input side_length is negative.\n    \"\"\"\n    # Check if the side length is negative\n    if side_length < 0:\n        raise ValueError(\"Side length must be a non-negative integer.\")\n\n    # Return the perimeter of the square\n    return 4 * side_length\n\n# Example usage:\ntry:\n    side = -5\n    perimeter = square_perimeter(side)\n    print(f\"The perimeter of a square with side length {side} is {perimeter}.\")\nexcept ValueError as e:\n    print(e)\n\nside = 5\nperimeter = square_perimeter(side)\nprint(f\"The perimeter of a square with side length {side} is {perimeter}.\")\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp6uxgod8x.py\", line 35, in <module>\n    assert square_perimeter.__annotations__ == {'a': int, 'return': int}\nAssertionError", "passed": false}
{"task_id": 20, "requirement": "Code Complexity", "completion": "def is_woodall(x: int) -> bool:\n    # Raise TypeError if the input is not an integer\n    if not isinstance(x, int):\n        raise TypeError(\"Input must be an integer\")\n    \n    # Handle edge case: 0 is not a Woodall number\n    if x <= 0:\n        return False\n    \n    # Check if x is a Woodall number\n    n = 1\n    while n * (2 ** n) - 1 <= x:\n        if n * (2 ** n) - 1 == x:\n            return True\n        n += 1\n    \n    return False\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpwe7lhcyd.py\", line 32, in <module>\n    assert cc_visit(inspect.getsource(is_woodall))[0].complexity == 1\nAssertionError", "passed": false}
{"task_id": 21, "requirement": "Code Complexity", "completion": "def multiples_of_num(n: int, m: int) -> list:\n    \"\"\"\n    This function returns a list of the first m multiples of n.\n    \n    Parameters:\n    n (int): The number for which to find multiples.\n    m (int): The number of multiples to find.\n    \n    Returns:\n    list: A list containing the first m multiples of n.\n    \"\"\"\n    if m < 0:\n        raise ValueError(\"The number of multiples must be a non-negative integer.\")\n    \n    return [i * n for i in range(1, m + 1)]\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpipk075gg.py\", line 5, in <module>\n    assert multiples_of_num(4,3)== [3,6,9,12]\nAssertionError", "passed": false}
{"task_id": 24, "requirement": "Code Complexity", "completion": "def binary_to_decimal(binary_str: str) -> int:\n    \"\"\"\n    Convert a binary number (as a string) to its decimal equivalent.\n\n    Parameters:\n    binary_str (str): The binary number as a string.\n\n    Returns:\n    int: The decimal equivalent of the binary number.\n    \"\"\"\n    if not all(char in '01' for char in binary_str):\n        raise ValueError('Invalid binary number')\n\n    decimal_value = 0\n    length = len(binary_str)\n\n    for i in range(length):\n        power = length - i - 1\n        if binary_str[i] == '1':\n            decimal_value += 2 ** power\n\n    return decimal_value\n\n# Example usage:\nbinary_number = \"1101\"\ntry:\n    decimal_number = binary_to_decimal(binary_number)\n    print(f\"The decimal equivalent of {binary_number} is {decimal_value}\")\nexcept ValueError as e:\n    print(e)\n", "result": "failed: File \"/tmp/tmpfumli8tf.py\", line 21\n    try: binary_to_decimal('102'); assert False, 'Expected ValueError' except ValueError as e: assert str(e) == 'Invalid binary number'\n                                                                       ^\nSyntaxError: invalid syntax", "passed": false}
{"task_id": 32, "requirement": "Code Complexity", "completion": "from typing import Union\n\ndef max_prime_factors(n: int) -> Union[int, str]:\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    # Initialize the largest prime factor\n    max_factor = -1\n    \n    # Divide n by 2 until it becomes odd\n    while n % 2 == 0:\n        max_factor = 2\n        n //= 2\n    \n    # Check for odd factors from 3 onwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            max_factor = factor\n            n //= factor\n        factor += 2\n    \n    # If n is still greater than 2, then n itself is a prime number\n    if n > 2:\n        max_factor = n\n    \n    return max_factor\n\n# Example usage:\nnumber = 600851475143\ntry:\n    print(f\"The largest prime factor of {number} is {max_prime_factors(number)}\")\nexcept ValueError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmperwpkqz1.py\", line 41, in <module>\n    assert max_prime_factors.__annotations__ == {'n': int, 'return': int}\nAssertionError", "passed": false}
{"task_id": 33, "requirement": "Code Complexity", "completion": "def decimal_to_binary(decimal_number: int) -> str:\n    if not isinstance(decimal_number, int) or decimal_number < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    # Special case for 0\n    if decimal_number == 0:\n        return \"0\"\n    \n    binary_number = \"\"\n    while decimal_number > 0:\n        binary_number = str(decimal_number % 2) + binary_number\n        decimal_number //= 2\n    \n    return binary_number\n\n# Example usage:\nprint(decimal_to_binary(10))  # Output: \"1010\"\nprint(decimal_to_binary(255)) # Output: \"11111111\"\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpyyqkess3.py\", line 15, in <module>\n    assert decimal_to_binary(10) == 1010\nAssertionError", "passed": false}
{"task_id": 35, "requirement": "Code Complexity", "completion": "def find_rect_num(n: int) -> int:\n    \"\"\"\n    Calculate the n-th triangular number.\n\n    Parameters:\n    n (int): The position of the triangular number in the sequence.\n\n    Returns:\n    int: The n-th triangular number.\n    \"\"\"\n    return n * (n + 1) // 2\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp73hpicgm.py\", line 3, in <module>\n    assert find_rect_num(4) == 20\nAssertionError", "passed": false}
{"task_id": 36, "requirement": "Code Complexity", "completion": "from typing import Tuple\n\ndef find_nth_digit(numerator: int, denominator: int, n: int) -> int:\n    \"\"\"\n    Find the nth digit in the decimal representation of the proper fraction numerator/denominator.\n    \n    :param numerator: The numerator of the fraction.\n    :param denominator: The denominator of the fraction.\n    :param n: The position of the digit to be found (1-based index).\n    :return: The nth digit in the decimal representation of the fraction.\n    \"\"\"\n    if denominator == 0:\n        raise ValueError(\"Denominator cannot be zero\")\n    \n    if numerator >= denominator:\n        raise ValueError(\"Numerator must be less than the denominator for a proper fraction.\")\n    \n    quotient_digits = []\n    remainder = numerator % denominator\n    seen_remainders = {}\n    \n    pos = 0\n    \n    while remainder != 0:\n        if remainder in seen_remainders:\n            start = seen_remainders[remainder]\n            repeat_start = quotient_digits[:start]\n            repeat_end = quotient_digits[start:]\n            n_in_repeating = (n - start) % len(repeat_end)\n            return repeat_end[n_in_repeating]\n        \n        seen_remainders[remainder] = pos\n        \n        remainder *= 10\n        digit = remainder // denominator\n        quotient_digits.append(digit)\n        remainder %= denominator\n        \n        pos += 1\n    \n    return quotient_digits[n - 1]\n\n# Example usage:\nnumerator = 1\ndenominator = 3\nn = 5\nprint(find_nth_digit(numerator, denominator, n))  # Output: 3 (since 1/3 = 0.3333...)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpwsk9gx51.py\", line 38, in <module>\n    assert find_nth_digit.__annotations__ == {'p': int, 'q': int, 'N': int, 'return': int}\nAssertionError", "passed": false}
{"task_id": 38, "requirement": "Code Complexity", "completion": "from typing import List\n\ndef div_even_odd(lst: List[int]) -> float:\n    # Find the first even number\n    for num in lst:\n        if num % 2 == 0:\n            first_even = num\n            break\n    else:\n        raise ValueError(\"The list must contain at least one even number.\")\n    \n    # Find the first odd number\n    for num in lst:\n        if num % 2 != 0:\n            first_odd = num\n            break\n    else:\n        raise ValueError(\"The list must contain at least one odd number.\")\n    \n    # Return the division of the first even number by the first odd number\n    return first_even / first_odd\n\n# Example usage:\nlst = [5, 7, 4, 9, 2]\nresult = div_even_odd(lst)\nprint(f\"The division of the first even and odd number is: {result}\")\n", "result": "failed: File \"/tmp/tmpmo3vedtk.py\", line 27\n    try: div_even_odd([2, 4, 6]); assert False; except ValueError as e: assert str(e) == 'List must contain at least one even and one odd number.'\n                                                ^\nSyntaxError: invalid syntax", "passed": false}
{"task_id": 40, "requirement": "Code Complexity", "completion": "from collections import Counter\n\ndef freq_element(nums: list[list[int]]) -> dict[int, int]:\n    # Ensure the input is a list of lists\n    if not isinstance(nums, list) or not all(isinstance(sublist, list) for sublist in nums):\n        raise TypeError(\"Input must be a list of lists\")\n    \n    # Flatten the list of lists into a single list\n    flattened_list = sum(nums, [])\n    \n    # Use Counter to count the frequency of each element\n    frequency_counter = Counter(flattened_list)\n    \n    return frequency_counter\n\n# Example usage:\nlist_of_lists = [[1, 2, 3], [2, 3, 4], [4, 5]]\nresult = freq_element(list_of_lists)\nprint(result)  # Output: Counter({2: 2, 3: 2, 4: 2, 1: 1, 5: 1})\n", "result": "failed: File \"/tmp/tmpu9w7naxw.py\", line 18\n    try: freq_element('not a list'); assert False; except TypeError: assert True\n                                                   ^\nSyntaxError: invalid syntax", "passed": false}
{"task_id": 42, "requirement": "Code Complexity", "completion": "from typing import List\n\ndef find_sum(arr: List[int]) -> int:\n    # If the input is not a list, raise a TypeError\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list\")\n    \n    # Dictionary to count occurrences of each element\n    element_count = {}\n    \n    # Iterate through the array and update counts\n    for num in arr:\n        element_count[num] = element_count.get(num, 0) + 1\n    \n    # Calculate the sum of repeated elements\n    repeated_sum = sum(num * count for num, count in element_count.items() if count > 1)\n    \n    return repeated_sum\n\n# Example usage:\narr = [1, 2, 3, 2, 4, 5, 3, 6]\nprint(find_sum(arr))  # Output should be 10 (2+2+3+3)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpei938flh.py\", line 17, in <module>\n    assert find_sum([1,2,3,1,1,4,5,6],8) == 3\nTypeError: find_sum() takes 1 positional argument but 2 were given", "passed": false}
{"task_id": 43, "requirement": "Code Complexity", "completion": "import re\n\ndef text_match(text: str) -> str:\n    \"\"\"\n    This function checks if the input string contains sequences of lowercase letters joined with an underscore.\n    \n    Args:\n    text (str): The input string to check.\n    \n    Returns:\n    str: 'Matched!' if the pattern is found, otherwise 'Not matched!'\n    \"\"\"\n    # Define the regex pattern for lowercase letters joined with an underscore\n    pattern = r'^[a-z]+_[a-z]+$'\n    \n    # Check if the input is a string\n    if not isinstance(text, str):\n        raise TypeError(\"Input must be a string\")\n    \n    # Check if the input string is empty\n    if len(text) == 0:\n        return 'Not matched!'\n    \n    # Perform the regex matching\n    if re.match(pattern, text):\n        return 'Matched!'\n    else:\n        return 'Not matched!'\n\n# Example usage:\ntry:\n    input_text = \"hello_world\"\n    result = text_match(input_text)\n    print(result)  # Output: Matched!\nexcept TypeError as e:\n    print(e)\n\ntry:\n    input_text = \"Hello_World\"\n    result = text_match(input_text)\n    print(result)  # Output: Not matched!\nexcept TypeError as e:\n    print(e)\n\ntry:\n    input_text = \"\"\n    result = text_match(input_text)\n    print(result)  # Output: Not matched!\nexcept TypeError as e:\n    print(e)\n\ntry:\n    input_text = 12345\n    result = text_match(input_text)\n    print(result)  # Should not reach this line due to exception\nexcept TypeError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpk3z2vqio.py\", line 41, in <module>\n    assert text_match(\"aab_cbbbc\") == 'Found a match!'\nAssertionError", "passed": false}
{"task_id": 45, "requirement": "Code Complexity", "completion": "import math\n\ndef get_gcd(numbers: list) -> int:\n    \"\"\"\n    Find the greatest common divisor (GCD) of an array of integers.\n    \n    Parameters:\n    numbers (list): A list of integers for which to find the GCD.\n    \n    Returns:\n    int: The GCD of the array elements.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"Array must contain at least one element\")\n    \n    current_gcd = numbers[0]\n    for num in numbers[1:]:\n        current_gcd = math.gcd(current_gcd, num)\n    \n    return current_gcd\n\n# Example usage:\narr = [24, 60, 36]\nprint(get_gcd(arr))  # Output should be 12\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpztpdwp46.py\", line 15, in <module>\n    try: get_gcd([])\n  File \"/tmp/tmpztpdwp46.py\", line 4, in get_gcd\n    raise ValueError(\"Array must contain at least one element\")\nValueError: Array must contain at least one element\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpztpdwp46.py\", line 16, in <module>\n    except ValueError as e: assert str(e) == 'Input list cannot be empty.'\nAssertionError", "passed": false}
{"task_id": 47, "requirement": "Code Complexity", "completion": "from typing import Union\n\ndef compute_last_digit(a: int, b: int) -> int:\n    # Check if a is greater than b\n    if a > b:\n        raise ValueError('a should not be greater than b')\n    \n    # Edge case where a equals b\n    if a == b:\n        return 1\n    \n    # Initialize the last digit result\n    last_digit_result = 1\n    \n    # If either a or b is less than 5, compute the last digits of factorials manually\n    for i in range(a + 1, b + 1):\n        last_digit_result = (last_digit_result * (i % 10)) % 10\n    \n    return last_digit_result\n\n# Example usage:\nprint(compute_last_digit(3, 7))  # Output should be 2\nprint(compute_last_digit(4, 8))  # Output should be 2\nprint(compute_last_digit(5, 9))  # Output should be 0\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpylw_2kqt.py\", line 30, in <module>\n    assert cc_visit(inspect.getsource(compute_last_digit))[0].complexity <=3\nAssertionError", "passed": false}
{"task_id": 51, "requirement": "Code Complexity", "completion": "def check_equilateral(a: int, b: int, c: int) -> bool:\n    \"\"\"\n    Check if a triangle with sides a, b, and c is equilateral.\n    \n    Raises:\n    ValueError: If any of the inputs are non-positive integers.\n    \n    Returns:\n    bool: True if the triangle is equilateral, False otherwise.\n    \"\"\"\n    # Validate input values\n    if not all(isinstance(x, int) and x > 0 for x in [a, b, c]):\n        raise ValueError(\"All inputs must be positive integers.\")\n    \n    # Check if the triangle is equilateral\n    return a == b == c\n\n# Example usage:\ntry:\n    side1 = 5\n    side2 = 5\n    side3 = 5\n    print(check_equilateral(side1, side2, side3))  # Output: True\n    \n    side4 = -1\n    side5 = 5\n    side6 = 5\n    print(check_equilateral(side4, side5, side6))  # Should raise ValueError\nexcept ValueError as e:\n    print(e)\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpixjjgu1k.py\", line 38, in <module>\n    assert cc_visit(inspect.getsource(check_equilateral))[0].complexity ==1\nAssertionError", "passed": false}
{"task_id": 52, "requirement": "Code Complexity", "completion": "def parallelogram_area(base: float, height: float) -> float:\n    \"\"\"\n    Calculate the area of a parallelogram.\n\n    Parameters:\n    base (float): The length of the base of the parallelogram.\n    height (float): The height of the parallelogram.\n\n    Returns:\n    float: The area of the parallelogram.\n    \"\"\"\n    # Assert that both base and height are non-negative\n    assert base >= 0 and height >= 0, \"Base and height must be non-negative numbers.\"\n    \n    # Calculate the area\n    return base * height\n\n# Example usage:\nbase = 5\nheight = 3\narea = parallelogram_area(base, height)\nprint(f\"The area of the parallelogram with base {base} and height {height} is {area}.\")\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpdjrn5tel.py\", line 39, in <module>\n    assert cc_visit(inspect.getsource(parallelogram_area))[0].complexity ==1\nAssertionError", "passed": false}
{"task_id": 53, "requirement": "Code Complexity", "completion": "from typing import TypeVar\n\nT = TypeVar('T')\n\ndef check_equality(s: T) -> str:\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    \n    if s != s[::-1]:\n        return \"Not Equal\"\n    else:\n        return \"Equal\"\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp3950wvcr.py\", line 10, in <module>\n    assert check_equality(\"abcda\") == \"Equal\"\nAssertionError", "passed": false}
{"task_id": 56, "requirement": "Code Complexity", "completion": "def reverse_number(n):\n    \"\"\"Helper function to reverse the digits of a number.\"\"\"\n    reversed_n = 0\n    while n > 0:\n        reversed_n = reversed_n * 10 + n % 10\n        n //= 10\n    return reversed_n\n\ndef check(number: int) -> bool:\n    \"\"\"Function to check if the number is one less than twice its reverse.\"\"\"\n    if not isinstance(number, int):\n        raise TypeError(\"Input must be an integer\")\n    \n    # Reverse the number using slicing (more concise and easier to understand)\n    reversed_num = int(str(number)[::-1])\n    \n    # Check the condition\n    return number == 2 * reversed_num - 1\n\n# Example usage:\nprint(check(19))  # True, because 2 * 91 - 1 = 181\nprint(check(123)) # False, because 2 * 321 - 1 != 123\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmp313_4r8w.py\", line 29, in <module>\n    assert check(1) == False\nAssertionError", "passed": false}
{"task_id": 58, "requirement": "Code Complexity", "completion": "def opposite_signs(a: int, b: int) -> bool:\n    \"\"\"\n    Check whether two given integers have opposite signs or not.\n\n    Args:\n        a (int): First integer.\n        b (int): Second integer.\n\n    Returns:\n        bool: True if the integers have opposite signs, False otherwise.\n\n    Raises:\n        TypeError: If either input is not an integer.\n    \"\"\"\n    \n    # Ensure the inputs are integers\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError(\"Both inputs must be integers.\")\n    \n    # Check if the integers have opposite signs\n    return (a < 0) != (b < 0)\n\n# Example usage:\nnum1 = -5\nnum2 = 10\nprint(opposite_signs(num1, num2))  # Output: True\n\nnum3 = 7\nnum4 = 9\nprint(opposite_signs(num3, num4))  # Output: False\n", "result": "failed: Traceback (most recent call last):\n  File \"/tmp/tmpzfd066bx.py\", line 33, in <module>\n    assert opposite_signs(0, 1) == True\nAssertionError", "passed": false}
